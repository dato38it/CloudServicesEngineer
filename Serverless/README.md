# Serverless
<p><strong>Task:</strong><br />Создаём вашу первую функцию<br />Мы уже достаточно сказали о том, что создавать облачные функции &mdash; просто. Давайте сделаем это на практике.<br /><strong>Decision:</strong><br />На главной странице консоли управления в списке сервисов выберите Cloud Functions:<br />На открывшейся странице нажмите кнопку Создать функцию:<br />Укажите имя функции, введите короткое описание того, что она будет делать, и нажмите кнопку Создать:<br />Затем выберите среду выполнения кода и нажмите кнопку Продолжить:<br />По умолчанию сервис предлагает создать Hello World &mdash; файл с примером кода на выбранном языке программирования. Этот файл будет создан и автоматически загружен в контейнер. В поле Способ укажите Редактор кода и выберите файл index.go.<br />По умолчанию сервис предлагает работать с редактором кода прямо в веб-интерфейсе (как на скриншоте выше). Однако вместо этого вы можете загрузить файл с кодом из бакета Object Storage (этот способ подойдёт для файлов больше 3,5 МБ) или загрузить ZIP-архив с кодом с локальной машины. Переключатель способа добавления кода находится прямо над окном редактора.<br />Код вашей функции может находиться как в одном файле, так и в нескольких. Вы также можете создавать папки. При этом обязательно нужно указывать точку входа &mdash; часть кода, которая будет вызываться первой и принимать параметры вызова. Формат точки входа &mdash; &lt;имя файла с функцией&gt;.&lt;имя обработчика вызова&gt;. Например, index.Handler.<br />Вверху справа нажмите кнопку Создать версию, чтобы сохранить текущее состояние функции.<br />Сервис создаст версию функции и покажет справочную страницу о ней.<br />Как протестировать созданную функцию<br />Теперь в панели слева перейдите на вкладку Тестирование. В поле Шаблон данных выберите HTTPS-вызов. Сервис автоматически сгенерирует входные данные в формате JSON.<br />Под полем с входными данными нажмите кнопку Запустить тест. Сервис выполнит HTTPS-вызов созданной функции и сформирует ответ (также в формате JSON).<br /><strong>Task:</strong><br />Запускаем функцию с помощью CLI.<br />В предыдущей практической работе вы познакомились с созданием функции через консоль управления. <br />На этом уроке вы научитесь создавать функцию с помощью интерфейса командной строки (утилиты yc).<br />Пользоваться консолью управления бывает очень удобно, но вести большой проект всё же лучше локально, с помощью среды разработки. <br />Артефакты локальной разработки можно с лёгкостью переносить в облако с помощью консольных утилит. <br /><strong>Decision:</strong><br />Шаг 1. Создание сервисного аккаунта<br />Создание аккаунта<br />Для начала убедитесь, что у вас установлена и инициализирована утилита yc.<br />У вас уже есть сервисные аккаунты, созданные на предыдущих занятиях. Однако гораздо лучше, когда для каждой конкретной задачи (или блока задач) вы заводите отдельный сервисный аккаунт. Это обеспечивает прозрачность в управлении доступом и контроле за ролями в сервисах.<br />Предварительно установите утилиту jq, она потребуется для выполнения задания:<br />sudo apt install jq <br />Создайте сервисный аккаунт с именем service-account-for-cf:<br />export SERVICE_ACCOUNT=$(yc iam service-account create \<br />&nbsp; --name service-account-for-cf \<br />&nbsp; --description "service account for cloud functions" \<br />&nbsp; --format json | jq -r .) <br />Проверьте текущий список сервисных аккаунтов:<br />yc iam service-account list<br />echo $SERVICE_ACCOUNT <br />После проверки запишите идентификатор (ID) созданного сервисного аккаунта в переменную SERVICE_ACCOUNT_ID:<br />echo "export SERVICE_ACCOUNT_ID=&lt;идентификатор_сервисного_аккаунта&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $SERVICE_ACCOUNT_ID <br />Назначение роли сервисному аккаунту<br />Добавьте вновь созданному сервисному аккаунту роль editor:<br />echo "export FOLDER_ID=$(yc config get folder-id)" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc <br />echo $FOLDER_ID<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_ID \<br />&nbsp; --role editor <br />Не удаляйте файл ~/.bashrc после прохождения практической работы, он понадобится нам в дальнейшем.<br />Шаг 2. Создание и настройка функции<br />Создание функции<br />Создайте функцию с именем my-first-function:<br />yc serverless function create --name my-first-function <br />Вы получите URL, по которому можно будет сделать вызов функции http_invoke_url. По умолчанию функция будет непубличной.<br />Загрузка кода функции<br />Создайте файл&nbsp; index.py :<br />sudo nano index.py <br />Добавьте в index.py следующее содержимое:<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': 200,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': 'Hello World!',<br />&nbsp;&nbsp;&nbsp; } <br />Успешное выполнение этой функции вернёт небольшую веб-страницу.<br />Загрузите код функции в облако и создайте её версию. Для этого перейдите в папку с файлом index.py и выполните команду:<br />yc serverless function version create \<br />&nbsp;&nbsp;&nbsp; --function-name my-first-function \<br />&nbsp;&nbsp;&nbsp; --memory 256m \<br />&nbsp;&nbsp;&nbsp; --execution-timeout 5s \<br />&nbsp;&nbsp;&nbsp; --runtime python37 \<br />&nbsp;&nbsp;&nbsp; --entrypoint index.handler \<br />&nbsp;&nbsp;&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp;&nbsp;&nbsp; --source-path index.py <br />Успешное выполнение команды приведёт к созданию версии функции. С помощью консоли управления убедитесь, что версия создана.<br />Вызов функции<br />Получите список функций, а затем &mdash; информацию о функции my-first-function:<br />yc serverless function list<br />yc serverless function version list --function-name my-first-function <br />В результате вызова последней команды из столбца FUNCTION ID вы узнаете идентификатор функции и сможете сделать вызов функции с помощью следующей команды:<br />yc serverless function invoke &lt;идентификатор_функции&gt; <br />По умолчанию функция создаётся непубличной. Чтобы сделать функцию my-first-function публичной, выполните следующую команду:<br />yc serverless function allow-unauthenticated-invoke my-first-function <br />После этого вы сможете вызвать её в браузере. Получите параметр http_invoke_url для функции my-first-function:<br />yc serverless function get my-first-function <br />Введите значение параметра http_invoke_url в браузере и наслаждайтесь вызовом вашей функции.<br /><strong>Decision:</strong><br />$ sudo apt install jq<br />$ export SERVICE_ACCOUNT=$(yc iam service-account create \<br />&nbsp; --name service-account-for-cf \<br />&nbsp; --description "service account for cloud functions" \<br />&nbsp; --format json | jq -r .) <br />$ yc iam service-account list<br />$ echo $SERVICE_ACCOUNT<br />$ echo "export SERVICE_ACCOUNT_ID=YOUR-ID" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $SERVICE_ACCOUNT_ID<br />$ echo "export FOLDER_ID=$(yc config get folder-id)" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $FOLDER_ID<br />YOUR-ID1<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_ID \<br />&nbsp; --role editor <br />$ yc serverless function create --name my-first-function<br />$ vim index.py<br />$ cat index.py<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': 200,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': 'Hello World!',<br />&nbsp;&nbsp;&nbsp; }<br />$ yc serverless function version create \<br />&nbsp;&nbsp;&nbsp; --function-name my-first-function \<br />&nbsp;&nbsp;&nbsp; --memory 256m \<br />&nbsp;&nbsp;&nbsp; --execution-timeout 5s \<br />&nbsp;&nbsp;&nbsp; --runtime python37 \<br />&nbsp;&nbsp;&nbsp; --entrypoint index.handler \<br />&nbsp;&nbsp;&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp;&nbsp;&nbsp; --source-path index.py<br />$ yc serverless function list<br />$ yc serverless function version list --function-name my-first-function<br />$ yc serverless function invoke YOUR-ID2<br />$ yc serverless function allow-unauthenticated-invoke my-first-function<br />$ yc serverless function get my-first-function<br /><strong>Task:</strong><br />Создание триггера от Object Storage.<br />В предыдущем практическом уроке вы познакомились с созданием одной функции с помощью интерфейса командной строки (yc). <br />В этом уроке мы продолжим разработку этой функции: модифицируем её содержание, добавим переменные окружения и т.д.<br /><strong>Decision:</strong><br />Шаг 1. Модификация сервисного аккаунта<br />Добавление роли сервисному аккаунту<br />По итогам прохождения предыдущей практической работы у вас есть сервисный аккаунт с именем service-account-for-cf. Для работы с Object Storage добавьте этому сервисному аккаунту роль storage.editor:<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp;&nbsp;&nbsp; --role storage.editor \<br />&nbsp;&nbsp;&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_ID <br />Создание ключа доступа для сервисного аккаунта<br />Этот этап нужен для получения идентификатора ключа доступа и секретного ключа, которые будут использованы для загрузки файлов в Object Storage, а также в том случае, если на следующем шаге для создания бакета в Object Storage вы планируете использовать Terraform.<br />Для создания ключа доступа необходимо вызвать следующую команду:<br />yc iam access-key create --service-account-name service-account-for-cf <br />В результате вы получите примерно следующее:<br />access_key:<br />&nbsp;&nbsp;&nbsp; id: ajefraollq5puj2tir1o<br />&nbsp;&nbsp;&nbsp; service_account_id: ajetdv28pl0a1a8r41f0<br />&nbsp;&nbsp;&nbsp; created_at: "2021-08-23T21:13:05.677319393Z"<br />&nbsp;&nbsp;&nbsp; key_id: BTPNvWthv0ZX2xVmlPIU<br />secret: cWLQ0HrTM0k_qAac43cwMNJA8VV_rfTg_kd4xVPi <br />Где: key_id &mdash; идентификатор ключа доступа, ACCESS_KEY. secret &mdash; секретный ключ, SECRET_KEY.<br />Переменные ACCESS_KEY и SECRET_KEY будут использованы для задания соответствующих значений aws_access_key_id и aws_secret_access_key при использовании библиотеки boto3 на следующих этапах.<br />Шаг 2. Object Storage<br />Самый простой способ создания бакета в Object Storage &mdash; через консоль управления. Более сложный, позволяющий автоматизировать разработку, &mdash; использование Terraform. Вы можете выбрать любой из них.<br />Способ 1. Консоль управления<br />В консоли управления в вашем рабочем каталоге выберите сервис Object Storage. Нажмите кнопку Создать бакет.<br />На странице создания бакета: Введите имя бакета, пусть это будет bucket-for-trigger. При необходимости ограничьте максимальный размер бакета, установив значение, например, 1 ГБ. Выберите тип доступа, в нашем уроке установим значения в Публичный во всех случаях. Выберите класс хранилища, по умолчанию используется Стандартное.<br />Нажмите кнопку Создать бакет для завершения операции. Далее вы всегда сможете поменять класс хранилища, его размер и настройки доступа.<br />Способ 2. Terraform<br />Прежде всего необходимо получить OAuth-токен для работы с Yandex Cloud. Для этого можно сделать запрос к сервису Яндекс.OAuth. Подробнее прочитать можно в документации.<br />Сохраните OAuth-токен в переменную OAuth, но никому не передавайте. Также вам потребуются значения переменных: идентификатор облака &mdash; CLOUD_ID и идентификатор каталога FOLDER_ID (сохранен в переменную ранее).<br />Также на предыдущем шаге вы получили ключ доступа для сервисного аккаунта. Нам потребуется идентификатор ключа доступа ACCESS_KEY и секретный ключ SECRET_KEY.<br />В файл main.tf, представленный далее, внесём все собранные переменные. Важно: переменная BUCKET_NAME содержит имя создаваемого бакета в Object Storage, куда будем загружать файлы. Допустим, переменная будет равна bucket-for-trigger. Сохраним все значения:<br />terraform {<br />&nbsp; required_providers {<br />&nbsp;&nbsp;&nbsp; yandex = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; source = "yandex-cloud/yandex"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br />&nbsp; required_version = "&gt;= 0.13"<br />}<br />provider "yandex" {<br />&nbsp; token&nbsp;&nbsp;&nbsp;&nbsp; = "&lt;OAuth&gt;"<br />&nbsp; cloud_id&nbsp; = "&lt;CLOUD_ID&gt;"<br />&nbsp; folder_id = "&lt;FOLDER_ID&gt;"<br />}<br />resource "yandex_storage_bucket" "bucket" {<br />&nbsp; access_key = "&lt;ACCESS_KEY&gt;"<br />&nbsp; secret_key = "&lt;SECRET_KEY&gt;"<br />&nbsp; bucket = "&lt;BUCKET_NAME&gt;"<br />} <br />После внесения правок, находясь в каталоге с файлом main.tf, последовательно выполните следующие команды:<br />terraform init<br />terraform plan<br />terraform apply <br />Успешное выполнение команд приведёт к созданию бакета bucket-for-trigger в объектном хранилище в вашем рабочем каталоге.<br />Шаг 3. Модификация функции<br />В предыдущей практической работе мы создали функцию с именем my-first-function с помощью следующей команды:<br />yc serverless function create --name my-first-function <br />При создании функции вы получили URL, по которому можно будет сделать вызов функции http_invoke_url.<br />Загрузка кода новой версии<br />Новая версия функции имеет зависимости, которые описаны в файле requirements.txt, а это значит, что для загрузки функции в облако необходимо файлы index.py и requirements.txt заархивировать и получить файл my-first-function.zip.<br />Новая версия index.py:<br />import os<br />import datetime<br />import boto3<br />import pytz<br />ACCESS_KEY = os.getenv("ACCESS_KEY")<br />SECRET_KEY = os.getenv("SECRET_KEY")<br />BUCKET_NAME = os.getenv("BUCKET_NAME")<br />TIME_ZONE = os.getenv("TIME_ZONE", "Europe/Moscow")<br />TEMP_FILENAME = "/tmp/temp_file"<br />TEXT_FOR_TEMP_FILE = "This is text file"<br />def write_temp_file():<br />&nbsp;&nbsp;&nbsp; temp_file = open(TEMP_FILENAME, 'w')<br />&nbsp;&nbsp;&nbsp; temp_file.write(TEXT_FOR_TEMP_FILE)<br />&nbsp;&nbsp;&nbsp; temp_file.close()<br />&nbsp;&nbsp;&nbsp; print("\U0001f680 Temp file is written")<br />def get_now_datetime_str():<br />&nbsp;&nbsp;&nbsp; now = datetime.datetime.now(pytz.timezone(TIME_ZONE))&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; return now.strftime('%Y-%m-%d__%H-%M-%S')<br />def get_s3_instance():<br />&nbsp;&nbsp;&nbsp; session = boto3.session.Session()<br />&nbsp;&nbsp;&nbsp; return session.client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_access_key_id=ACCESS_KEY,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_secret_access_key=SECRET_KEY,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='s3',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://storage.yandexcloud.net'<br />&nbsp;&nbsp;&nbsp; )<br />def upload_dump_to_s3():<br />&nbsp;&nbsp;&nbsp; print("\U0001F4C2 Starting upload to Object Storage")<br />&nbsp;&nbsp;&nbsp; get_s3_instance().upload_file(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Filename=TEMP_FILENAME,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bucket=BUCKET_NAME,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key=f'file-{get_now_datetime_str()}.txt'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; print("\U0001f680 Uploaded")<br />def remove_temp_files():<br />&nbsp;&nbsp;&nbsp; os.remove(TEMP_FILENAME)<br />&nbsp;&nbsp;&nbsp; print("\U0001F44D That's all!")<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; write_temp_file()<br />&nbsp;&nbsp;&nbsp; upload_dump_to_s3()<br />&nbsp;&nbsp;&nbsp; remove_temp_files()<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': 200,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': 'File is uploaded',<br />&nbsp;&nbsp;&nbsp; } <br />Первая версия requirements.txt:<br />boto3==1.13.10<br />botocore==1.16.10<br />python-dateutil==2.8.1<br />pytz==2020.1 <br />Находясь в каталоге с файлом my-first-function.zip вызовите следующую команду, это позволит вам загрузить код функции в облако и создать её версию:<br />yc serverless function version create \<br />&nbsp; --function-name my-first-function \<br />&nbsp; --memory 256m \<br />&nbsp; --execution-timeout 5s \<br />&nbsp; --runtime python37 \<br />&nbsp; --entrypoint index.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --source-path my-first-function.zip <br />Новая версия функции при вызове будет загружать в Object Storage новый файл. Для создания этой версии необходимо подготовить несколько переменных. Переменные ACCESS_KEY и SECRET_KEY вы получили на первом шаге, а значение BUCKET_NAME на втором:<br />echo "export ACCESS_KEY=&lt;ACCESS_KEY&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export SECRET_KEY=&lt;SECRET_KEY&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export BUCKET_NAME=bucket-for-trigger" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc <br />Определим идентификатор (ID) для последней загруженной версии функции:<br />yc serverless function version list --function-name my-first-function <br />Создадим новую версию функции, задав при этом переменные окружения. Для этого выставим значение параметра source-version-id равное полученному ID в следующей команде:<br />yc serverless function version create \<br />&nbsp; --function-name my-first-function \<br />&nbsp; --memory 256m \<br />&nbsp; --execution-timeout 5s \<br />&nbsp; --runtime python37 \<br />&nbsp; --entrypoint index.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --source-version-id &lt;ID&gt; \<br />&nbsp; --environment ACCESS_KEY=$ACCESS_KEY \<br />&nbsp; --environment SECRET_KEY=$SECRET_KEY \<br />&nbsp; --environment BUCKET_NAME=$BUCKET_NAME <br />Успешное выполнение команды приведёт к созданию версии функции.<br />Вызов функции<br />Получите список функций и информацию о функции my-first-function:<br />yc serverless function list<br />yc serverless function version list --function-name my-first-function <br />В результате вызова последней команды в столбце FUNCTION ID вы узнаете идентификатор функции и сможете сделать вызов функции с помощью следующей команды:<br />yc serverless function invoke &lt;идентификатор_функции&gt; <br />В предыдущей практической работе мы сделали функцию my-first-function публичной с помощью команды:<br />yc serverless function allow-unauthenticated-invoke my-first-function <br />Теперь мы можем сделать её вызов в браузере. Получите параметр http_invoke_url для функции my-first-function<br />yc serverless function get my-first-function <br />Введите значение параметра http_invoke_url в браузере и наслаждайтесь вызовом вашей функции. Во время её вызова в Object Storage будет создан новый файл.<br />Шаг 4. Создание триггера<br />Создание функции<br />Для создания триггера нам необходима функция, которую триггер будет запускать. Аналогично предыдущему шагу создадим функцию my-trigger-function и её версию на основе файла index.py.<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; print("\U0001F4C2 Starting function after trigger")<br />&nbsp;&nbsp;&nbsp; print(event)&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': 200,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': 'File is uploaded',<br />&nbsp;&nbsp;&nbsp; } <br />Находясь в каталоге с файлом index.py, вызовите следующие команды:<br />yc serverless function create --name my-trigger-function<br />yc serverless function version create \<br />&nbsp; --function-name my-trigger-function \<br />&nbsp; --memory 256m \<br />&nbsp; --execution-timeout 5s \<br />&nbsp; --runtime python37 \<br />&nbsp; --entrypoint index.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --source-path index.py<br />yc serverless function version list --function-name my-trigger-function <br />Создание триггера<br />Чтобы создать триггер my-first-trigger, который вызывает функцию my-trigger-function при создании нового объекта в бакете BUCKET_NAME, выполните команду:<br />yc serverless trigger create object-storage \<br />&nbsp; --name my-first-trigger \<br />&nbsp; --bucket-id $BUCKET_NAME \<br />&nbsp; --events 'create-object' \<br />&nbsp; --invoke-function-name my-trigger-function \<br />&nbsp; --invoke-function-service-account-id $SERVICE_ACCOUNT_ID <br />Вызов цепочки событий<br />Чтобы запустить цепочку событий, вызовем первую функцию my-first-function. Получите список функций и информацию о функции my-first-function:<br />yc serverless function list<br />yc serverless function version list --function-name my-first-function <br />В результате вызова последней команды в столбце FUNCTION ID вы узнаете идентификатор функции и сможете сделать вызов функции с помощью команды:<br />yc serverless function invoke &lt;идентификатор_функции&gt; <br />После этого вы можете сделать её вызов в браузере. Получите параметр http_invoke_url для функции my-first-function<br />yc serverless function get my-first-function <br />Введите значение параметра http_invoke_url в браузере. Во время вызова функции в Object Storage будет создан новый объект. Сразу после этого сработает триггер my-first-trigger, который вызовет функцию my-trigger-function. В итоге, наша вторая функция запишет в логи содержание переменной event. Убедиться в этом вы сможете как в UI, так и через CLI.<br />yc serverless function logs my-trigger-function <br /><strong>Decision:</strong><br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp;&nbsp;&nbsp; --role storage.editor \<br />&nbsp;&nbsp;&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_ID<br />$ yc iam access-key create --service-account-name service-account-for-cf<br />$ vim main.tf<br />$ cat main.tf<br />terraform {<br />&nbsp; required_providers {<br />&nbsp;&nbsp;&nbsp; yandex = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; source = "yandex-cloud/yandex"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br />&nbsp; required_version = "&gt;= 0.13"<br />}<br />provider "yandex" {<br />&nbsp; token&nbsp;&nbsp;&nbsp;&nbsp; = "YOUR-KEY"<br />&nbsp; cloud_id&nbsp; = "YOUR-ID"<br />&nbsp; folder_id = "YOUR-ID1"<br />}<br />resource "yandex_storage_bucket" "bucket" {<br />&nbsp; access_key = "YOUR-KEY1"<br />&nbsp; secret_key = "YOUR-KEY2"<br />&nbsp; bucket = "YOUR-NAME"<br />}<br />$ yc serverless function create --name my-first-function<br />$ vim index.py<br />$ cat index.py<br />import os<br />import datetime<br />import boto3<br />import pytz<br />ACCESS_KEY = os.getenv("ACCESS_KEY")<br />SECRET_KEY = os.getenv("SECRET_KEY")<br />BUCKET_NAME = os.getenv("BUCKET_NAME")<br />TIME_ZONE = os.getenv("TIME_ZONE", "Europe/Moscow")<br />TEMP_FILENAME = "/tmp/temp_file"<br />TEXT_FOR_TEMP_FILE = "This is text file"<br />def write_temp_file():<br />&nbsp;&nbsp;&nbsp; temp_file = open(TEMP_FILENAME, 'w')<br />&nbsp;&nbsp;&nbsp; temp_file.write(TEXT_FOR_TEMP_FILE)<br />&nbsp;&nbsp;&nbsp; temp_file.close()<br />&nbsp;&nbsp;&nbsp; print("\U0001f680 Temp file is written")<br />def get_now_datetime_str():<br />&nbsp;&nbsp;&nbsp; now = datetime.datetime.now(pytz.timezone(TIME_ZONE))<br />&nbsp;&nbsp;&nbsp; return now.strftime('%Y-%m-%d__%H-%M-%S')<br />def get_s3_instance():<br />&nbsp;&nbsp;&nbsp; session = boto3.session.Session()<br />&nbsp;&nbsp;&nbsp; return session.client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_access_key_id=ACCESS_KEY,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_secret_access_key=SECRET_KEY,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='s3',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://storage.yandexcloud.net'<br />&nbsp;&nbsp;&nbsp; )<br />def upload_dump_to_s3():<br />&nbsp;&nbsp;&nbsp; print("\U0001F4C2 Starting upload to Object Storage")<br />&nbsp;&nbsp;&nbsp; get_s3_instance().upload_file(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Filename=TEMP_FILENAME,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bucket=BUCKET_NAME,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key=f'file-{get_now_datetime_str()}.txt'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; print("\U0001f680 Uploaded")<br />def remove_temp_files():<br />&nbsp;&nbsp;&nbsp; os.remove(TEMP_FILENAME)<br />&nbsp;&nbsp;&nbsp; print("\U0001F44D That's all!")<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; write_temp_file()<br />&nbsp;&nbsp;&nbsp; upload_dump_to_s3()<br />&nbsp;&nbsp;&nbsp; remove_temp_files()<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': 200,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': 'File is uploaded',<br />&nbsp;&nbsp;&nbsp; }<br />$ vim requirements.txt<br />$ cat requirements.txt<br />boto3==1.13.10<br />botocore==1.16.10<br />python-dateutil==2.8.1<br />pytz==2020.1boto3==1.13.10<br />botocore==1.16.10<br />python-dateutil==2.8.1<br />pytz==2020.1<br />$ zip my-first-function.zip requirements.txt index.py<br />$ yc serverless function version create \<br />&nbsp; --function-name my-first-function \<br />&nbsp; --memory 256m \<br />&nbsp; --execution-timeout 5s \<br />&nbsp; --runtime python37 \<br />&nbsp; --entrypoint index.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --source-path my-first-function.zip<br />$ echo "export ACCESS_KEY=YOUR-KEY1" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export SECRET_KEY=YOUR-KEY2" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export BUCKET_NAME=bucket-for-trigger" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ yc serverless function version list --function-name my-first-function<br />$ yc serverless function version create \<br />&nbsp; --function-name my-first-function \<br />&nbsp; --memory 256m \<br />&nbsp; --execution-timeout 5s \<br />&nbsp; --runtime python37 \<br />&nbsp; --entrypoint index.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --source-version-id YOUR-ID2 \<br />&nbsp; --environment ACCESS_KEY=$ACCESS_KEY \<br />&nbsp; --environment SECRET_KEY=$SECRET_KEY \<br />&nbsp; --environment BUCKET_NAME=$BUCKET_NAME<br />$ yc serverless function list<br />$ yc serverless function version list --function-name my-first-function<br />$ yc serverless function invoke YOUR-ID3<br />$ yc serverless function allow-unauthenticated-invoke my-first-function<br />$ yc serverless function get my-first-function<br />$ vim index1.py<br />$ cat index1.py<br />import os<br />import datetime<br />import boto3<br />import pytz<br />ACCESS_KEY = os.getenv("ACCESS_KEY")<br />SECRET_KEY = os.getenv("SECRET_KEY")<br />BUCKET_NAME = os.getenv("BUCKET_NAME")<br />TIME_ZONE = os.getenv("TIME_ZONE", "Europe/Moscow")<br />TEMP_FILENAME = "/tmp/temp_file"<br />TEXT_FOR_TEMP_FILE = "This is text file"<br />def write_temp_file():<br />&nbsp;&nbsp;&nbsp; temp_file = open(TEMP_FILENAME, 'w')<br />&nbsp;&nbsp;&nbsp; temp_file.write(TEXT_FOR_TEMP_FILE)<br />&nbsp;&nbsp;&nbsp; temp_file.close()<br />&nbsp;&nbsp;&nbsp; print("\U0001f680 Temp file is written")<br />def get_now_datetime_str():<br />&nbsp;&nbsp;&nbsp; now = datetime.datetime.now(pytz.timezone(TIME_ZONE))&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; return now.strftime('%Y-%m-%d__%H-%M-%S')<br />def get_s3_instance():<br />&nbsp;&nbsp;&nbsp; session = boto3.session.Session()<br />&nbsp;&nbsp;&nbsp; return session.client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_access_key_id=ACCESS_KEY,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_secret_access_key=SECRET_KEY,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='s3',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://storage.yandexcloud.net'<br />&nbsp;&nbsp;&nbsp; )<br />def upload_dump_to_s3():<br />&nbsp;&nbsp;&nbsp; print("\U0001F4C2 Starting upload to Object Storage")<br />&nbsp;&nbsp;&nbsp; get_s3_instance().upload_file(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Filename=TEMP_FILENAME,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bucket=BUCKET_NAME,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key=f'file-{get_now_datetime_str()}.txt'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; print("\U0001f680 Uploaded")<br />def remove_temp_files():<br />&nbsp;&nbsp;&nbsp; os.remove(TEMP_FILENAME)<br />&nbsp;&nbsp;&nbsp; print("\U0001F44D That's all!")<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; print("\U0001F4C2 Starting function after trigger")<br />&nbsp;&nbsp;&nbsp; print(event)&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': 200,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': 'File is uploaded',<br />&nbsp;&nbsp;&nbsp; }<br />$ yc serverless function create --name my-trigger-function<br />$ yc serverless function version create \<br />&nbsp; --function-name my-trigger-function \<br />&nbsp; --memory 256m \<br />&nbsp; --execution-timeout 5s \<br />&nbsp; --runtime python37 \<br />&nbsp; --entrypoint index.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --source-path index.py<br />$ yc serverless function version list --function-name my-trigger-function<br />$ yc serverless trigger create object-storage \<br />&nbsp; --name my-first-trigger \<br />&nbsp; --bucket-id $BUCKET_NAME \<br />&nbsp; --events 'create-object' \<br />&nbsp; --invoke-function-name my-trigger-function \<br />&nbsp; --invoke-function-service-account-id $SERVICE_ACCOUNT_ID<br />$ yc serverless function list<br />$ yc serverless function version list --function-name my-first-function<br />$ yc serverless function invoke YOUR-ID3<br />$ yc serverless function get my-first-function<br />$ yc serverless function logs my-trigger-function<br /><strong>Task:</strong><br />Навык Алисы. <br />В предыдущих практических работах вы создали сервисный аккаунт с именем service-account-for-cf, добавили ему роли editor и storage.editor и создали ключ доступа.<br />Также вы создали бакет в Object Storage с именем bucket-for-trigger, триггер my-first-trigger для его обработки и вызываемую им функцию my-trigger-function.<br />Ещё была создана функция my-first-function, её использовали для того, чтобы запустить цепочку событий. <br />Публичный вызов этой функции приводил к созданию нового объекта в бакете в Object Storage. <br />Это запускало вызов триггера my-first-trigger, который стартовал функцию my-trigger-function. <br />В итоге последняя функция записывала в логи содержание переменной event.<br /><strong>Decision:</strong><br />Шаг 1. Создание функции<br />На предыдущем уроке мы создали функцию с именем my-first-function. Поменяем её исходный код так, чтобы обрабатывать запросы от Алисы.<br />На основе функции будет создан навык Попугай, который повторяет все, что ему написал или сказал пользователь.<br />Функция parrot. Создадим новую функцию с именем parrot с помощью команды:<br />yc serverless function create \<br />&nbsp; --name parrot \<br />&nbsp; --description "function for Alice" <br />По умолчанию функция не является публичной.<br />Загрузка кода новой версии<br />Функция имеет зависимости, которые описаны в файле requirements.txt, а это значит, что для загрузки функции в облако необходимо заархивировать файлы parrot.py и requirements.txt и получить файл parrot.zip.<br />Содержание функции parrot.py:<br />import os<br />import datetime<br />import boto3<br />import pytz<br />ACCESS_KEY = os.getenv("ACCESS_KEY")<br />SECRET_KEY = os.getenv("SECRET_KEY")<br />BUCKET_NAME = os.getenv("BUCKET_NAME")<br />TIME_ZONE = os.getenv("TIME_ZONE", "Europe/Moscow")<br />TEMP_FILENAME = "/tmp/temp_file"<br />TEXT_FOR_TEMP_FILE = "This is text file"<br />def write_temp_file(text_for_s3):<br />&nbsp;&nbsp;&nbsp; TEXT_FOR_TEMP_FILE = text_for_s3<br />&nbsp;&nbsp;&nbsp; temp_file = open(TEMP_FILENAME, 'w')&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; temp_file.write(TEXT_FOR_TEMP_FILE)<br />&nbsp;&nbsp;&nbsp; temp_file.close()<br />&nbsp;&nbsp;&nbsp; print("\U0001f680 Temp file is written")<br />def get_now_datetime_str():<br />&nbsp;&nbsp;&nbsp; now = datetime.datetime.now(pytz.timezone(TIME_ZONE))<br />&nbsp;&nbsp;&nbsp; return now.strftime('%Y-%m-%d__%H-%M-%S')<br />def get_s3_instance():<br />&nbsp;&nbsp;&nbsp; session = boto3.session.Session()<br />&nbsp;&nbsp;&nbsp; return session.client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_access_key_id=ACCESS_KEY,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_secret_access_key=SECRET_KEY,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='s3',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://storage.yandexcloud.net'<br />&nbsp;&nbsp;&nbsp; )<br />def upload_dump_to_s3():<br />&nbsp;&nbsp;&nbsp; print("\U0001F4C2 Starting upload to Object Storage")<br />&nbsp;&nbsp;&nbsp; get_s3_instance().upload_file(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Filename=TEMP_FILENAME,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bucket=BUCKET_NAME,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key=f'file-{get_now_datetime_str()}.txt'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; print("\U0001f680 Uploaded")<br />def remove_temp_files():<br />&nbsp;&nbsp;&nbsp; os.remove(TEMP_FILENAME)<br />&nbsp;&nbsp;&nbsp; print("\U0001F44D That's all!")<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; Entry-point for Serverless Function.<br />&nbsp;&nbsp;&nbsp; :param event: request payload.<br />&nbsp;&nbsp;&nbsp; :param context: information about current execution context.<br />&nbsp;&nbsp;&nbsp; :return: response to be serialized as JSON.<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; text = 'Hello! I\'ll repeat anything you say to me.'<br />&nbsp;&nbsp;&nbsp; if 'request' in event and \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'original_utterance' in event['request'] \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and len(event['request']['original_utterance']) &gt; 0:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text = event['request']['original_utterance']<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_temp_file(text)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; upload_dump_to_s3()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove_temp_files()<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'version': event['version'],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'session': event['session'],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'response': {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Respond with the original request or welcome the user if this is the beginning of the dialog and the request has not yet been made.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'text': text,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Don't finish the session after this response.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'end_session': 'false'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp; }<br />Содержание файла зависимостей requirements.txt:<br />boto3==1.13.10<br />botocore==1.16.10<br />python-dateutil==2.8.1<br />pytz==2020.1 <br />Находясь в каталоге с файлом parrot.zip, вызовите приведенную ниже команду. Это позволит вам загрузить код функции в облако и создать её версию:<br />yc serverless function version create \<br />&nbsp; --function-name=parrot \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=parrot.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --source-path parrot.zip <br />Шаг 2. Создание новой версии функции<br />Новая версия функции при вызове будет загружать в Object Storage новый файл. Для создания этой новой версии функции необходимы переменные.<br />Если переменные среды не сохранились, то в консоли управления можно посмотреть имя бакета, а ACCESS_KEY и SECRET_KEY скопировать из предыдущей функции my-first-function:<br />echo "export ACCESS_KEY=&lt;ACCESS_KEY&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export SECRET_KEY=&lt;SECRET_KEY&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export BUCKET_NAME=bucket-for-trigger" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc <br />Определим идентификатор (ID) последней загруженной версии функции:<br />yc serverless function version list --function-name parrot <br />Создадим новую версию функции, задав переменные окружения. Для этого выставим значение параметра source-version-id равное полученному идентификатору версии функции (ID) в следующей команде:<br />yc serverless function version create \<br />&nbsp; --function-name parrot \<br />&nbsp; --memory 256m \<br />&nbsp; --execution-timeout 5s \<br />&nbsp; --runtime python37 \<br />&nbsp; --entrypoint parrot.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --source-version-id &lt;идентификатор_версии_функции&gt; \<br />&nbsp; --environment ACCESS_KEY=$ACCESS_KEY \<br />&nbsp; --environment SECRET_KEY=$SECRET_KEY \<br />&nbsp; --environment BUCKET_NAME=$BUCKET_NAME <br />Успешное выполнение команды приведёт к созданию версии функции.<br />Шаг 3. Вызов функции и её тестирование<br />По умолчанию функция создаётся непубличной. Чтобы сделать функцию parrot публичной, вызовите следующую команду:<br />yc serverless function allow-unauthenticated-invoke parrot <br />Протестируйте функцию parrot, чтобы проверить правильность кода перед созданием связки с Алисой. В консоли управления на странице сервиса Cloud Functions выберите созданную функцию и перейдите на вкладку Тестирование. В поле Шаблон данных данных укажите Навык Алисы и нажмите кнопку Запустить тест.<br />В блоке Результат тестирования убедитесь, что функция выполнена и приведен ответ.<br />Перейдите по ссылке https://dialogs.yandex.ru/developer/ и создайте новый диалог Алисы (подробности о создании навыков вы можете узнать из документации):<br />Нажмите кнопку Создать диалог. Выберите тип диалога Навык в Алисе, у вас откроется форма на вкладке Настройки.<br />Заполните имя навыка, оно должно состоять минимум из двух слов, например My parrot.<br />В блоке Backend выберите вариант Функция в Яндекс.Облаке и в выпадающем списке выберите созданную вами функцию parrot.<br />В блоке Тип доступа в выпадающем списке выберите Приватный.<br />В блоке Публикация в каталоге выберите Примеры запросов, например Запусти навык - My parrot, Имя разработчика, Категорию, Описание и Иконку.<br />Нажмите кнопку Сохранить и перейдите на вкладку Тестирование.<br />Если вы сделали всё правильно, то на экране появится приветствие навыка. Далее навык будет повторять всё, что вы ему напишете. При этом фразы, которые вы отправите Алисе, будут сохраняться в новом файле в бакете. Вы можете это проверить в консоли управления.<br /><strong>Decision:</strong><br />$ yc serverless function create \<br />&nbsp; --name parrot \<br />&nbsp; --description "function for Alice"<br />$ vim parrot.py<br />$ cat parrot.py<br />import os<br />import datetime<br />import boto3<br />import pytz<br />ACCESS_KEY = os.getenv("ACCESS_KEY")<br />SECRET_KEY = os.getenv("SECRET_KEY")<br />BUCKET_NAME = os.getenv("BUCKET_NAME")<br />TIME_ZONE = os.getenv("TIME_ZONE", "Europe/Moscow")<br />TEMP_FILENAME = "/tmp/temp_file"<br />TEXT_FOR_TEMP_FILE = "This is text file"<br />def write_temp_file(text_for_s3):<br />&nbsp;&nbsp;&nbsp; TEXT_FOR_TEMP_FILE = text_for_s3<br />&nbsp;&nbsp;&nbsp; temp_file = open(TEMP_FILENAME, 'w')&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; temp_file.write(TEXT_FOR_TEMP_FILE)<br />&nbsp;&nbsp;&nbsp; temp_file.close()<br />&nbsp;&nbsp;&nbsp; print("\U0001f680 Temp file is written")<br />def get_now_datetime_str():<br />&nbsp;&nbsp;&nbsp; now = datetime.datetime.now(pytz.timezone(TIME_ZONE))<br />&nbsp;&nbsp;&nbsp; return now.strftime('%Y-%m-%d__%H-%M-%S')<br />def get_s3_instance():<br />&nbsp;&nbsp;&nbsp; session = boto3.session.Session()<br />&nbsp;&nbsp;&nbsp; return session.client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_access_key_id=ACCESS_KEY,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_secret_access_key=SECRET_KEY,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='s3',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://storage.yandexcloud.net'<br />&nbsp;&nbsp;&nbsp; )<br />def upload_dump_to_s3():<br />&nbsp;&nbsp;&nbsp; print("\U0001F4C2 Starting upload to Object Storage")<br />&nbsp;&nbsp;&nbsp; get_s3_instance().upload_file(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Filename=TEMP_FILENAME,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bucket=BUCKET_NAME,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key=f'file-{get_now_datetime_str()}.txt'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; print("\U0001f680 Uploaded")<br />def remove_temp_files():<br />&nbsp;&nbsp;&nbsp; os.remove(TEMP_FILENAME)<br />&nbsp;&nbsp;&nbsp; print("\U0001F44D That's all!")<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; Entry-point for Serverless Function.<br />&nbsp;&nbsp;&nbsp; :param event: request payload.<br />&nbsp;&nbsp;&nbsp; :param context: information about current execution context.<br />&nbsp;&nbsp;&nbsp; :return: response to be serialized as JSON.<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; text = 'Hello! I\'ll repeat anything you say to me.'<br />&nbsp;&nbsp;&nbsp; if 'request' in event and \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'original_utterance' in event['request'] \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and len(event['request']['original_utterance']) &gt; 0:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text = event['request']['original_utterance']<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_temp_file(text)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; upload_dump_to_s3()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove_temp_files()<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'version': event['version'],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'session': event['session'],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'response': {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Respond with the original request or welcome the user if this is the beginning of the dialog and the request has not yet been made.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'text': text,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Don't finish the session after this response.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'end_session': 'false'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp; }<br />$ zip parrot.zip parrot.py<br />$ zip parrot.zip requirements.txt<br />$ yc serverless function version create \<br />&nbsp; --function-name=parrot \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=parrot.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --source-path parrot.zip<br />$ echo "export ACCESS_KEY=&lt;ACCESS_KEY&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export SECRET_KEY=&lt;SECRET_KEY&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export BUCKET_NAME=bucket-for-trigger" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ yc serverless function version list --function-name parrot<br />$ yc serverless function version create \<br />&nbsp; --function-name parrot \<br />&nbsp; --memory 256m \<br />&nbsp; --execution-timeout 5s \<br />&nbsp; --runtime python37 \<br />&nbsp; --entrypoint parrot.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --source-version-id &lt;идентификатор_версии_функции&gt; \<br />&nbsp; --environment ACCESS_KEY=$ACCESS_KEY \<br />&nbsp; --environment SECRET_KEY=$SECRET_KEY \<br />&nbsp; --environment BUCKET_NAME=$BUCKET_NAME<br />$ yc serverless function allow-unauthenticated-invoke parrot<br /><strong>Task:</strong><br />Проверка доступности<br />На этом практическом занятии вы создадите функцию для проверки доступности сайта yandex.ru, которая будет измерять время ответа. <br />Результаты работы функции будут передаваться в базу данных сервиса Yandex Managed Service for PostgreSQL с использованием подключения к управляемой БД из функции. <br />Также вы запустите триггер-таймер, который будет регулярно производить опрос сайта yandex.ru.<br /><strong>Decision:</strong><br />Шаг 1. Дополнительная роль для сервисного аккаунта<br />В предыдущих практических работах вы создали сервисный аккаунт с именем service-account-for-cf, назначили ему роли editor и&nbsp; storage.editor и создали ключ доступа. Чтобы подключаться к управляемым БД из функции, нужно добавить сервисному аккаунту роль serverless.mdbProxies.user.<br />Для этого выполните следующую команду:<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --role serverless.mdbProxies.user \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_ID <br />Шаг 2. Создание базы данных<br />Создание кластера PostgreSQL<br />Конечно, кластер PostgreSQL можно создать с помощью консоли управления, но в этой практической работе мы используем CLI. Прежде всего, давайте определим подсеть, в которой будет расположен кластер. Разместим кластер в зоне ru-central1-c и с помощью следующей команды узнаем идентификатор(ID) соответствующей подсети:<br />yc vpc subnet list <br />Создадим кластер версии PostgreSQL 13 с именем my-pg-database. Установим тип хоста burstable b2.nano &mdash; это самый дешёвый и простой вариант хоста. Из-за невысокой производительности он подходит только для тестовых целей. Используем для хоста жёсткий диск (HDD) размером 10 ГБ.<br />Сразу создадим пользователя с именем user1 и паролем user1user1, а также базу данных db1. Для удобства администрирования откроем доступ из консоли управления. Используйте опцию websql-access &mdash; это позволит выполнять SQL-запросы прямо в консоли управления. Чтобы открыть возможность подключения к PostgreSQL из функции, необходимо подключить опцию serverless-access.<br />Следующая команда за несколько минут создаст кластер PostgreSQL (не забудьте подставить идентификатор вашей подсети):<br />yc managed-postgresql cluster create \<br />&nbsp; --name my-pg-database \<br />&nbsp; --description 'For Serverless' \<br />&nbsp; --postgresql-version 13 \<br />&nbsp; --environment production \<br />&nbsp; --network-name default \<br />&nbsp; --resource-preset b2.nano \<br />&nbsp; --host zone-id=ru-central1-c,subnet-id=&lt;идентификатор_подсети&gt; \<br />&nbsp; --disk-type network-hdd \<br />&nbsp; --disk-size 10 \<br />&nbsp; --user name=user1,password=user1user1 \<br />&nbsp; --database name=db1,owner=user1 \<br />&nbsp; --websql-access \<br />&nbsp; --serverless-access <br />После успешного создания кластера проверьте результат:<br />yc managed-postgresql cluster list<br />yc managed-postgresql cluster get &lt;имя или идентификатор кластера&gt; <br />Создание таблицы для хранения данных<br />При создании кластера мы использовали опцию websql-access, что открывает нам возможности по исполнению SQL-команд в консоли управления. Воспользуемся этим и сделаем таблицу в созданной нами базе данных. В эту таблицу мы будем складывать результаты выполнения функции. В консоли управления перейдите в каталог, в котором создан кластер PostgreSQL. Откройте сервис Managed Service for PostgreSQL и перейдите в кластер my-pg-database.<br />В боковом меню перейдите на вкладку SQL. Для базы данных db1введите имя user1 и пароль user1user1, нажмите кнопку Подключиться.<br />В открывшемся окне введите SQL-запрос и исполните его:<br />CREATE TABLE measurements (<br />&nbsp;&nbsp;&nbsp; result integer,<br />&nbsp;&nbsp;&nbsp; time float<br />); <br />Успешное выполнение команды создаст таблицу, куда мы будем складывать результаты.<br />Шаг 3. Подключение к управляемой БД из функции<br />Создание подключения<br />В консоли управления перейдите в каталог, в котором хотите создать подключение. Откройте сервис Cloud Functions. В боковом меню перейдите на вкладку Подключения к БД. Нажмите кнопку Создать подключение.<br />&nbsp;&nbsp;&nbsp; Введите имя, описание подключения и в выпадающем списке выберите тип подключения &mdash; PostgreSQL.<br />&nbsp;&nbsp;&nbsp; Укажите кластер &mdash; my-pg-database.<br />&nbsp;&nbsp;&nbsp; Укажите базу данных &mdash; db1.<br />&nbsp;&nbsp;&nbsp; Введите данные пользователя БД: имя user1 и пароль user1user1.<br />&nbsp;&nbsp;&nbsp; Нажмите кнопку Создать.<br />Выберите созданное подключение. На вкладке Обзор скопируйте параметры Идентификатор и Точка входа. Они будут использованы в функции на следующем шаге.<br />Шаг 4. Создание функции<br />Перед созданием функции определите переменные для инициации подключения: CONNECTION_ID &mdash; идентификатор подключения, DB_USER &mdash; имя пользователя БД, DB_HOST &mdash; точка входа. Используйте следующие команды:<br />echo "export CONNECTION_ID=&lt;CONNECTION_ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export DB_USER=&lt;DB_USER&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export DB_HOST=&lt;DB_HOST&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc <br />Они будут использованы в функции function-for-postgresql.py. Код функции:<br />import datetime<br />import logging<br />import requests<br />import os<br />#Эти библиотеки нужны для работы с PostgreSQL<br />import psycopg2<br />import psycopg2.errors<br />CONNECTION_ID = os.getenv("CONNECTION_ID")<br />DB_USER = os.getenv("DB_USER")<br />DB_HOST = os.getenv("DB_HOST")<br /># Настраиваем функцию для записи информации в журнал функции<br /># Получаем стандартный логер языка Python<br />logger = logging.getLogger()<br />logger.setLevel(logging.INFO)<br /># Вычитываем переменную VERBOSE_LOG, которую мы указываем в переменных окружения <br />verboseLogging = eval(os.environ['VERBOSE_LOG'])&nbsp; ## Convert to bool<br />#Функция log, которая запишет текст в журнал выполнения функции, если в переменной окружения VERBOSE_LOG будет значение True<br />def log(logString):<br />&nbsp;&nbsp;&nbsp; if verboseLogging:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.info(logString)<br />#Запись в базу данных<br />def save(result, time, context):<br />&nbsp;&nbsp;&nbsp; connection = psycopg2.connect(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; database=CONNECTION_ID, # Идентификатор подключения<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user=DB_USER, # Пользователь БД<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; password=context.token["access_token"],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host=DB_HOST, # Точка входа<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port=6432,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sslmode="require")<br />&nbsp;&nbsp;&nbsp; cursor = connection.cursor()&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; postgres_insert_query = """INSERT INTO measurements (result, time) VALUES (%s,%s)"""<br />&nbsp;&nbsp;&nbsp; record_to_insert = (result, time)<br />&nbsp;&nbsp;&nbsp; cursor.execute(postgres_insert_query, record_to_insert)<br />&nbsp;&nbsp;&nbsp; connection.commit()<br /># Это обработчик. Он будет вызван первым при запуске функции<br />def entry(event, context):<br />&nbsp;&nbsp;&nbsp; #Выводим в журнал значения входных параметров event и context<br />&nbsp;&nbsp;&nbsp; log(event)<br />&nbsp;&nbsp;&nbsp; log(context)<br />&nbsp;&nbsp;&nbsp; # Тут мы запоминаем текущее время, отправляем запрос к yandex.ru и вычисляем время выполнения запроса<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now = datetime.datetime.now()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #здесь указано два таймаута: 1c для установки связи с сервисом и 3 секунды на получение ответа<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = requests.get('https://yandex.ru', timeout=(1.0000, 3.0000))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timediff = datetime.datetime.now() - now<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #сохраняем результат запроса<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = response.status_code<br />&nbsp;&nbsp;&nbsp; #если в процессе запроса сработали таймауты, то в результат записываем соответствующие коды<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.ReadTimeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 601<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.ConnectTimeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 602<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.Timeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 603<br />&nbsp;&nbsp;&nbsp; log(f'Result: {result} Time: {timediff.total_seconds()}')&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; save(result, timediff.total_seconds(), context)<br />&nbsp;&nbsp;&nbsp; #возвращаем результат запроса<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': result,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'headers': {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Content-Type': 'text/plain'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'isBase64Encoded': False<br />&nbsp;&nbsp;&nbsp; } <br />Перейдем в директорию с кодом функции и создадим нашу функцию function-for-postgresql. При этом сразу зададим все необходимые переменные и сервисный аккаунт:<br />yc serverless function create \<br />&nbsp; --name&nbsp; function-for-postgresql \<br />&nbsp; --description "function for postgresql"<br />yc serverless function version create \<br />&nbsp; --function-name=function-for-postgresql \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=function-for-postgresql.entry \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --environment VERBOSE_LOG=True \<br />&nbsp; --environment CONNECTION_ID=$CONNECTION_ID \<br />&nbsp; --environment DB_USER=$DB_USER \<br />&nbsp; --environment DB_HOST=$DB_HOST \<br />&nbsp; --source-path function-for-postgresql.py <br />Проверим работоспособность функции:<br />yc serverless function version list --function-name function-for-postgresql<br />yc serverless function invoke --name function-for-postgresql <br />Успешный вызов функции приведёт к измерению времени ответа сайта и формированию записи в базе данных.<br />Шаг 5. Создание триггера<br />Создание триггера-таймера<br />Проверять доступность сайта лучше в автоматическом режиме через равные промежутки времени. Для этой задачи создайте триггер-таймер. Он будет использовать cron-выражения:<br />yc serverless trigger create timer \<br />&nbsp; --name trigger-for-postgresql \<br />&nbsp; --invoke-function-name function-for-postgresql \<br />&nbsp; --invoke-function-service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --cron-expression '* * * * ? *' <br />Cron-выражение * * * * ? * означает вызов функции function-for-postgresql один раз в минуту. Успешное выполнение функции раз в минуту будет создавать запись в базе данных, в чём вы можете убедиться, просмотрев записи в таблице.<br />Убедились? Поздравляем: вы успешно создали функцию, которая через заданный промежуток времени выполняется по триггеру, чтобы проверить доступность yandex.ru и записать результат проверки в базу данных.<br />Удаление триггера-таймера<br />После завершения практической работы не забудьте удалить созданный триггер trigger-for-postgresql, иначе он будет продолжать работать:<br />yc serverless trigger delete trigger-for-postgresql <br /><strong>Decision:</strong><br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --role serverless.mdbProxies.user \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_ID<br />$ yc vpc subnet list<br />$ yc managed-postgresql cluster create \<br />&nbsp; --name my-pg-database \<br />&nbsp; --description 'For Serverless' \<br />&nbsp; --postgresql-version 13 \<br />&nbsp; --environment production \<br />&nbsp; --network-name default \<br />&nbsp; --resource-preset b2.nano \<br />&nbsp; --host zone-id=ru-central1-c,subnet-id=&lt;идентификатор_подсети&gt; \<br />&nbsp; --disk-type network-hdd \<br />&nbsp; --disk-size 10 \<br />&nbsp; --user name=user1,password=user1user1 \<br />&nbsp; --database name=db1,owner=user1 \<br />&nbsp; --websql-access \<br />&nbsp; --serverless-access<br />$ yc managed-postgresql cluster list<br />$ yc managed-postgresql cluster get &lt;имя или идентификатор кластера&gt;<br />$ echo "export CONNECTION_ID=&lt;CONNECTION_ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export DB_USER=&lt;DB_USER&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export DB_HOST=&lt;DB_HOST&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ vim function-for-postgresql.py<br />$ cat function-for-postgresql.py<br />import datetime<br />import logging<br />import requests<br />import os<br />#Эти библиотеки нужны для работы с PostgreSQL<br />import psycopg2<br />import psycopg2.errors<br />CONNECTION_ID = os.getenv("CONNECTION_ID")<br />DB_USER = os.getenv("DB_USER")<br />DB_HOST = os.getenv("DB_HOST")<br /># Настраиваем функцию для записи информации в журнал функции<br /># Получаем стандартный логер языка Python<br />logger = logging.getLogger()<br />logger.setLevel(logging.INFO)<br /># Вычитываем переменную VERBOSE_LOG, которую мы указываем в переменных окружения <br />verboseLogging = eval(os.environ['VERBOSE_LOG'])&nbsp; ## Convert to bool<br />#Функция log, которая запишет текст в журнал выполнения функции, если в переменной окружения VERBOSE_LOG будет значение True<br />def log(logString):<br />&nbsp;&nbsp;&nbsp; if verboseLogging:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.info(logString)<br />#Запись в базу данных<br />def save(result, time, context):<br />&nbsp;&nbsp;&nbsp; connection = psycopg2.connect(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; database=CONNECTION_ID, # Идентификатор подключения<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user=DB_USER, # Пользователь БД<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; password=context.token["access_token"],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host=DB_HOST, # Точка входа<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port=6432,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sslmode="require")<br />&nbsp;&nbsp;&nbsp; cursor = connection.cursor()&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; postgres_insert_query = """INSERT INTO measurements (result, time) VALUES (%s,%s)"""<br />&nbsp;&nbsp;&nbsp; record_to_insert = (result, time)<br />&nbsp;&nbsp;&nbsp; cursor.execute(postgres_insert_query, record_to_insert)<br />&nbsp;&nbsp;&nbsp; connection.commit()<br /># Это обработчик. Он будет вызван первым при запуске функции<br />def entry(event, context):<br />&nbsp;&nbsp;&nbsp; #Выводим в журнал значения входных параметров event и context<br />&nbsp;&nbsp;&nbsp; log(event)<br />&nbsp;&nbsp;&nbsp; log(context)<br />&nbsp;&nbsp;&nbsp; # Тут мы запоминаем текущее время, отправляем запрос к ya.ru и вычисляем время выполнения запроса<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now = datetime.datetime.now()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #здесь указано два таймаута: 1c для установки связи с сервисом и 3 секунды на получение ответа<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = requests.get('https://ya.ru', timeout=(1.0000, 3.0000))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timediff = datetime.datetime.now() - now<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #сохраняем результат запроса<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = response.status_code<br />&nbsp;&nbsp;&nbsp; #если в процессе запроса сработали таймауты, то в результат записываем соответствующие коды<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.ReadTimeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 601<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.ConnectTimeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 602<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.Timeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 603<br />&nbsp;&nbsp;&nbsp; log(f'Result: {result} Time: {timediff.total_seconds()}')&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; save(result, timediff.total_seconds(), context)<br />&nbsp;&nbsp;&nbsp; #возвращаем результат запроса<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': result,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'headers': {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Content-Type': 'text/plain'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'isBase64Encoded': False<br />&nbsp;&nbsp;&nbsp; }<br />$ yc serverless function create \<br />&nbsp; --name&nbsp; function-for-postgresql \<br />&nbsp; --description "function for postgresql"<br />$ yc serverless function version create \<br />&nbsp; --function-name=function-for-postgresql \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=function-for-postgresql.entry \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --environment VERBOSE_LOG=True \<br />&nbsp; --environment CONNECTION_ID=$CONNECTION_ID \<br />&nbsp; --environment DB_USER=$DB_USER \<br />&nbsp; --environment DB_HOST=$DB_HOST \<br />&nbsp; --source-path function-for-postgresql.py<br />$ yc serverless function version list --function-name function-for-postgresql<br />$ yc serverless function invoke --name function-for-postgresql<br />$ yc serverless trigger create timer \<br />&nbsp; --name trigger-for-postgresql \<br />&nbsp; --invoke-function-name function-for-postgresql \<br />&nbsp; --invoke-function-service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --cron-expression '* * * * ? *'<br />$ yc serverless trigger delete trigger-for-postgresql<br /><strong>Task:</strong><br />Создание HTTP API с помощью Cloud Functions и API Gateway.<br />На предыдущем практическом занятии мы создали простую систему, которая проверяет доступность сайта yandex.ru и измеряет время ответа на запрос. <br />Полученную информацию функция записывала в базу данных PostgreSQL. <br />На этом уроке мы доработаем начатый проект и добавим REST API, который позволит получать до 50 результатов проверки из базы данных.<br /><strong>Decision:</strong><br />Шаг 1. Проверить наличие сервисного аккаунта<br />Для работы нам понадобится сервисный аккаунт с именем service-account-for-cf и ролями editor, serverless.mdbProxies.user, который мы создали ранее.<br />Шаг 2. Yandex API Gateway<br />Создание спецификации<br />В рабочем каталоге создадим спецификацию hello-world.yaml:<br />openapi: "3.0.0"<br />info:<br />&nbsp; version: 1.0.0<br />&nbsp; title: Test API<br />paths:<br />&nbsp; /hello:<br />&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; summary: Say hello<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: hello<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameters:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: user<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in: query<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; description: User name to appear in greetings<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; required: false<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schema:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: string<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: 'world'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; responses:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '200':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; description: Greeting<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'text/plain':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schema:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: "string"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: dummy<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http_code: 200<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http_headers:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Content-Type': "text/plain"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'text/plain': "Hello, {user}!\n" <br />Мы можем создать API-шлюз с помощью консоли управления, но сейчас воспользуемся CLI.<br />Инициализация спецификации<br />Чтобы развернуть API-шлюз, используем спецификацию hello-world.yaml:<br />yc serverless api-gateway create \<br />&nbsp; --name hello-world \<br />&nbsp; --spec=hello-world.yaml \<br />&nbsp; --description "hello world" <br />В результате успешного создания API-шлюза получим значение параметра domain:<br />yc serverless api-gateway list<br />yc serverless api-gateway get --name hello-world <br />Скопируем служебный домен, чтобы проверить работоспособность API-шлюза. Вставим его в адресную строку браузера и допишем в конец /hello. Должно получиться следующее:<br />https://&lt;идентификатор API Gateway&gt;.apigw.yandexcloud.net/hello <br />Теперь протестируем запрос с параметрами. Добавьте к предыдущему запросу ?user=my_user. Должно получиться следующее:<br />https://&lt;идентификатор API Gateway&gt;.apigw.yandexcloud.net/hello?user=my_user <br />В первом случае в окне браузера вы увидите &laquo;Hello, world!&raquo;, во втором &laquo;Hello, my_user!&raquo;.<br />Шаг 3. Создание функции<br />Работа с библиотеками и переменными<br />До этого момента мы использовали рантайм python37, который не требовал явного указания библиотек, но начиная с версии python39, нужно указывать библиотеки явно. Для работы с requirements.txt можно воспользоваться удобной Python-библиотекой pipreqs: чтобы сгенерировать requirements.txt с помощью pipreqs, достаточно указать рабочий каталог. В большинстве интерпретаторов Linux для указания текущего каталога предусмотрена переменная $PWD. Если файл requirements.txt уже существует, актуализируйте его с помощью флага --force, например:<br />pip install pipreqs<br />pipreqs $PWD --print<br />pipreqs $PWD --force <br />Чтобы создать функцию, проверим доступность переменных для инициации подключения CONNECTION_ID, DB_USER, DB_HOST, которые мы создали в предыдущей работе с помощью следующих команд:<br />echo "export CONNECTION_ID=&lt;CONNECTION_ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export DB_USER=&lt;DB_USER&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export DB_HOST=&lt;DB_HOST&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc <br />Создание функции<br />Создадим функцию function-for-user-requests.py:<br />import json<br />import logging<br />import requests<br />import os<br />#Эти библиотеки нужны для работы с PostgreSQL<br />import psycopg2<br />import psycopg2.errors<br />import psycopg2.extras<br />CONNECTION_ID = os.getenv("CONNECTION_ID")<br />DB_USER = os.getenv("DB_USER")<br />DB_HOST = os.getenv("DB_HOST")<br /># Настраиваем функцию для записи информации в журнал функции<br /># Получаем стандартный логер языка Python<br />logger = logging.getLogger()<br />logger.setLevel(logging.INFO)<br /># Вычитываем переменную VERBOSE_LOG, которую мы указываем в переменных окружения<br />verboseLogging = eval(os.environ['VERBOSE_LOG'])&nbsp; ## Convert to bool<br />#Функция log, которая запишет текст в журнал выполнения функции, если в переменной окружения VERBOSE_LOG будет значение True<br />def log(logString):<br />&nbsp;&nbsp;&nbsp; if verboseLogging:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.info(logString)<br />#Запись в базу данных<br />def save(result, time, context):<br />&nbsp;&nbsp;&nbsp; connection = psycopg2.connect(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; database=CONNECTION_ID, # Идентификатор подключения<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user=DB_USER, # Пользователь БД<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; password=context.token["access_token"],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host=DB_HOST, # Точка входа<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port=6432,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sslmode="require")<br />&nbsp;&nbsp;&nbsp; cursor = connection.cursor()&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; postgres_insert_query = """INSERT INTO measurements (result, time) VALUES (%s,%s)"""<br />&nbsp;&nbsp;&nbsp; record_to_insert = (result, time)<br />&nbsp;&nbsp;&nbsp; cursor.execute(postgres_insert_query, record_to_insert)<br />&nbsp;&nbsp;&nbsp; connection.commit()<br />#Формируем запрос<br />def generateQuery():<br />&nbsp;&nbsp;&nbsp; select = f"SELECT * FROM measurements LIMIT 50"<br />&nbsp;&nbsp;&nbsp; result = select<br />&nbsp;&nbsp;&nbsp; return result<br />#Получаем подключение<br />def getConnString(context):<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; Extract env variables to connect to DB and return a db string<br />&nbsp;&nbsp;&nbsp; Raise an error if the env variables are not set<br />&nbsp;&nbsp;&nbsp; :return: string<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; connection = psycopg2.connect(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; database=CONNECTION_ID, # Идентификатор подключения<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user=DB_USER, # Пользователь БД<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; password=context.token["access_token"],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host=DB_HOST, # Точка входа<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port=6432,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sslmode="require")&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; return connection<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secret = event['queryStringParameters']['secret']<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if secret != 'cecfb23c-bc86-4ca2-b611-e79bc77e5c31':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise Exception()<br />&nbsp;&nbsp;&nbsp; except Exception as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error(error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusCode = 401<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; sql = generateQuery()<br />&nbsp;&nbsp;&nbsp; log(f'Exec: {sql}')<br />&nbsp;&nbsp;&nbsp; connection = getConnString(context)<br />&nbsp;&nbsp;&nbsp; log(f'Connecting: {connection}')<br />&nbsp;&nbsp;&nbsp; cursor = connection.cursor()<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(sql)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusCode = 200<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': json.dumps(cursor.fetchall()),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; except psycopg2.errors.UndefinedTable as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection.rollback()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error(error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusCode = 500<br />&nbsp;&nbsp;&nbsp; except Exception as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error(error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusCode = 500<br />&nbsp;&nbsp;&nbsp; cursor.close()<br />&nbsp;&nbsp;&nbsp; connection.close()<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': json.dumps({<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'event': event,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }),<br />&nbsp;&nbsp;&nbsp; }<br />Обратите внимание, в коде функции мы заложили параметр secret и его значение cecfb23c-bc86-4ca2-b611-e79bc77e5c31, при котором функция будет выполняться. Таким образом мы обеспечиваем дополнительную защиту при доступе к БД.<br />При создании функции сразу зададим все необходимые переменные и сервисный аккаунт:<br />yc serverless function create \<br />&nbsp; --name function-for-user-requests \<br />&nbsp; --description "function for response to user"<br />yc serverless function version create \<br />&nbsp; --function-name=function-for-user-requests \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=function-for-user-requests.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --environment VERBOSE_LOG=True \<br />&nbsp; --environment CONNECTION_ID=$CONNECTION_ID \<br />&nbsp; --environment DB_USER=$DB_USER \<br />&nbsp; --environment DB_HOST=$DB_HOST \<br />&nbsp; --source-path function-for-user-requests.py <br />Шаг 4. Обновление спецификации API Gateway<br />Наша функция готова, но по умолчанию она не является публичной. Предоставим доступ к этой функции с помощью API-шлюза &mdash; обновим ранее созданную спецификацию hello-world.yaml. Не забудьте вставить в файл идентификаторы вашей функции и вашего сервисного аккаунта:<br />openapi: "3.0.0"<br />info:<br />&nbsp; version: 1.0.0<br />&nbsp; title: Updated API<br />paths:<br />&nbsp; /results:<br />&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: cloud-functions<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function_id: &lt;идентификатор функции&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_account_id: &lt;идентификатор сервисного аккаунта&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: function-for-user-requests <br />Вызовем перезагрузку нашей спецификации:<br />yc serverless api-gateway update \<br />&nbsp; --name hello-world \<br />&nbsp; --spec=hello-world.yaml <br />Для тестирования вызовем функцию в браузере сначала без параметра secret, а затем &mdash; с ним:<br />https://&lt;идентификатор API Gateway&gt;.apigw.yandexcloud.net/results<br />https://&lt;идентификатор API Gateway&gt;.apigw.yandexcloud.net/results?secret=cecfb23c-bc86-4ca2-b611-e79bc77e5c31 <br />В ответе увидим результаты тестирования сервиса yandex.ru из базы данных.<br />Иногда приходится тестировать функцию в процессе разработки: для этого в консоли управления на странице функции перейдите на вкладку Тестирование, в поле Шаблон данных выберите HTTPS-вызов. Нажмите кнопку Запустить тест, и вы увидите код ошибки.<br />Код функции проверяет параметр secret для авторизации, то есть при вызове вы должны передать секретную последовательность, чтобы функция выдала результат. Добавим secret в параметры запроса в поле Входные данные:<br />&nbsp;&nbsp;&nbsp; "queryStringParameters": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "a": "2",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "b": "1",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "secret": "cecfb23c-bc86-4ca2-b611-e79bc77e5c31"<br />&nbsp;&nbsp;&nbsp; }, <br />Запустим тест ещё раз. В ответе отобразятся данные из базы, как и с запросами через браузер.<br /><strong>Decision:</strong><br />$ vim hello-world.yaml<br />$ cat hello-world.yaml<br />openapi: "3.0.0"<br />info:<br />&nbsp; version: 1.0.0<br />&nbsp; title: Test API<br />paths:<br />&nbsp; /hello:<br />&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; summary: Say hello<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: hello<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameters:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: user<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in: query<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; description: User name to appear in greetings<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; required: false<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schema:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: string<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: 'world'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; responses:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '200':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; description: Greeting<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'text/plain':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schema:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: "string"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: dummy<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http_code: 200<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http_headers:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Content-Type': "text/plain"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'text/plain': "Hello, {user}!\n"<br />$ yc serverless api-gateway create \<br />&nbsp; --name hello-world \<br />&nbsp; --spec=hello-world.yaml \<br />&nbsp; --description "hello world"<br />$ yc serverless api-gateway list<br />$ yc serverless api-gateway get --name hello-world<br />$ touch requirements.txt<br />$ sudo apt install python3-pip<br />$ pip install pipreqs<br />$ pipreqs $PWD --print<br />$ pipreqs $PWD --force<br />$ echo "export CONNECTION_ID=&lt;CONNECTION_ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export DB_USER=&lt;DB_USER&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export DB_HOST=&lt;DB_HOST&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ vim function-for-user-requests.py<br />$ cat function-for-user-requests.py<br />import json<br />import logging<br />import requests<br />import os<br />#Эти библиотеки нужны для работы с PostgreSQL<br />import psycopg2<br />import psycopg2.errors<br />import psycopg2.extras<br />CONNECTION_ID = os.getenv("CONNECTION_ID")<br />DB_USER = os.getenv("DB_USER")<br />DB_HOST = os.getenv("DB_HOST")<br /># Настраиваем функцию для записи информации в журнал функции<br /># Получаем стандартный логер языка Python<br />logger = logging.getLogger()<br />logger.setLevel(logging.INFO)<br /># Вычитываем переменную VERBOSE_LOG, которую мы указываем в переменных окружения<br />verboseLogging = eval(os.environ['VERBOSE_LOG'])&nbsp; ## Convert to bool<br />#Функция log, которая запишет текст в журнал выполнения функции, если в переменной окружения VERBOSE_LOG будет значение True<br />def log(logString):<br />&nbsp;&nbsp;&nbsp; if verboseLogging:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.info(logString)<br />#Запись в базу данных<br />def save(result, time, context):<br />&nbsp;&nbsp;&nbsp; connection = psycopg2.connect(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; database=CONNECTION_ID, # Идентификатор подключения<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user=DB_USER, # Пользователь БД<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; password=context.token["access_token"],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host=DB_HOST, # Точка входа<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port=6432,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sslmode="require")<br />&nbsp;&nbsp;&nbsp; cursor = connection.cursor()&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; postgres_insert_query = """INSERT INTO measurements (result, time) VALUES (%s,%s)"""<br />&nbsp;&nbsp;&nbsp; record_to_insert = (result, time)<br />&nbsp;&nbsp;&nbsp; cursor.execute(postgres_insert_query, record_to_insert)<br />&nbsp;&nbsp;&nbsp; connection.commit()<br />#Формируем запрос<br />def generateQuery():<br />&nbsp;&nbsp;&nbsp; select = f"SELECT * FROM measurements LIMIT 50"<br />&nbsp;&nbsp;&nbsp; result = select<br />&nbsp;&nbsp;&nbsp; return result<br />#Получаем подключение<br />def getConnString(context):<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; Extract env variables to connect to DB and return a db string<br />&nbsp;&nbsp;&nbsp; Raise an error if the env variables are not set<br />&nbsp;&nbsp;&nbsp; :return: string<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; connection = psycopg2.connect(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; database=CONNECTION_ID, # Идентификатор подключения<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user=DB_USER, # Пользователь БД<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; password=context.token["access_token"],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host=DB_HOST, # Точка входа<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port=6432,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sslmode="require")&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; return connection<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secret = event['queryStringParameters']['secret']<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if secret != 'cecfb23c-bc86-4ca2-b611-e79bc77e5c31':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise Exception()<br />&nbsp;&nbsp;&nbsp; except Exception as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error(error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusCode = 401<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; sql = generateQuery()<br />&nbsp;&nbsp;&nbsp; log(f'Exec: {sql}')<br />&nbsp;&nbsp;&nbsp; connection = getConnString(context)<br />&nbsp;&nbsp;&nbsp; log(f'Connecting: {connection}')<br />&nbsp;&nbsp;&nbsp; cursor = connection.cursor()<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(sql)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusCode = 200<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': json.dumps(cursor.fetchall()),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; except psycopg2.errors.UndefinedTable as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection.rollback()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error(error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusCode = 500<br />&nbsp;&nbsp;&nbsp; except Exception as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error(error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusCode = 500<br />&nbsp;&nbsp;&nbsp; cursor.close()<br />&nbsp;&nbsp;&nbsp; connection.close()<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': json.dumps({<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'event': event,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }),<br />&nbsp;&nbsp;&nbsp; }<br />$ yc serverless function create \<br />&nbsp; --name function-for-user-requests \<br />&nbsp; --description "function for response to user"<br />$ yc serverless function version create \<br />&nbsp; --function-name=function-for-user-requests \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=function-for-user-requests.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --environment VERBOSE_LOG=True \<br />&nbsp; --environment CONNECTION_ID=$CONNECTION_ID \<br />&nbsp; --environment DB_USER=$DB_USER \<br />&nbsp; --environment DB_HOST=$DB_HOST \<br />&nbsp; --source-path function-for-user-requests.py<br />$ vim hello-world1.yaml<br />$ cat hello-world1.yaml<br />openapi: "3.0.0"<br />info:<br />&nbsp; version: 1.0.0<br />&nbsp; title: Updated API<br />paths:<br />&nbsp; /results:<br />&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: cloud-functions<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function_id: &lt;идентификатор функции&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_account_id: &lt;идентификатор сервисного аккаунта&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: function-for-user-requests<br />$ yc serverless api-gateway update \<br />&nbsp; --name hello-world \<br />&nbsp; --spec=hello-world.yaml<br /><strong>Task:</strong><br />Загрузка данных, выполнение запросов AWS CLI.<br />B предыдущем уроке мы рассмотрели, как работать с YDB через Document API &mdash; низкоуровневый HTTP API, совместимый с AWS DynamoDB API.<br />В этом уроке рассмотрим операции создания таблицы, записи, чтения, изменения и удаления данных в таблице с помощью AWS CLI.<br /><strong>Decision:</strong><br />Сервисный аккаунт и ключ доступа. Для работы инструментов AWS вам понадобится создать сервисный аккаунт в облаке.<br />Выберите вкладку Сервисные аккаунты в каталоге, где расположена БД.<br />Нажмите кнопку Создать сервисный аккаунт.<br />Введите имя сервисного аккаунта. Чтобы назначить сервисному аккаунту роль на текущий каталог, нажмите Добавить роль и выберите роль, например editor.<br />Нажмите кнопку Создать.<br />Выберите созданный сервисный аккаунт и нажмите на строку с его именем. Нажмите кнопку Создать новый ключ на верхней панели. Выберите пункт Создать статический ключ доступа.<br />Сохраните идентификатор и секретный ключ.<br />Работа с AWS CLI. Установите AWS CLI с сайта https://aws.amazon.com/ru/cli/.<br />Для Windows: загрузите и запустите 64- или 32-разрядный установщик.<br />Для Mac и Linux: установите AWS CLI с помощью утилиты pip (требуется Python 2.6.5 или более поздней версии).<br />pip install awscli <br />Для настройки AWS CLI&nbsp; запустите команду:<br />aws configure <br />Введите сохраненные значения идентификатора ключа AWS Access Key ID и ключа AWS Secret Access Key и укажите ru-central1 в качестве Default region name.<br />Убедитесь, что в качестве переменной окружения ENDPOINT указано корректное значение эндпойнта вашей базы данных, либо добавьте его, как вы это делали в прошлом уроке: сохраните значение эндпойнта, указанное в строке Document API эндпоинт, в переменной окружения с помощью команды<br />export ENDPOINT=&lt;значение endpoint&gt; <br />Создание таблицы. Создайте таблицу с помощью команды:<br />aws dynamodb create-table \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --attribute-definitions \<br />&nbsp; AttributeName=series_id,AttributeType=N \<br />&nbsp; AttributeName=title,AttributeType=S \<br />&nbsp; --key-schema \<br />&nbsp; AttributeName=series_id,KeyType=HASH \<br />&nbsp; AttributeName=title,KeyType=RANGE \<br />&nbsp; --endpoint $ENDPOINT <br />Убедитесь, что в директории docapitest появилась таблица series.<br />Добавление данных в таблицу<br />Добавьте в таблицу две строки c помощью команд:<br />aws dynamodb put-item \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --item '{"series_id": {"N": "1"}, "title": {"S": "IT Crowd"}, "series_info": {"S": "The IT Crowd is a British sitcom produced by Channel 4, written by Graham Linehan, produced by Ash Atalla and starring Chris ODowd, Richard Ayoade, Katherine Parkinson, and Matt Berry."}, "release_date": {"S": "2006-02-03"}}' \<br />&nbsp; --endpoint $ENDPOINT <br />и<br />aws dynamodb put-item \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --item '{"series_id": {"N": "2"}, "title": {"S": "Silicon Valley"}, "series_info": {"S": "Silicon Valley is an American comedy television series created by Mike Judge, John Altschuler and Dave Krinsky."}, "release_date": {"S": "2014-04-06"}}' \<br />&nbsp; --endpoint $ENDPOINT <br />Чтение данных из таблицы. Для того чтобы прочитать данные из таблицы, выполните команду:<br />aws dynamodb get-item --consistent-read \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --key '{"series_id": {"N": "1"}, "title": {"S": "IT Crowd"}}' \<br />&nbsp; --endpoint $ENDPOINT <br />В качестве вывода вы увидите:<br />{<br />&nbsp;&nbsp;&nbsp; "Item": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "S": "2006-02-03"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_id": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "N": "1"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "S": "The IT Crowd is a British sitcom produced by Channel 4, written by Graham Linehan, produced by Ash Atalla and starring Chris ODowd, Richard Ayoade, Katherine Parkinson, and Matt Berry."<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "title": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "S": "IT Crowd"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />} <br />Для того, чтобы выбрать данные из таблицы series по ключу series_id, выполните следующую команду:<br />aws dynamodb query \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --key-condition-expression "series_id = :name" \<br />&nbsp; --expression-attribute-values '{":name":{"N":"2"}}' \<br />&nbsp; --endpoint $ENDPOINT <br />В качестве результата вы увидите:<br />{<br />&nbsp;&nbsp;&nbsp; "Items": [<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "S": "2014-04-06"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_id": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "N": "2"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "S": "Silicon Valley is an American comedy television series created by Mike Judge, John Altschuler and Dave Krinsky."<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "title": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "S": "Silicon Valley"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; ],<br />&nbsp;&nbsp;&nbsp; "Count": 1,<br />&nbsp;&nbsp;&nbsp; "ScannedCount": 1,<br />&nbsp;&nbsp;&nbsp; "ConsumedCapacity": null<br />} <br />Удаление таблицы<br />aws dynamodb delete-table \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --endpoint $ENDPOINT <br />На следующем практическом занятии мы разберём пример использования AWS SDK для работы с YDB в serverless-режиме.<br /><strong>Decision:</strong><br />$ pip install awscli<br />$ aws configure<br />$ export ENDPOINT=&lt;значение endpoint&gt;<br />$ aws dynamodb create-table \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --attribute-definitions \<br />&nbsp; AttributeName=series_id,AttributeType=N \<br />&nbsp; AttributeName=title,AttributeType=S \<br />&nbsp; --key-schema \<br />&nbsp; AttributeName=series_id,KeyType=HASH \<br />&nbsp; AttributeName=title,KeyType=RANGE \<br />&nbsp; --endpoint $ENDPOINT<br />$ aws dynamodb put-item \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --item '{"series_id": {"N": "1"}, "title": {"S": "IT Crowd"}, "series_info": {"S": "The IT Crowd is a British sitcom produced by Channel 4, written by Graham Linehan, produced by Ash Atalla and starring Chris ODowd, Richard Ayoade, Katherine Parkinson, and Matt Berry."}, "release_date": {"S": "2006-02-03"}}' \<br />&nbsp; --endpoint $ENDPOINT<br />$ aws dynamodb put-item \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --item '{"series_id": {"N": "2"}, "title": {"S": "Silicon Valley"}, "series_info": {"S": "Silicon Valley is an American comedy television series created by Mike Judge, John Altschuler and Dave Krinsky."}, "release_date": {"S": "2014-04-06"}}' \<br />&nbsp; --endpoint $ENDPOINT<br />$ aws dynamodb get-item --consistent-read \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --key '{"series_id": {"N": "1"}, "title": {"S": "IT Crowd"}}' \<br />&nbsp; --endpoint $ENDPOINT<br />$ aws dynamodb query \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --key-condition-expression "series_id = :name" \<br />&nbsp; --expression-attribute-values '{":name":{"N":"2"}}' \<br />&nbsp; --endpoint $ENDPOINT<br />$ aws dynamodb delete-table \<br />&nbsp; --table-name docapitest/series \<br />&nbsp; --endpoint $ENDPOINT<br /><strong>Task:</strong><br />Запуск тестового приложения<br />В предыдущем уроке вы прошли подготовительные этапы: создали и настроили сервисный аккаунт, выпустили статический ключ, а также научились работать с таблицами и данными с помощью низкоуровневого API и CLI.<br />В этом уроке вы продолжите работу с инструментами AWS и с помощью AWS SDK для языка Python научитесь выполнять такие базовые операции, как создание таблиц БД, запись и чтение данных.<br /><strong>Decision:</strong><br />Для выполнения работы вам понадобится Python версии 3.6 и выше и библиотека boto3.<br />Установить эту библиотеку можно с помощью команды:<br />pip install boto3 <br />Создание таблицы<br />Создайте файл с именем SeriesCreateTable.py и скопируйте в него исходный код программы:<br />import boto3<br />def create_series_table():<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.create_table(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TableName = 'docapitest/series', # Series &mdash; имя таблицы <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeySchema = [<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeName': 'series_id',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'KeyType': 'HASH'&nbsp; # Ключ партицирования<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeName': 'title',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'KeyType': 'RANGE'&nbsp; # Ключ сортировки<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AttributeDefinitions = [<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeName': 'series_id',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeType': 'N'&nbsp; # Целое число<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeName': 'title',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeType': 'S'&nbsp; # Строка<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return table<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; series_table = create_series_table()<br />&nbsp;&nbsp;&nbsp; print("Table status:", series_table.table_status) <br />Отредактируйте исходный код файла и укажите значение endpoint_url вашей базы. Затем запустите написанный код:<br />python SeriesCreateTable.py <br />С помощью консоли управления убедитесь, что&nbsp; в директории docapitest появилась таблица series.<br />Первоначальная загрузка данных<br />Для того чтобы вставить данные в созданную таблицу series, создайте файл с именем SeriesLoadData.py и скопируйте в него следующий исходный код программы:<br />from decimal import Decimal<br />import json<br />import boto3<br />def load_series(series):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document API эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; for serie in series:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; series_id = int(serie['series_id'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; title = serie['title']<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Series added:", series_id, title)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table.put_item(Item = serie)<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; with open("seriesdata.json") as json_file:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serie_list = json.load(json_file, parse_float = Decimal)<br />&nbsp;&nbsp;&nbsp; load_series(serie_list) <br />Отредактируйте файл SeriesLoadData.py и укажите значение endpoint_url вашей базы.<br />Для загрузки данных приложение будет использовать данные, которые записаны в файл seriesdata.json. Создайте этот файл и скопируйте в него описание сериалов:<br />[{<br />&nbsp;&nbsp;&nbsp; "series_id": 1,<br />&nbsp;&nbsp;&nbsp; "title": "IT Crowd",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2006-02-03T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "The IT Crowd is a British sitcom produced by Channel 4, written by Graham Linehan, produced by Ash Atalla and starring Chris O'Dowd, Richard Ayoade, Katherine Parkinson, and Matt Berry"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 2,<br />&nbsp;&nbsp;&nbsp; "title": "Silicon Valley",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2014-04-06T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "Silicon Valley is an American comedy television series created by Mike Judge, John Altschuler and Dave Krinsky. The series focuses on five young men who founded a startup company in Silicon Valley"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 3,<br />&nbsp;&nbsp;&nbsp; "title": "House of Cards",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2013-02-01T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "House of Cards is an American political thriller streaming television series created by Beau Willimon. It is an adaptation of the 1990 BBC miniseries of the same name and based on the 1989 novel of the same name by Michael Dobbs"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 3,<br />&nbsp;&nbsp;&nbsp; "title": "The Office",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2005-03-24T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "The Office is an American mockumentary sitcom television series that depicts the everyday work lives of office employees in the Scranton, Pennsylvania, branch of the fictional Dunder Mifflin Paper Company"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 3,<br />&nbsp;&nbsp;&nbsp; "title": "True Detective",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2014-01-12T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "True Detective is an American anthology crime drama television series created and written by Nic Pizzolatto. The series, broadcast by the premium cable network HBO in the United States, premiered on January 12, 2014"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 4,<br />&nbsp;&nbsp;&nbsp; "title": "The Big Bang Theory",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2007-09-24T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "The Big Bang Theory is an American television sitcom created by Chuck Lorre and Bill Prady, both of whom served as executive producers on the series, along with Steven Molaro"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 5,<br />&nbsp;&nbsp;&nbsp; "title": "Twin Peaks",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "1990-04-08T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "Twin Peaks is an American mystery horror drama television series created by Mark Frost and David Lynch that premiered on April 8, 1990, on ABC until its cancellation after its second season in 1991 before returning as a limited series in 2017 on Showtime"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br />] <br />Запустите программу (для её успешного выполнения может понадобиться указать в скрипте SeriesLoadData.py полный путь к файлу seriesdata.json):<br />python SeriesLoadData.py <br />В результате выполнения вы увидите вывод программы:<br />Series added: 1 IT Crowd<br />Series added: 2 Silicon Valley<br />Series added: 3 House of Cards<br />Series added: 3 The Office<br />Series added: 3 True Detective<br />Series added: 4 The Big Bang Theory<br />Series added: 5 Twin Peaks <br />Работа с записями<br />Создание записи<br />Теперь создайте файл SeriesItemPut.py и скопируйте в него следующий код:<br />from pprint import pprint<br />import boto3<br />def put_serie(series_id, title, release_date, series_info):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; response = table.put_item(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Item = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'series_id': series_id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'title': title,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'info': {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'release_date': release_date,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'series_info': series_info<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return response<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; serie_resp = put_serie(3, "Supernatural", "2015-09-13",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Supernatural is an American television series created by Eric Kripke")<br />&nbsp;&nbsp;&nbsp; print("Series added successfully:")<br />&nbsp;&nbsp;&nbsp; pprint(serie_resp, sort_dicts = False) <br />В результате выполнения этого кода в таблице добавится запись о сериале Supernatural.<br />Чтение записи<br />Создайте файл SeriesItemGet.py и скопируйте в него следующий код:<br />from pprint import pprint<br />import boto3<br />from botocore.exceptions import ClientError<br />def get_serie(title, series_id):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = table.get_item(Key = {'series_id': series_id, 'title': title})<br />&nbsp;&nbsp;&nbsp; except ClientError as e:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(e.response['Error']['Message'])<br />&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return response['Item']<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; serie = get_serie("Supernatural", 3,)<br />&nbsp;&nbsp;&nbsp; if serie:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Record read:")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pprint(serie, sort_dicts = False) <br />Результатом будет сообщение в формате JSON с данными о сериале.<br />Обновление записи<br />В файле SeriesItemUpdate.py разместите код обновления записи:<br />from decimal import Decimal<br />from pprint import pprint<br />import boto3<br />def update_serie(title, series_id, release_date,&nbsp; rating):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; response = table.update_item(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'series_id': series_id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'title': title<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateExpression = "set info.release_date = :d, info.rating = :r ",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExpressionAttributeValues = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ':d': release_date,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ':r': Decimal(rating)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReturnValues = "UPDATED_NEW"<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return response<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; update_response = update_serie(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Supernatural", 3, "2005-09-13", 8)<br />&nbsp;&nbsp;&nbsp; print("Series updated:")<br />&nbsp;&nbsp;&nbsp; pprint(update_response, sort_dicts = False) <br />Результатом будет сообщение в формате JSON с измененными данными.<br />Удаление записи<br />Создайте файл SeriesItemDelete.py и скопируйте в него следующий код:<br />from decimal import Decimal<br />from pprint import pprint<br />import boto3<br />from botocore.exceptions import ClientError<br />def delete_underrated_serie(title, series_id, rating):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = table.delete_item(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'series_id': series_id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'title': title<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConditionExpression = "info.rating &lt;= :val",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExpressionAttributeValues = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ":val": Decimal(rating)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; except ClientError as e:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if e.response['Error']['Code'] == "ConditionalCheckFailedException":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(e.response['Error']['Message'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise<br />&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return response<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; print("Deleting...")<br />&nbsp;&nbsp;&nbsp; delete_response = delete_underrated_serie("Supernatural", 3, 8)<br />&nbsp;&nbsp;&nbsp; if delete_response:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Series data deleted:")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pprint(delete_response, sort_dicts = False) <br />Убедитесь, что данные о сериале Supernatural удалены из таблицы.<br />Поиск по ключам партицирования и сортировки<br />Код поиска разместите в новом файле SeriesQuery.py:<br />from pprint import pprint<br />import boto3<br />from boto3.dynamodb.conditions import Key<br />def query_and_project_series(series_id, title_range):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; response = table.query(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProjectionExpression = "series_id, title, info.release_date",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyConditionExpression = Key('series_id').eq(series_id) &amp; Key('title').begins_with(title_range)<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return response['Items']<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; query_id = 3<br />&nbsp;&nbsp;&nbsp; query_range = 'T'<br />&nbsp;&nbsp;&nbsp; print(f"Series with ID = {query_id} and names beginning with "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f"{query_range}")<br />&nbsp;&nbsp;&nbsp; series = query_and_project_series(query_id, query_range)<br />&nbsp;&nbsp;&nbsp; for serie in series:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"\n{serie['series_id']} : {serie['title']}")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pprint(serie['info']) <br />Результатом будет сообщение:<br />Series with ID = 3 and names beginning with T<br />3 : The Office<br />{'release_date': '2005-03-24T00:00:00Z'}<br />3 : True Detective<br />{'release_date': '2014-01-12T00:00:00Z'} <br />Запуск операции Scan<br />Создайте файл SeriesTableScan.py и скопируйте в него следующий код:<br />from pprint import pprint<br />import boto3<br />from boto3.dynamodb.conditions import Key<br />def scan_series(id_range, display_series):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; scan_kwargs = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'FilterExpression': Key('series_id').between(*id_range),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ProjectionExpression': "series_id, title, info.release_date"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; done = False<br />&nbsp;&nbsp;&nbsp; start_key = None<br />&nbsp;&nbsp;&nbsp; while not done:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if start_key:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scan_kwargs['ExclusiveStartKey'] = start_key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = table.scan(**scan_kwargs)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display_series(response.get('Items', []))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start_key = response.get('LastEvaluatedKey', None)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; done = start_key is None<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; def print_series(series):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for serie in series:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"\n{serie['series_id']} : {serie['title']}")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pprint(serie['info'])<br />&nbsp;&nbsp;&nbsp; query_range = (1, 3)<br />&nbsp;&nbsp;&nbsp; print(f"Series with IDs from {query_range[0]} to {query_range[1]}...")<br />&nbsp;&nbsp;&nbsp; scan_series(query_range, print_series) <br />Результатом будет сообщение:<br />Series with IDs from 1 to 3...<br />3 : House of Cards<br />{'release_date': '2013-02-01T00:00:00Z'}<br />3 : The Office<br />{'release_date': '2005-03-24T00:00:00Z'}<br />3 : True Detective<br />{'release_date': '2014-01-12T00:00:00Z'}<br />1 : IT Crowd<br />{'release_date': '2006-02-03T00:00:00Z'}<br />2 : Silicon Valley<br />{'release_date': '2014-04-06T00:00:00Z'} <br />Удаление таблицы<br />Создайте файл SeriesTableDelete.py и скопируйте в него следующий код:<br />import boto3<br />def delete_serie_table():<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; table.delete()<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; delete_serie_table()<br />&nbsp;&nbsp;&nbsp; print("Table Series deleted") <br />Убедитесь, что таблица удалена из базы данных.<br /><strong>Decision:</strong><br />$ pip install boto3<br />$ vim SeriesCreateTable.py<br />$ cat SeriesCreateTable.py<br />import boto3<br />def create_series_table():<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.create_table(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TableName = 'docapitest/series', # Series &mdash; имя таблицы <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeySchema = [<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeName': 'series_id',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'KeyType': 'HASH'&nbsp; # Ключ партицирования<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeName': 'title',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'KeyType': 'RANGE'&nbsp; # Ключ сортировки<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AttributeDefinitions = [<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeName': 'series_id',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeType': 'N'&nbsp; # Целое число<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeName': 'title',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AttributeType': 'S'&nbsp; # Строка<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return table<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; series_table = create_series_table()<br />&nbsp;&nbsp;&nbsp; print("Table status:", series_table.table_status)<br />$ python SeriesCreateTable.py<br />$ vim SeriesLoadData.py<br />$ cat SeriesLoadData.py<br />from decimal import Decimal<br />import json<br />import boto3<br />def load_series(series):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document API эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; for serie in series:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; series_id = int(serie['series_id'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; title = serie['title']<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Series added:", series_id, title)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table.put_item(Item = serie)<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; with open("seriesdata.json") as json_file:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serie_list = json.load(json_file, parse_float = Decimal)<br />&nbsp;&nbsp;&nbsp; load_series(serie_list)<br />$ vim seriesdata.json<br />$ cat seriesdata.json<br />[{<br />&nbsp;&nbsp;&nbsp; "series_id": 1,<br />&nbsp;&nbsp;&nbsp; "title": "IT Crowd",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2006-02-03T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "The IT Crowd is a British sitcom produced by Channel 4, written by Graham Linehan, produced by Ash Atalla and starring Chris O'Dowd, Richard Ayoade, Katherine Parkinson, and Matt Berry"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 2,<br />&nbsp;&nbsp;&nbsp; "title": "Silicon Valley",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2014-04-06T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "Silicon Valley is an American comedy television series created by Mike Judge, John Altschuler and Dave Krinsky. The series focuses on five young men who founded a startup company in Silicon Valley"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 3,<br />&nbsp;&nbsp;&nbsp; "title": "House of Cards",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2013-02-01T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "House of Cards is an American political thriller streaming television series created by Beau Willimon. It is an adaptation of the 1990 BBC miniseries of the same name and based on the 1989 novel of the same name by Michael Dobbs"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 3,<br />&nbsp;&nbsp;&nbsp; "title": "The Office",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2005-03-24T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "The Office is an American mockumentary sitcom television series that depicts the everyday work lives of office employees in the Scranton, Pennsylvania, branch of the fictional Dunder Mifflin Paper Company"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 3,<br />&nbsp;&nbsp;&nbsp; "title": "True Detective",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2014-01-12T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "True Detective is an American anthology crime drama television series created and written by Nic Pizzolatto. The series, broadcast by the premium cable network HBO in the United States, premiered on January 12, 2014"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 4,<br />&nbsp;&nbsp;&nbsp; "title": "The Big Bang Theory",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "2007-09-24T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "The Big Bang Theory is an American television sitcom created by Chuck Lorre and Bill Prady, both of whom served as executive producers on the series, along with Steven Molaro"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; },<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; "series_id": 5,<br />&nbsp;&nbsp;&nbsp; "title": "Twin Peaks",<br />&nbsp;&nbsp;&nbsp; "info": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "release_date": "1990-04-08T00:00:00Z",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "series_info": "Twin Peaks is an American mystery horror drama television series created by Mark Frost and David Lynch that premiered on April 8, 1990, on ABC until its cancellation after its second season in 1991 before returning as a limited series in 2017 on Showtime"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br />]<br />$ python SeriesLoadData.py<br />$ vim SeriesItemPut.py<br />$ cat SeriesItemPut.py<br />from pprint import pprint<br />import boto3<br />def put_serie(series_id, title, release_date, series_info):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; response = table.put_item(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Item = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'series_id': series_id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'title': title,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'info': {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'release_date': release_date,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'series_info': series_info<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return response<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; serie_resp = put_serie(3, "Supernatural", "2015-09-13",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Supernatural is an American television series created by Eric Kripke")<br />&nbsp;&nbsp;&nbsp; print("Series added successfully:")<br />&nbsp;&nbsp;&nbsp; pprint(serie_resp, sort_dicts = False)<br />$ vim SeriesItemGet.py<br />$ cat SeriesItemGet.py<br />from pprint import pprint<br />import boto3<br />from botocore.exceptions import ClientError<br />def get_serie(title, series_id):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = table.get_item(Key = {'series_id': series_id, 'title': title})<br />&nbsp;&nbsp;&nbsp; except ClientError as e:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(e.response['Error']['Message'])<br />&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return response['Item']<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; serie = get_serie("Supernatural", 3,)<br />&nbsp;&nbsp;&nbsp; if serie:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Record read:")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pprint(serie, sort_dicts = False)<br />$ vim SeriesItemUpdate.py<br />$ cat SeriesItemUpdate.py<br />from decimal import Decimal<br />from pprint import pprint<br />import boto3<br />def update_serie(title, series_id, release_date,&nbsp; rating):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; response = table.update_item(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'series_id': series_id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'title': title<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateExpression = "set info.release_date = :d, info.rating = :r ",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExpressionAttributeValues = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ':d': release_date,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ':r': Decimal(rating)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReturnValues = "UPDATED_NEW"<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return response<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; update_response = update_serie(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Supernatural", 3, "2005-09-13", 8)<br />&nbsp;&nbsp;&nbsp; print("Series updated:")<br />&nbsp;&nbsp;&nbsp; pprint(update_response, sort_dicts = False)<br />$ vim SeriesItemDelete.py<br />$ cat SeriesItemDelete.py<br />from decimal import Decimal<br />from pprint import pprint<br />import boto3<br />from botocore.exceptions import ClientError<br />def delete_underrated_serie(title, series_id, rating):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = table.delete_item(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'series_id': series_id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'title': title<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConditionExpression = "info.rating &lt;= :val",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExpressionAttributeValues = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ":val": Decimal(rating)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; except ClientError as e:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if e.response['Error']['Code'] == "ConditionalCheckFailedException":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(e.response['Error']['Message'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise<br />&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return response<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; print("Deleting...")<br />&nbsp;&nbsp;&nbsp; delete_response = delete_underrated_serie("Supernatural", 3, 8)<br />&nbsp;&nbsp;&nbsp; if delete_response:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Series data deleted:")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pprint(delete_response, sort_dicts = False)<br />$ vim SeriesQuery.py<br />$ cat SeriesQuery.py<br />from pprint import pprint<br />import boto3<br />from boto3.dynamodb.conditions import Key<br />def query_and_project_series(series_id, title_range):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; response = table.query(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProjectionExpression = "series_id, title, info.release_date",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyConditionExpression = Key('series_id').eq(series_id) &amp; Key('title').begins_with(title_range)<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return response['Items']<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; query_id = 3<br />&nbsp;&nbsp;&nbsp; query_range = 'T'<br />&nbsp;&nbsp;&nbsp; print(f"Series with ID = {query_id} and names beginning with "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f"{query_range}")<br />&nbsp;&nbsp;&nbsp; series = query_and_project_series(query_id, query_range)<br />&nbsp;&nbsp;&nbsp; for serie in series:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"\n{serie['series_id']} : {serie['title']}")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pprint(serie['info'])<br />$ vim SeriesTableScan.py<br />$ cat SeriesTableScan.py<br />from pprint import pprint<br />import boto3<br />from boto3.dynamodb.conditions import Key<br />def scan_series(id_range, display_series):<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; scan_kwargs = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'FilterExpression': Key('series_id').between(*id_range),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ProjectionExpression': "series_id, title, info.release_date"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; done = False<br />&nbsp;&nbsp;&nbsp; start_key = None<br />&nbsp;&nbsp;&nbsp; while not done:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if start_key:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scan_kwargs['ExclusiveStartKey'] = start_key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = table.scan(**scan_kwargs)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display_series(response.get('Items', []))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start_key = response.get('LastEvaluatedKey', None)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; done = start_key is None<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; def print_series(series):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for serie in series:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"\n{serie['series_id']} : {serie['title']}")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pprint(serie['info'])<br />&nbsp;&nbsp;&nbsp; query_range = (1, 3)<br />&nbsp;&nbsp;&nbsp; print(f"Series with IDs from {query_range[0]} to {query_range[1]}...")<br />&nbsp;&nbsp;&nbsp; scan_series(query_range, print_series)<br />$ vim SeriesTableDelete.py<br />$ cat SeriesTableDelete.py<br />import boto3<br />def delete_serie_table():<br />&nbsp;&nbsp;&nbsp; ydb_docapi_client = boto3.resource('dynamodb', endpoint_url = "&lt;Document_API_эндпоинт&gt;")<br />&nbsp;&nbsp;&nbsp; table = ydb_docapi_client.Table('docapitest/series')<br />&nbsp;&nbsp;&nbsp; table.delete()<br />if __name__ == '__main__':<br />&nbsp;&nbsp;&nbsp; delete_serie_table()<br />&nbsp;&nbsp;&nbsp; print("Table Series deleted")<br /><strong>Task:</strong><br />Проверка доступности веб-ресурсов. <br />В этом уроке вы доработаете систему проверки доступности веб-ресурсов, которую создали на предыдущих практических занятиях. <br />В текущем варианте она проверяет только доступность сайта yandex.ru. <br />Теперь давайте добавим в неё возможность ставить задачи по проверке доступности других веб-ресурсов.<br /><strong>Decision:</strong><br />Общая архитектура системы. У системы есть два метода: CheckUrl &mdash; ставит задачу на проверку указанного URL. GetResult &mdash; считывает результаты проверки.<br />Метод CheckUrl обрабатывается функцией, которая будет складывать все запросы в очередь. Функция-обработчик будет вызываться раз в секунду, считывать URL из очереди,&nbsp; проверять его доступность и записывать результат в базу данных. Оттуда этот результат можно будет получить с помощью метода GetResult.<br />Мы не будем менять уже созданные функции и таблицу в PostgreSQL, сделаем новые.<br />Работать с YMQ из функций мы будем с помощью библиотеки boto3. Чтобы её использовать, нужно создать сервисный аккаунт с секретным ключом доступа, а затем настроить зависимости функции. Сделаем это после того, как создадим очередь.<br />Шаг 1. Проверить наличие сервисного аккаунта<br />Если вы ранее создавали сервисный аккаунт с именем service-account-for-cf, добавляли вновь созданному сервисному аккаунту роли editor и другие, то вам остаётся только создать ключ доступа:<br />yc iam access-key create --service-account-name service-account-for-cf <br />В результате вы получите примерно следующее:<br />&nbsp;&nbsp;&nbsp; access_key:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id: ajefraollq5puj2tir1o<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_account_id: ajetdv28pl0a1a8r41f0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; created_at: "2021-08-23T21:13:05.677319393Z"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key_id: BTPNvWthv0ZX2xVmlPIU<br />&nbsp;&nbsp;&nbsp; secret: cWLQ0HrTM0k_qAac43cwMNJA8VV_rfTg_kd4xVPi <br />Здесь key_id &mdash; это идентификатор ключа доступа ACCESS_KEY. А secret &mdash; это секретный ключ SECRET_KEY. Переменные ACCESS_KEY и SECRET_KEY могут быть использованы для задания соответствующих значений aws_access_key_id и aws_secret_access_key при использовании библиотеки boto3.<br />Шаг 2. Создание очереди Yandex Message Queue<br />Вы можете создать очередь одним из трёх способов: через консоль управления; с помощью консольной утилиты aws; с помощью Terraform.<br />В этом уроке мы будем использовать консоль управления. Откройте раздел Message Queue и нажмите кнопку Создать очередь.<br />В настройках создаваемой очереди задайте имя очереди my-first-queue, затем выберите тип очереди Стандартная и нажмите кнопку Создать.<br />Очередь создана.<br />Теперь зайдите в настройки очереди, чтобы посмотреть параметры подключения к ней. Нам потребуется значение URL.<br />Шаг 3. Создание функции<br />Для создания функции зададим ряд переменных: VERBOSE_LOG &mdash; определяет, пишет ли функция подробности своего выполнения в журнал. AWS_ACCESS_KEY_ID &mdash; значение &laquo;Идентификатор ключа&raquo; из сервисного аккаунта, который мы сделали ранее. AWS_SECRET_ACCESS_KEY &mdash; значение &laquo;Секретный ключ&raquo; из того же сервисного аккаунта. QUEUE_URL &mdash; URL на очередь, его можно получить на обзорной странице созданной ранее очереди.<br />Чтобы задать переменные, в консоли выполните следующие команды:<br />echo "export VERBOSE_LOG=True" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export AWS_ACCESS_KEY_ID=&lt;AWS_ACCESS_KEY_ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export AWS_SECRET_ACCESS_KEY=&lt;AWS_SECRET_ACCESS_KEY&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export QUEUE_URL=&lt;QUEUE_URL&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc <br />Воспользуйтесь командой pipreqs $PWD --force для формирования файла requirements.txt. Затем создайте функцию my-url-receiver-function.py:<br />import logging<br />import os<br />import boto3<br />logger = logging.getLogger()<br />logger.setLevel(logging.INFO)<br />verboseLogging = eval(os.environ['VERBOSE_LOG'])&nbsp; ## Convert to bool<br />queue_url = os.environ['QUEUE_URL']<br />def log(logString):<br />&nbsp;&nbsp;&nbsp; if verboseLogging:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.info(logString)<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; # Get url<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; url = event['queryStringParameters']['url']<br />&nbsp;&nbsp;&nbsp; except Exception as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error(error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusCode = 400<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; # Create client<br />&nbsp;&nbsp;&nbsp; client = boto3.client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='sqs',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://message-queue.api.cloud.yandex.net',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; region_name='ru-central1'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; # Send message to queue<br />&nbsp;&nbsp;&nbsp; client.send_message(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QueueUrl=queue_url,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBody=url<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; log('Successfully sent test message to queue')<br />&nbsp;&nbsp;&nbsp; statusCode = 200<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode<br />&nbsp;&nbsp;&nbsp; } <br />Перейдите в директорию с исходными файлами и упакуйте файлы с функцией и требованиями в ZIP-архив. При этом сразу задайте все необходимые переменные и сервисный аккаунт:<br />zip my-url-receiver-function my-url-receiver-function.py requirements.txt<br />yc serverless function create \<br />&nbsp; --name&nbsp; my-url-receiver-function \<br />&nbsp; --description "function for url"<br />yc serverless function version create \<br />&nbsp; --function-name=my-url-receiver-function \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=my-url-receiver-function.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --environment VERBOSE_LOG=$VERBOSE_LOG \<br />&nbsp; --environment AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \<br />&nbsp; --environment AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \<br />&nbsp; --environment QUEUE_URL=$QUEUE_URL \<br />&nbsp; --source-path my-url-receiver-function.zip <br />Тестирование функции. Находясь в вашем рабочем каталоге, перейдите в раздел Cloud Functions консоли управления и выберите ранее созданную функцию my-url-receiver-function. Перейдите на вкладку Тестирование в боковом меню, выберите шаблон HTTPS-вызов и замените раздел queryStringParameters:<br />&nbsp;&nbsp;&nbsp; "queryStringParameters": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "a": "2",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "b": "1",<br />&nbsp;&nbsp;&nbsp; },&nbsp;&nbsp;&nbsp; &nbsp;<br />на аналогичный, но с параметром url с любым сайтом. Важно указывать ссылку целиком.<br />&nbsp;&nbsp;&nbsp; "queryStringParameters": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "url": "https://ya.ru/"<br />&nbsp;&nbsp;&nbsp; },&nbsp;&nbsp;&nbsp; &nbsp;<br />Нажмите кнопку Запустить тест.<br />Если вы всё сделали правильно, то увидите код статуса 200. При этом в очереди увеличится количество сообщений.<br />Шаг 4. Обновление спецификации API Gateway<br />Функция готова, но по умолчанию она не является публичной. Предоставим доступ к ней с помощью API-шлюза. Для этого необходимо обновить ранее созданную спецификацию hello-world.yaml. Если у вас нет её под рукой, выгрузите её из облака:<br />yc serverless api-gateway get-spec \<br />&nbsp; --name hello-world &gt;&gt; hello-world-new.yaml <br />Внесите изменения, добавив секцию о ранее созданной функции:<br />&nbsp;&nbsp;&nbsp; /check:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: cloud-functions<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function_id: &lt;идентификатор функции&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_account_id: &lt;идентификатор сервисного аккаунта&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: add-url <br />Обновите конфигурацию:<br />yc serverless api-gateway update \<br />&nbsp; --name hello-world \<br />&nbsp; --spec=hello-world-new.yaml <br />Для тестирования выполните вызов функции в браузере:<br />https://&lt;идентификатор API Gateway&gt;.apigw.yandexcloud.net/check?url=https://ya.ru/ <br />После каждого запроса количество сообщений в очереди будет увеличиваться на одно.<br />Шаг 5. Создание функции для чтения из очереди<br />В предыдущих работах мы создавали функцию, использующую подключение к БД. Здесь мы повторим этот опыт.<br />Проверим, что нам доступны переменные для инициации подключения: CONNECTION_ID, DB_USER, DB_HOST. Мы создавали их в предыдущей работе с помощью следующих команд:<br />echo "export CONNECTION_ID=&lt;CONNECTION_ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export DB_USER=&lt;DB_USER&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo "export DB_HOST=&lt;DB_HOST&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc <br />Также для работы с очередью нам потребуются переменные VERBOSE_LOG, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY и QUEUE_URL, заданные на предыдущих шагах.<br />Создадим функцию function-for-url-from-mq.py и воспользуемся командой pipreqs $PWD --force, чтобы сформировать для нее файл requirements.txt.<br />import logging<br />import os<br />import boto3<br />import datetime<br />import requests<br />#Эти библиотеки нужны для работы с PostgreSQL<br />import psycopg2<br />import psycopg2.errors<br />import psycopg2.extras<br />CONNECTION_ID = os.getenv("CONNECTION_ID")<br />DB_USER = os.getenv("DB_USER")<br />DB_HOST = os.getenv("DB_HOST")<br />QUEUE_URL = os.environ['QUEUE_URL']<br /># Настраиваем функцию для записи информации в журнал функции<br /># Получаем стандартный логер языка Python<br />logger = logging.getLogger()<br />logger.setLevel(logging.INFO)<br /># Вычитываем переменную VERBOSE_LOG, которую мы указываем в переменных окружения <br />verboseLogging = eval(os.environ['VERBOSE_LOG'])&nbsp; ## Convert to bool<br />#Функция log, которая запишет текст в журнал выполнения функции, если в переменной окружения VERBOSE_LOG будет значение True<br />def log(logString):<br />&nbsp;&nbsp;&nbsp; if verboseLogging:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.info(logString)<br />#Получаем подключение<br />def getConnString(context):<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; Extract env variables to connect to DB and return a db string<br />&nbsp;&nbsp;&nbsp; Raise an error if the env variables are not set<br />&nbsp;&nbsp;&nbsp; :return: string<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; connection = psycopg2.connect(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; database=CONNECTION_ID, # Идентификатор подключения<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user=DB_USER, # Пользователь БД<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; password=context.token["access_token"],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host=DB_HOST, # Точка входа<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port=6432,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sslmode="require")<br />&nbsp;&nbsp;&nbsp; return connection<br />"""<br />&nbsp;&nbsp;&nbsp; Create SQL query with table creation<br />"""<br />def makeCreateDataTableQuery(table_name):<br />&nbsp;&nbsp;&nbsp; query = f"""CREATE TABLE public.{table_name} (<br />&nbsp;&nbsp;&nbsp; url text,<br />&nbsp;&nbsp;&nbsp; result integer,<br />&nbsp;&nbsp;&nbsp; time float<br />&nbsp;&nbsp;&nbsp; )"""<br />&nbsp;&nbsp;&nbsp; return query<br />def makeInsertDataQuery(table_name, url, result, time):<br />&nbsp;&nbsp;&nbsp; query = f"""INSERT INTO {table_name} <br />&nbsp;&nbsp;&nbsp; (url, result,time)<br />&nbsp;&nbsp;&nbsp; VALUES('{url}', {result}, {time})<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; return query<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; # Create client<br />&nbsp;&nbsp;&nbsp; client = boto3.client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='sqs',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://message-queue.api.cloud.yandex.net',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; region_name='ru-central1'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; # Receive sent message<br />&nbsp;&nbsp;&nbsp; messages = client.receive_message(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QueueUrl=QUEUE_URL,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MaxNumberOfMessages=1,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VisibilityTimeout=60,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WaitTimeSeconds=1<br />&nbsp;&nbsp;&nbsp; ).get('Messages')<br />&nbsp;&nbsp;&nbsp; if messages is None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': 200<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; for msg in messages:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log('Received message: "{}"'.format(msg.get('Body')))<br />&nbsp;&nbsp;&nbsp; # Get url from message<br />&nbsp;&nbsp;&nbsp; url = msg.get('Body');<br />&nbsp;&nbsp;&nbsp; # Check url<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now = datetime.datetime.now()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = requests.get(url, timeout=(1.0000, 3.0000))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timediff = datetime.datetime.now() - now<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = response.status_code<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.ReadTimeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 601<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.ConnectTimeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 602<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.Timeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 603<br />&nbsp;&nbsp;&nbsp; log(f'Result: {result} Time: {timediff.total_seconds()}')<br />&nbsp;&nbsp;&nbsp; connection = getConnString(context)<br />&nbsp;&nbsp;&nbsp; log(f'Connecting: {connection}')&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; cursor = connection.cursor()<br />&nbsp;&nbsp;&nbsp; table_name = 'custom_request_result'<br />&nbsp;&nbsp;&nbsp; sql = makeInsertDataQuery(table_name, url, result, timediff.total_seconds())<br />&nbsp;&nbsp;&nbsp; log(f'Exec: {sql}')<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(sql)<br />&nbsp;&nbsp;&nbsp; except psycopg2.errors.UndefinedTable as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log(f'Table not exist - create and repeate insert')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection.rollback()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error(error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; createTable = makeCreateDataTableQuery(table_name)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log(f'Exec: {createTable}')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(createTable)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection.commit()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log(f'Exec: {sql}')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(sql)<br />&nbsp;&nbsp;&nbsp; except Exception as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error( error)<br />&nbsp;&nbsp;&nbsp; connection.commit()<br />&nbsp;&nbsp;&nbsp; cursor.close()<br />&nbsp;&nbsp;&nbsp; connection.close()<br />&nbsp;&nbsp;&nbsp; # Delete processed messages<br />&nbsp;&nbsp;&nbsp; for msg in messages:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; client.delete_message(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QueueUrl=QUEUE_URL,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReceiptHandle=msg.get('ReceiptHandle')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('Successfully deleted message by receipt handle "{}"'.format(msg.get('ReceiptHandle')))<br />&nbsp;&nbsp;&nbsp; statusCode = 200<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode<br />&nbsp;&nbsp;&nbsp; } <br />При создании сразу задайте все необходимые переменные и сервисный аккаунт:<br />zip function-for-url-from-mq function-for-url-from-mq.py requirements.txt<br />yc serverless function create \<br />&nbsp; --name function-for-url-from-mq \<br />&nbsp; --description "function for url from mq"<br />yc serverless function version create \<br />&nbsp; --function-name=function-for-url-from-mq \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=function-for-url-from-mq.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --environment VERBOSE_LOG=True \<br />&nbsp; --environment CONNECTION_ID=$CONNECTION_ID \<br />&nbsp; --environment DB_USER=$DB_USER \<br />&nbsp; --environment DB_HOST=$DB_HOST \<br />&nbsp; --environment AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \<br />&nbsp; --environment AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \<br />&nbsp; --environment QUEUE_URL=$QUEUE_URL \<br />&nbsp; --source-path function-for-url-from-mq.zip <br />Протестируйте функцию.<br />После её выполнения количество сообщений в очереди уменьшится, а в базе данных появится новая таблица с результатами тестирования доступности функции.<br />Шаг 6. Создание триггера<br />Создадим триггер, который будет вызывать функцию обработки сообщений из очереди один раз в минуту. Он будет использовать cron-выражение:<br />yc serverless trigger create timer \<br />&nbsp; --name trigger-for-mq \<br />&nbsp; --invoke-function-name function-for-url-from-mq \<br />&nbsp; --invoke-function-service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --cron-expression '* * * * ? *' <br />Cron-выражение * * * * ? * означает вызов функции function-for-url-from-mq один раз в минуту. Подробнее про cron-выражения можно прочитать в документации.<br />Теперь у нас есть функция, которая раз в минуту будет пробовать взять из очереди URL и проверить его. Также есть метод REST API, который позволяет записывать URL в очередь независимо от работы обработчика. Мы можем вызывать созданный метод как угодно часто. Очередь будет просто накапливаться, а затем обработчик будет постепенно её разбирать.<br />В итоге вы получили асинхронную систему проверки доступности URL с доступом по REST API. Вы не создали ни одной виртуальной машины, но решили вопросы масштабирования и отказоустойчивости системы.<br />Удаление триггера-таймера<br />По завершении практической работы не забудьте удалить созданный вами триггер trigger-for-mq, иначе он будет работать, пока не исчерпает деньги на аккаунте:<br />yc serverless trigger delete trigger-for-mq <br />Не забудьте удалить или остановить все созданные вами ресурсы: триггеры, очереди YMQ и кластер базы данных.<br /><strong>Decision:</strong><br />$ yc iam access-key create --service-account-name service-account-for-cf<br />$ echo "export VERBOSE_LOG=True" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export AWS_ACCESS_KEY_ID=&lt;AWS_ACCESS_KEY_ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export AWS_SECRET_ACCESS_KEY=&lt;AWS_SECRET_ACCESS_KEY&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export QUEUE_URL=&lt;QUEUE_URL&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ vim my-url-receiver-function.py<br />$ cat my-url-receiver-function.py<br />import logging<br />import os<br />import boto3<br />logger = logging.getLogger()<br />logger.setLevel(logging.INFO)<br />verboseLogging = eval(os.environ['VERBOSE_LOG'])&nbsp; ## Convert to bool<br />queue_url = os.environ['QUEUE_URL']<br />def log(logString):<br />&nbsp;&nbsp;&nbsp; if verboseLogging:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.info(logString)<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; # Get url<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; url = event['queryStringParameters']['url']<br />&nbsp;&nbsp;&nbsp; except Exception as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error(error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusCode = 400<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; # Create client<br />&nbsp;&nbsp;&nbsp; client = boto3.client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='sqs',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://message-queue.api.cloud.yandex.net',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; region_name='ru-central1'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; # Send message to queue<br />&nbsp;&nbsp;&nbsp; client.send_message(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QueueUrl=queue_url,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBody=url<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; log('Successfully sent test message to queue')<br />&nbsp;&nbsp;&nbsp; statusCode = 200<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode<br />&nbsp;&nbsp;&nbsp; }<br />$ touch requirements.txt<br />$ pipreqs $PWD --force<br />$ zip my-url-receiver-function my-url-receiver-function.py requirements.txt<br />$ yc serverless function create \<br />&nbsp;&nbsp;&nbsp; --name&nbsp; my-url-receiver-function \<br />&nbsp;&nbsp;&nbsp; --description "function for url"<br />$ yc serverless function version create \<br />&nbsp;&nbsp;&nbsp; --function-name=my-url-receiver-function \<br />&nbsp;&nbsp;&nbsp; --memory=256m \<br />&nbsp;&nbsp;&nbsp; --execution-timeout=5s \<br />&nbsp;&nbsp;&nbsp; --runtime=python37 \<br />&nbsp;&nbsp;&nbsp; --entrypoint=my-url-receiver-function.handler \<br />&nbsp;&nbsp;&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp;&nbsp;&nbsp; --environment VERBOSE_LOG=$VERBOSE_LOG \<br />&nbsp;&nbsp;&nbsp; --environment AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \<br />&nbsp;&nbsp;&nbsp; --environment AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \<br />&nbsp;&nbsp;&nbsp; --environment QUEUE_URL=$QUEUE_URL \<br />&nbsp;&nbsp;&nbsp; --source-path my-url-receiver-function.zip<br />$ yc serverless api-gateway get-spec \<br />&nbsp;&nbsp;&nbsp; --name hello-world &gt;&gt; hello-world-new.yaml<br />$ vim hello-world-new.yaml <br />$ cat hello-world-new.yaml <br />openapi: "3.0.0"<br />info:<br />&nbsp; version: 1.0.0<br />&nbsp; title: Test API<br />paths:<br />&nbsp; /hello:<br />&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; summary: Say hello<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: hello<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameters:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: user<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in: query<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; description: User name to appear in greetings<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; required: false<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schema:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: string<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: 'world'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; responses:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '200':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; description: Greeting<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'text/plain':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schema:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: "string"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: dummy<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http_code: 200<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http_headers:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Content-Type': "text/plain"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'text/plain': "Hello, {user}!\n"<br />&nbsp;&nbsp;&nbsp; /check:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: cloud-functions<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function_id: &lt;идентификатор функции&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_account_id: &lt;идентификатор сервисного аккаунта&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: add-url<br />$ yc serverless api-gateway update \<br />&nbsp; --name hello-world \<br />&nbsp; --spec=hello-world-new.yaml<br />$ echo "export CONNECTION_ID=&lt;CONNECTION_ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export DB_USER=&lt;DB_USER&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo "export DB_HOST=&lt;DB_HOST&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ vim function-for-url-from-mq.py<br />$ cat function-for-url-from-mq.py<br />import logging<br />import os<br />import boto3<br />import datetime<br />import requests<br />#Эти библиотеки нужны для работы с PostgreSQL<br />import psycopg2<br />import psycopg2.errors<br />import psycopg2.extras<br />CONNECTION_ID = os.getenv("CONNECTION_ID")<br />DB_USER = os.getenv("DB_USER")<br />DB_HOST = os.getenv("DB_HOST")<br />QUEUE_URL = os.environ['QUEUE_URL']<br /># Настраиваем функцию для записи информации в журнал функции<br /># Получаем стандартный логер языка Python<br />logger = logging.getLogger()<br />logger.setLevel(logging.INFO)<br /># Вычитываем переменную VERBOSE_LOG, которую мы указываем в переменных окружения <br />verboseLogging = eval(os.environ['VERBOSE_LOG'])&nbsp; ## Convert to bool<br />#Функция log, которая запишет текст в журнал выполнения функции, если в переменной окружения VERBOSE_LOG будет значение True<br />def log(logString):<br />&nbsp;&nbsp;&nbsp; if verboseLogging:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.info(logString)<br />#Получаем подключение<br />def getConnString(context):<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; Extract env variables to connect to DB and return a db string<br />&nbsp;&nbsp;&nbsp; Raise an error if the env variables are not set<br />&nbsp;&nbsp;&nbsp; :return: string<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; connection = psycopg2.connect(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; database=CONNECTION_ID, # Идентификатор подключения<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user=DB_USER, # Пользователь БД<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; password=context.token["access_token"],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host=DB_HOST, # Точка входа<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port=6432,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sslmode="require")<br />&nbsp;&nbsp;&nbsp; return connection<br />"""<br />&nbsp;&nbsp;&nbsp; Create SQL query with table creation<br />"""<br />def makeCreateDataTableQuery(table_name):<br />&nbsp;&nbsp;&nbsp; query = f"""CREATE TABLE public.{table_name} (<br />&nbsp;&nbsp;&nbsp; url text,<br />&nbsp;&nbsp;&nbsp; result integer,<br />&nbsp;&nbsp;&nbsp; time float<br />&nbsp;&nbsp;&nbsp; )"""<br />&nbsp;&nbsp;&nbsp; return query<br />def makeInsertDataQuery(table_name, url, result, time):<br />&nbsp;&nbsp;&nbsp; query = f"""INSERT INTO {table_name} <br />&nbsp;&nbsp;&nbsp; (url, result,time)<br />&nbsp;&nbsp;&nbsp; VALUES('{url}', {result}, {time})<br />&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; return query<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; # Create client<br />&nbsp;&nbsp;&nbsp; client = boto3.client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='sqs',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://message-queue.api.cloud.yandex.net',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; region_name='ru-central1'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; # Receive sent message<br />&nbsp;&nbsp;&nbsp; messages = client.receive_message(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QueueUrl=QUEUE_URL,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MaxNumberOfMessages=1,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VisibilityTimeout=60,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WaitTimeSeconds=1<br />&nbsp;&nbsp;&nbsp; ).get('Messages')<br />&nbsp;&nbsp;&nbsp; if messages is None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': 200<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; for msg in messages:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log('Received message: "{}"'.format(msg.get('Body')))<br />&nbsp;&nbsp;&nbsp; # Get url from message<br />&nbsp;&nbsp;&nbsp; url = msg.get('Body');<br />&nbsp;&nbsp;&nbsp; # Check url<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now = datetime.datetime.now()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = requests.get(url, timeout=(1.0000, 3.0000))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timediff = datetime.datetime.now() - now<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = response.status_code<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.ReadTimeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 601<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.ConnectTimeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 602<br />&nbsp;&nbsp;&nbsp; except requests.exceptions.Timeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 603<br />&nbsp;&nbsp;&nbsp; log(f'Result: {result} Time: {timediff.total_seconds()}')<br />&nbsp;&nbsp;&nbsp; connection = getConnString(context)<br />&nbsp;&nbsp;&nbsp; log(f'Connecting: {connection}')&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; cursor = connection.cursor()<br />&nbsp;&nbsp;&nbsp; table_name = 'custom_request_result'<br />&nbsp;&nbsp;&nbsp; sql = makeInsertDataQuery(table_name, url, result, timediff.total_seconds())<br />&nbsp;&nbsp;&nbsp; log(f'Exec: {sql}')<br />&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(sql)<br />&nbsp;&nbsp;&nbsp; except psycopg2.errors.UndefinedTable as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log(f'Table not exist - create and repeate insert')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection.rollback()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error(error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; createTable = makeCreateDataTableQuery(table_name)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log(f'Exec: {createTable}')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(createTable)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection.commit()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log(f'Exec: {sql}')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(sql)<br />&nbsp;&nbsp;&nbsp; except Exception as error:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.error( error)<br />&nbsp;&nbsp;&nbsp; connection.commit()<br />&nbsp;&nbsp;&nbsp; cursor.close()<br />&nbsp;&nbsp;&nbsp; connection.close()<br />&nbsp;&nbsp;&nbsp; # Delete processed messages<br />&nbsp;&nbsp;&nbsp; for msg in messages:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; client.delete_message(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QueueUrl=QUEUE_URL,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReceiptHandle=msg.get('ReceiptHandle')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('Successfully deleted message by receipt handle "{}"'.format(msg.get('ReceiptHandle')))<br />&nbsp;&nbsp;&nbsp; statusCode = 200<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode<br />&nbsp;&nbsp;&nbsp; }<br />$ zip function-for-url-from-mq function-for-url-from-mq.py requirements.txt<br />$ yc serverless function create \<br />&nbsp; --name function-for-url-from-mq \<br />&nbsp; --description "function for url from mq"<br />$ yc serverless function version create \<br />&nbsp; --function-name=function-for-url-from-mq \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=function-for-url-from-mq.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --environment VERBOSE_LOG=True \<br />&nbsp; --environment CONNECTION_ID=$CONNECTION_ID \<br />&nbsp; --environment DB_USER=$DB_USER \<br />&nbsp; --environment DB_HOST=$DB_HOST \<br />&nbsp; --environment AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \<br />&nbsp; --environment AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \<br />&nbsp; --environment QUEUE_URL=$QUEUE_URL \<br />&nbsp; --source-path function-for-url-from-mq.zip<br />$ yc serverless trigger create timer \<br />&nbsp; --name trigger-for-mq \<br />&nbsp; --invoke-function-name function-for-url-from-mq \<br />&nbsp; --invoke-function-service-account-id $SERVICE_ACCOUNT_ID \<br />&nbsp; --cron-expression '* * * * ? *'<br />$ yc serverless trigger delete trigger-for-mq<br /><strong>Task:</strong><br />Однократная отправка сообщений<br />В этой практической работе мы реализуем проект, который позволит пользователям конвертировать видеофайлы в GIF. <br />Такая задача хорошо подходит для Cloud Functions, потому что конвертирование отнимает немало ресурсов процессора, и чем качественнее видео, тем больше ресурсов требуется на его обработку.<br />Почему для решения этой задачи нужны очереди?<br />Представим, что мы попытались решить эту задачу &laquo;в лоб&raquo;. Пользователь заходит на страницу и вводит ссылку на видеофайл. Сервис скачивает его, конвертирует и отдает ссылку на GIF. Возникают две серьёзные проблемы:<br />Синхронное соединение не всегда стабильно. Чем дольше вы его держите, тем выше вероятность, что оно разорвётся. В этом случае всё придётся сделать заново. А если соединение нестабильно, то пользователь может и не дождаться результата.<br />Задача ресурсоёмкая: если сервисом одновременно воспользуются много пользователей с большими видеороликами, мощностей может не хватить.<br />Чтобы избежать этих проблем, в архитектуру сервиса необходимо встроить очередь.<br /><strong>Decision:</strong><br />Шаг 1. Сервисный аккаунт и Lockbox<br />Создание сервисного аккаунта<br />Создайте сервисный аккаунт с именем ffmpeg-account-for-cf:<br />export SERVICE_ACCOUNT=$(yc iam service-account create --name ffmpeg-account-for-cf \<br />&nbsp; --description "service account for serverless" \<br />&nbsp; --format json | jq -r .) <br />Проверьте текущий список сервисных аккаунтов:<br />yc iam service-account list <br />После проверки запишите ID созданного сервисного аккаунта в переменную SERVICE_ACCOUNT_ID:<br />echo "export SERVICE_ACCOUNT_FFMPEG_ID=&lt;ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $SERVICE_ACCOUNT_FFMPEG_ID <br />Назначение роли сервисному аккаунту<br />Добавим вновь созданному сервисному аккаунту роли storage.viewer, storage.uploader, ymq.reader, ymq.writer, ydb.admin, serverless.functions.invoker, и lockbox.payloadViewer:<br />echo "export FOLDER_ID=$(yc config get folder-id)" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $FOLDER_ID<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role storage.viewer<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role storage.uploader<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role ymq.reader<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role ymq.writer<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role ydb.admin<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role serverless.functions.invoker<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role lockbox.payloadViewer<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role editor <br />Вы можете назначить несколько ролей и с помощью команды set-access-binding. Но эта команда полностью перезаписывает права доступа к ресурсу и все текущие роли на него будут удалены! Поэтому сначала убедитесь, что ресурсу не назначены роли, которые вы не хотите потерять:<br />yc resource-manager folder list-access-bindings $FOLDER_ID<br />yc resource-manager folder set-access-bindings $FOLDER_ID \<br />&nbsp; --access-binding role=storage.viewer,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=storage.uploader,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=ymq.reader,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=ymq.writer,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=ydb.admin,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=serverless.functions.invoker,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=lockbox.payloadViewer,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=editor,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID <br />Создание ключа доступа для сервисного аккаунта<br />Этот этап нужен для получения идентификатора ключа доступа и секретного ключа, которые будут использованы для загрузки файлов в Object Storage, работы с Yandex Message Queue и т. д. Для создания ключа доступа необходимо вызвать следующую команду:<br />yc iam access-key create --service-account-name ffmpeg-account-for-cf <br />В результате вы получите примерно следующее:<br />&nbsp;&nbsp;&nbsp; access_key:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id: ajefraollq5puj2tir1o<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_account_id: ajetdv28pl0a1a8r41f0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; created_at: "2021-08-23T21:13:05.677319393Z"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key_id: BTPNvWthv0ZX2xVmlPIU<br />&nbsp;&nbsp;&nbsp; secret: cWLQ0HrTM0k_qAac43cwMNJA8VV_rfTg_kd4xVPi <br />Здесь key_id &mdash; это идентификатор ключа доступа ACCESS_KEY_ID. А secret &mdash; это секретный ключ SECRET_ACCESS_KEY. Переменные ACCESS_KEY_ID и SECRET_ACCESS_KEY могут быть использованы для задания соответствующих значений aws_access_key_id и aws_secret_access_key при использовании библиотеки boto3.<br />Создание элемента в сервисе Lockbox<br />В сервисе Lockbox (находится на стадии Preview) создайте ваш первый секрет, состоящий из набора версий, в которых хранятся ваши данные. Версия содержит наборы ключей и значений:<br />&nbsp;&nbsp;&nbsp; Ключ &mdash; несекретное название для значения, по которому вы будете его идентифицировать.<br />&nbsp;&nbsp;&nbsp; Значение &mdash; это секретные данные.<br />Версия не изменяется. Для любого изменения количества пар ключей-значений или их содержимого необходимо создать новую версию. Создадим секрет с именем ffmpeg-sa-key и парой ключей ACCESS_KEY_ID и SECRET_ACCESS_KEY:<br />yc lockbox secret create --name ffmpeg-sa-key \<br />&nbsp; --folder-id $FOLDER_ID \<br />&nbsp; --description "keys for serverless" \<br />&nbsp; --payload '[{"key": "ACCESS_KEY_ID", "text_value": &lt;ACCESS_KEY_ID&gt;}, {"key": "SECRET_ACCESS_KEY", "text_value": "&lt;SECRET_ACCESS_KEY&gt;"}]' <br />Получим и запишем значение SECRET_ID, оно нам потребуется при создании функции:<br />yc lockbox secret list<br />yc lockbox secret get --name ffmpeg-sa-key<br />echo "export SECRET_ID=&lt;SECRET_ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $SECRET_ID <br />Шаг 2. Создание очереди Yandex Message Queue<br />Для создания очереди Yandex Message Queue вы можете использовать три разных способа:<br />&nbsp;&nbsp;&nbsp; консоль управления;<br />&nbsp;&nbsp;&nbsp; консольная утилита aws;<br />&nbsp;&nbsp;&nbsp; Terraform.<br />Создание очереди с помощью утилиты aws<br />Воспользуемся AWS CLI. Для начала задайте конфигурацию с помощью команды aws configure. При этом от вас потребуется ввести:<br />&nbsp;&nbsp;&nbsp; AWS Access Key ID &mdash; идентификатор ключа доступа key_id сервисного аккаунта, полученный на предыдущем шаге.<br />&nbsp;&nbsp;&nbsp; AWS Secret Access Key &mdash; секретный ключ secret сервисного аккаунта, полученный на предыдущем шаге.<br />&nbsp;&nbsp;&nbsp; Default region name &mdash; используйте значение ru-central1.<br />По завершению конфигурации вы сможете создать очередь:<br />aws configure<br />aws sqs create-queue --queue-name ffmpeg --endpoint https://message-queue.api.cloud.yandex.net/ <br />В результате успешного выполнения предыдущей команды в ответ вы получите URL:<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "QueueUrl": "https://message-queue.api.cloud.yandex.net/b1ga4gj7agij03ln6aov/dj6000000003kv2t02b3/ffmpeg"<br />&nbsp;&nbsp;&nbsp; } <br />Запишем значения URL в переменную YMQ_QUEUE_URL. Она потребуется нам при создании функции:<br />echo "export YMQ_QUEUE_URL=&lt;YMQ_QUEUE_URL&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $YMQ_QUEUE_URL <br />Ещё вам потребует значение атрибута QueueArn, получим его:<br />aws sqs get-queue-attributes \<br />&nbsp; --endpoint https://message-queue.api.cloud.yandex.net \<br />&nbsp; --queue-url $YMQ_QUEUE_URL \<br />&nbsp; --attribute-names QueueArn <br />В результате вы получите ответ вида:<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Attributes": {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "QueueArn": "yrn:yc:ymq:ru-central1:b1gl21bkgss4msekt08i:ffmpeg"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; } <br />Сохраним значение QueueArn в переменную YMQ_QUEUE_ARN:<br />echo "export YMQ_QUEUE_ARN=&lt;YMQ_QUEUE_ARN&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $YMQ_QUEUE_ARN <br />Шаг 3. Создание базы данных в сервисе Yandex Database<br />Создадим базу данных YDB с именем ffmpeg и типом serverless, используя для этого флаг --serverless:<br />yc ydb database create ffmpeg \<br />&nbsp; --serverless \<br />&nbsp; --folder-id $FOLDER_ID<br />yc ydb database list <br />Сразу получим и сохраним document_api_endpoint в значение переменной DOCAPI_ENDPOINT:<br />yc ydb database get --name ffmpeg<br />echo "export DOCAPI_ENDPOINT=&lt;DOCAPI_ENDPOINT&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $DOCAPI_ENDPOINT <br />Как только база данных создана, воспользуемся ранее использованной утилитой AWS CLI для создания документной таблицы в этой базе данных. Всю конфигурацию возьмем из файла tasks.json:<br />{<br />&nbsp; "AttributeDefinitions": [<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "AttributeName": "task_id",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "AttributeType": "S"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; ],<br />&nbsp; "KeySchema": [<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "AttributeName": "task_id",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "KeyType": "HASH"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; ],<br />&nbsp; "TableName": "tasks"<br />} <br />Находясь в одном каталоге с файлом tasks.json, вызовите следующую команду для создания таблицы:<br />aws dynamodb create-table \<br />&nbsp; --cli-input-json file://tasks.json \<br />&nbsp; --endpoint-url $DOCAPI_ENDPOINT \<br />&nbsp; --region ru-central1 <br />В консоли управления убедитесь, что БД ffmpeg создана, и в ней есть пустая таблица tasks.<br />Шаг 4. Создание бакета в сервисе Object Storage<br />Самый простой способ создания бакета в Object Storage &mdash; это использование консоли управления.<br />В консоли управления в вашем рабочем каталоге выберите сервис Object Storage. Нажмите кнопку Создать бакет. На странице создания бакета введите имя, в нашем примере это будет storage-for-ffmpeg, остальные параметры не меняйте.<br />Нажмите кнопку Создать бакет для завершения операции. Далее вы всегда сможете поменять класс хранилища, его размер и настройки доступа.<br />Сохраним название бакета для дальнейшего использования:<br />echo "export S3_BUCKET=&lt;имя бакета&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $S3_BUCKET <br />Шаг 5. Создание функций<br />При создании функций нам потребуется ряд переменных:<br />&nbsp;&nbsp;&nbsp; SECRET_ID &mdash; идентификатор секрета (можно получить из таблицы со списком секретов);<br />&nbsp;&nbsp;&nbsp; YMQ_QUEUE_URL &mdash; URL очереди (можно получить на странице обзора);<br />&nbsp;&nbsp;&nbsp; DOCAPI_ENDPOINT &mdash; его можно получить на странице обзора БД, нужен именно Document API;<br />&nbsp;&nbsp;&nbsp; S3_BUCKET &mdash; имя бакета, в нашем случае это storage-for-ffmpeg.<br />Проверим заданные ранее переменные:<br />echo $SERVICE_ACCOUNT_FFMPEG_ID<br />echo $SECRET_ID<br />echo $YMQ_QUEUE_URL<br />echo $DOCAPI_ENDPOINT<br />echo $S3_BUCKET <br />Для обработки видео нам потребуется утилита FFmpeg. Скачайте статический релизный бинарный файл для Linux amd64 на сайте ffmpeg.org. Обычно он находится в разделе FFmpeg Static Builds и называется примерно так: ffmpeg-release-amd64-static.tar.xz. Распакуйте архив. Из него вам понадобится только файл ffmpeg. Поскольку есть ограничение на размер&nbsp; файла, который можно приложить через консоль, загрузим код функций и ffmpeg в Object Storage.<br />Исходный код в файле index.py содержит обе необходимые нам функции:<br />import json<br />import os<br />import subprocess<br />import uuid<br />from urllib.parse import urlencode<br />import boto3<br />import requests<br />import yandexcloud<br />from yandex.cloud.lockbox.v1.payload_service_pb2 import GetPayloadRequest<br />from yandex.cloud.lockbox.v1.payload_service_pb2_grpc import PayloadServiceStub<br />boto_session = None<br />storage_client = None<br />docapi_table = None<br />ymq_queue = None<br />def get_boto_session():<br />&nbsp;&nbsp;&nbsp; global boto_session<br />&nbsp;&nbsp;&nbsp; if boto_session is not None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return boto_session<br />&nbsp;&nbsp;&nbsp; # initialize lockbox and read secret value<br />&nbsp;&nbsp;&nbsp; yc_sdk = yandexcloud.SDK()<br />&nbsp;&nbsp;&nbsp; channel = yc_sdk._channels.channel("lockbox-payload")<br />&nbsp;&nbsp;&nbsp; lockbox = PayloadServiceStub(channel)<br />&nbsp;&nbsp;&nbsp; response = lockbox.Get(GetPayloadRequest(secret_id=os.environ['SECRET_ID']))<br />&nbsp;&nbsp;&nbsp; # extract values from secret<br />&nbsp;&nbsp;&nbsp; access_key = None<br />&nbsp;&nbsp;&nbsp; secret_key = None<br />&nbsp;&nbsp;&nbsp; for entry in response.entries:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if entry.key == 'ACCESS_KEY_ID':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_key = entry.text_value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif entry.key == 'SECRET_ACCESS_KEY':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secret_key = entry.text_value<br />&nbsp;&nbsp;&nbsp; if access_key is None or secret_key is None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise Exception("secrets required")<br />&nbsp;&nbsp;&nbsp; print("Key id: " + access_key)<br />&nbsp;&nbsp;&nbsp; # initialize boto session<br />&nbsp;&nbsp;&nbsp; boto_session = boto3.session.Session(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_access_key_id=access_key,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_secret_access_key=secret_key<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return boto_session<br />def get_ymq_queue():<br />&nbsp;&nbsp;&nbsp; global ymq_queue<br />&nbsp;&nbsp;&nbsp; if ymq_queue is not None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ymq_queue<br />&nbsp;&nbsp;&nbsp; ymq_queue = get_boto_session().resource(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='sqs',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://message-queue.api.cloud.yandex.net',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; region_name='ru-central1'<br />&nbsp;&nbsp;&nbsp; ).Queue(os.environ['YMQ_QUEUE_URL'])<br />&nbsp;&nbsp;&nbsp; return ymq_queue<br />def get_docapi_table():<br />&nbsp;&nbsp;&nbsp; global docapi_table<br />&nbsp;&nbsp;&nbsp; if docapi_table is not None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return docapi_table<br />&nbsp;&nbsp;&nbsp; docapi_table = get_boto_session().resource(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'dynamodb',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url=os.environ['DOCAPI_ENDPOINT'],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; region_name='ru-central1'<br />&nbsp;&nbsp;&nbsp; ).Table('tasks')<br />&nbsp;&nbsp;&nbsp; return docapi_table<br />def get_storage_client():<br />&nbsp;&nbsp;&nbsp; global storage_client<br />&nbsp;&nbsp;&nbsp; if storage_client is not None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return storage_client<br />&nbsp;&nbsp;&nbsp; storage_client = get_boto_session().client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='s3',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://storage.yandexcloud.net',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; region_name='ru-central1'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return storage_client<br /># API handler<br />def create_task(src_url):<br />&nbsp;&nbsp;&nbsp; task_id = str(uuid.uuid4())<br />&nbsp;&nbsp;&nbsp; get_docapi_table().put_item(Item={<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'task_id': task_id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ready': False<br />&nbsp;&nbsp;&nbsp; })<br />&nbsp;&nbsp;&nbsp; get_ymq_queue().send_message(MessageBody=json.dumps({'task_id': task_id, "src": src_url}))<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'task_id': task_id<br />&nbsp;&nbsp;&nbsp; }<br />def get_task_status(task_id):<br />&nbsp;&nbsp;&nbsp; task = get_docapi_table().get_item(Key={<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "task_id": task_id<br />&nbsp;&nbsp;&nbsp; })<br />&nbsp;&nbsp;&nbsp; if task['Item']['ready']:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ready': True,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'gif_url': task['Item']['gif_url']<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return {'ready': False}<br />def handle_api(event, context):<br />&nbsp;&nbsp;&nbsp; action = event['action']<br />&nbsp;&nbsp;&nbsp; if action == 'convert':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return create_task(event['src_url'])<br />&nbsp;&nbsp;&nbsp; elif action == 'get_task_status':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return get_task_status(event['task_id'])<br />&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {"error": "unknown action: " + action}<br /># Converter handler<br />def download_from_ya_disk(public_key, dst):<br />&nbsp;&nbsp;&nbsp; api_call_url = 'https://cloud-api.yandex.net/v1/disk/public/resources/download?' + \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; urlencode(dict(public_key=public_key))<br />&nbsp;&nbsp;&nbsp; response = requests.get(api_call_url)<br />&nbsp;&nbsp;&nbsp; download_url = response.json()['href']<br />&nbsp;&nbsp;&nbsp; download_response = requests.get(download_url)<br />&nbsp;&nbsp;&nbsp; with open(dst, 'wb') as video_file:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; video_file.write(download_response.content)<br />def upload_and_presign(file_path, object_name):<br />&nbsp;&nbsp;&nbsp; client = get_storage_client()<br />&nbsp;&nbsp;&nbsp; bucket = os.environ['S3_BUCKET']<br />&nbsp;&nbsp;&nbsp; client.upload_file(file_path, bucket, object_name)<br />&nbsp;&nbsp;&nbsp; return client.generate_presigned_url('get_object', Params={'Bucket': bucket, 'Key': object_name}, ExpiresIn=3600)<br />def handle_process_event(event, context):<br />&nbsp;&nbsp;&nbsp; for message in event['messages']:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; task_json = json.loads(message['details']['message']['body'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; task_id = task_json['task_id']<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Download video<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; download_from_ya_disk(task_json['src'], '/tmp/video.mp4')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Convert with ffmpeg<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subprocess.run(['ffmpeg', '-i', '/tmp/video.mp4', '-r', '10', '-s', '320x240', '/tmp/result.gif'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result_object = task_id + ".gif"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Upload to Object Storage and generate presigned url<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result_download_url = upload_and_presign('/tmp/result.gif', result_object)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Update task status in DocAPI<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_docapi_table().update_item(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key={'task_id': task_id},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AttributeUpdates={<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ready': {'Value': True, 'Action': 'PUT'},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'gif_url': {'Value': result_download_url, 'Action': 'PUT'},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return "OK" <br />Сгенерируйте файл requirements.txt:<br />pipreqs $PWD --force <br />Находясь в директории с исходными файлами, упакуем все нужные файлы в ZIP-архив.<br />zip src.zip index.py requirements.txt ffmpeg <br />В Object Storage для простоты используем тот же бакет, куда далее будем складывать видео. На вкладке Объекты, вверху справа нажмите кнопку Загрузить и выберите созданный архив.<br />Создадим функции ffmpeg-api и ffmpeg-converter, при этом сразу зададим все необходимые переменные и сервисный аккаунт:<br />yc serverless function create \<br />&nbsp; --name ffmpeg-api \<br />&nbsp; --description "function for ffmpeg-api"<br />yc serverless function create \<br />&nbsp; --name ffmpeg-converter \<br />&nbsp; --description "function for ffmpeg-converter"<br />yc serverless function version create \<br />&nbsp; --function-name ffmpeg-api \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=index.handle_api \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --environment SECRET_ID=$SECRET_ID \<br />&nbsp; --environment YMQ_QUEUE_URL=$YMQ_QUEUE_URL \<br />&nbsp; --environment DOCAPI_ENDPOINT=$DOCAPI_ENDPOINT \<br />&nbsp; --package-bucket-name $S3_BUCKET \<br />&nbsp; --package-object-name src.zip<br />yc serverless function version create \<br />&nbsp; --function-name ffmpeg-converter \<br />&nbsp; --memory=2048m \<br />&nbsp; --execution-timeout=600s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=index.handle_process_event \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --environment SECRET_ID=$SECRET_ID \<br />&nbsp; --environment YMQ_QUEUE_URL=$YMQ_QUEUE_URL \<br />&nbsp; --environment DOCAPI_ENDPOINT=$DOCAPI_ENDPOINT \<br />&nbsp; --environment S3_BUCKET=$S3_BUCKET \<br />&nbsp; --package-bucket-name $S3_BUCKET \<br />&nbsp; --package-object-name src.zip <br />Тестирование функции<br />В консоли управления перейдите из рабочего каталога в раздел Cloud Functions и выберите ранее созданную функцию ffmpeg-api. Перейдите на вкладку Тестирование в боковом меню, выберите шаблон данных Без шаблона и добавьте во вводные данные JSON:<br />{"action":"convert", "src_url":"https://disk.yandex.ru/i/38RbVC0spb_jQQ"} <br />Нажмите кнопку Запустить тест. Этим самым мы загрузим файл в хранилище и создадим задачу в БД. Если всё сделано правильно, то вы увидите такой результат:<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "task_id": "133e05c2-1b98-41cc-9aab-b816d71af343"<br />&nbsp;&nbsp;&nbsp; } <br />Воспользуемся полученным идентификатором задачи task_id для получения статуса из базы данных. Для этого внесите в вводные данные JSON следующие изменения:<br />{"action":"get_task_status", "task_id":"&lt;идентификатор задачи&gt;"} <br />Нажмите кнопку Запустить тест. Так как мы ещё не обрабатывали задачи в очереди, результат очевиден:<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ready": false<br />&nbsp;&nbsp;&nbsp; } <br />Шаг 6. Создание триггера<br />Теперь создайте триггер, который будет вызывать функцию обработки сообщений из очереди. После создания триггер начинает работать через пять минут. Он будет брать по одному сообщению и раз в 10 секунд отправлять в функцию:<br />yc serverless trigger create message-queue \<br />&nbsp; --name ffmpeg \<br />&nbsp; --queue $YMQ_QUEUE_ARN \<br />&nbsp; --queue-service-account-id $SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --invoke-function-name ffmpeg-converter&nbsp; \<br />&nbsp; --invoke-function-service-account-id $SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --batch-size 1 \<br />&nbsp; --batch-cutoff 10s <br />С этого момента очередь начнёт обрабатываться. Можно проверить, готова ли задача, и, если это так, запросить по URL результат обработки из Object Storage.<br />Теперь у нас есть функция, которая выполняет функцию API, через которую мы можем ставить задачи в очередь на исполнение. Триггер раз в 10 секунд берет по одному сообщению в очереди и передает функции обработчику. Функция-обработчик формирует результат и обновляет данные в базе данных. При этом мы получаем сконвертированные GIF-файлы из видео.<br />Протестируйте систему, используя полученный ранее идентификатор задачи task_id для получения статуса из базы данных. Для этого внесите изменения в вводные данные JSON:<br />{"action":"get_task_status", "task_id":"133e05c2-1b98-41cc-9aab-b816d71af343"} <br />Нажмите кнопку Запустить тест. Если задача уже успела обработаться, то вы получите URL.<br />Удаление триггера<br />По завершении работы не забудьте удалить созданный триггер ffmpeg, иначе он будет продолжать работать:<br />yc serverless trigger delete ffmpeg <br /><strong>Decision:</strong><br />$ export SERVICE_ACCOUNT=$(yc iam service-account create --name ffmpeg-account-for-cf \<br />&nbsp; --description "service account for serverless" \<br />&nbsp; --format json | jq -r .)<br />$ yc iam service-account list<br />$ echo "export SERVICE_ACCOUNT_FFMPEG_ID=&lt;ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $SERVICE_ACCOUNT_FFMPEG_ID<br />$ echo "export FOLDER_ID=$(yc config get folder-id)" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $FOLDER_ID<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role storage.viewer<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role storage.uploader<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role ymq.reader<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role ymq.writer<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role ydb.admin<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role serverless.functions.invoker<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role lockbox.payloadViewer<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --role editor<br />$ yc resource-manager folder list-access-bindings $FOLDER_ID<br />$ yc resource-manager folder set-access-bindings $FOLDER_ID \<br />&nbsp; --access-binding role=storage.viewer,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=storage.uploader,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=ymq.reader,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=ymq.writer,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=ydb.admin,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=serverless.functions.invoker,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=lockbox.payloadViewer,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --access-binding role=editor,subject=serviceAccount:$SERVICE_ACCOUNT_FFMPEG_ID<br />$ yc iam access-key create --service-account-name ffmpeg-account-for-cf<br />$ yc lockbox secret create --name ffmpeg-sa-key \<br />&nbsp; --folder-id $FOLDER_ID \<br />&nbsp; --description "keys for serverless" \<br />&nbsp; --payload '[{"key": "ACCESS_KEY_ID", "text_value": &lt;ACCESS_KEY_ID&gt;}, {"key": "SECRET_ACCESS_KEY", "text_value": "&lt;SECRET_ACCESS_KEY&gt;"}]'<br />$ yc lockbox secret list<br />$ yc lockbox secret get --name ffmpeg-sa-key<br />$ echo "export SECRET_ID=&lt;SECRET_ID&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $SECRET_ID<br />$ aws configure<br />$ aws sqs create-queue --queue-name ffmpeg --endpoint https://message-queue.api.cloud.yandex.net/<br />$ echo "export YMQ_QUEUE_URL=&lt;YMQ_QUEUE_URL&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $YMQ_QUEUE_URL<br />$ aws sqs get-queue-attributes \<br />&nbsp; --endpoint https://message-queue.api.cloud.yandex.net \<br />&nbsp; --queue-url $YMQ_QUEUE_URL \<br />&nbsp; --attribute-names QueueArn<br />$ echo "export YMQ_QUEUE_ARN=&lt;YMQ_QUEUE_ARN&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $YMQ_QUEUE_ARN<br />$ yc ydb database create ffmpeg \<br />&nbsp; --serverless \<br />&nbsp; --folder-id $FOLDER_ID<br />$ yc ydb database list<br />$ yc ydb database get --name ffmpeg<br />$ echo "export DOCAPI_ENDPOINT=&lt;DOCAPI_ENDPOINT&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $DOCAPI_ENDPOINT<br />$ vim tasks.json<br />$ cat tasks.json<br />{<br />&nbsp; "AttributeDefinitions": [<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "AttributeName": "task_id",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "AttributeType": "S"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; ],<br />&nbsp; "KeySchema": [<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "AttributeName": "task_id",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "KeyType": "HASH"<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; ],<br />&nbsp; "TableName": "tasks"<br />}<br />$ aws dynamodb create-table \<br />&nbsp; --cli-input-json file://tasks.json \<br />&nbsp; --endpoint-url $DOCAPI_ENDPOINT \<br />&nbsp; --region ru-central1<br />$ echo "export S3_BUCKET=&lt;имя бакета&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $S3_BUCKET<br />$ echo $SERVICE_ACCOUNT_FFMPEG_ID<br />$ echo $SECRET_ID<br />$ echo $YMQ_QUEUE_URL<br />$ echo $DOCAPI_ENDPOINT<br />$ echo $S3_BUCKET<br />$ sudo apt install ffmpeg<br />$ vim index.py<br />$ cat index.py<br />import json<br />import os<br />import subprocess<br />import uuid<br />from urllib.parse import urlencode<br />import boto3<br />import requests<br />import yandexcloud<br />from yandex.cloud.lockbox.v1.payload_service_pb2 import GetPayloadRequest<br />from yandex.cloud.lockbox.v1.payload_service_pb2_grpc import PayloadServiceStub<br />boto_session = None<br />storage_client = None<br />docapi_table = None<br />ymq_queue = None<br />def get_boto_session():<br />&nbsp;&nbsp;&nbsp; global boto_session<br />&nbsp;&nbsp;&nbsp; if boto_session is not None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return boto_session<br />&nbsp;&nbsp;&nbsp; # initialize lockbox and read secret value<br />&nbsp;&nbsp;&nbsp; yc_sdk = yandexcloud.SDK()<br />&nbsp;&nbsp;&nbsp; channel = yc_sdk._channels.channel("lockbox-payload")<br />&nbsp;&nbsp;&nbsp; lockbox = PayloadServiceStub(channel)<br />&nbsp;&nbsp;&nbsp; response = lockbox.Get(GetPayloadRequest(secret_id=os.environ['SECRET_ID']))<br />&nbsp;&nbsp;&nbsp; # extract values from secret<br />&nbsp;&nbsp;&nbsp; access_key = None<br />&nbsp;&nbsp;&nbsp; secret_key = None<br />&nbsp;&nbsp;&nbsp; for entry in response.entries:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if entry.key == 'ACCESS_KEY_ID':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_key = entry.text_value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif entry.key == 'SECRET_ACCESS_KEY':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secret_key = entry.text_value<br />&nbsp;&nbsp;&nbsp; if access_key is None or secret_key is None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise Exception("secrets required")<br />&nbsp;&nbsp;&nbsp; print("Key id: " + access_key)<br />&nbsp;&nbsp;&nbsp; # initialize boto session<br />&nbsp;&nbsp;&nbsp; boto_session = boto3.session.Session(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_access_key_id=access_key,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aws_secret_access_key=secret_key<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return boto_session<br />def get_ymq_queue():<br />&nbsp;&nbsp;&nbsp; global ymq_queue<br />&nbsp;&nbsp;&nbsp; if ymq_queue is not None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ymq_queue<br />&nbsp;&nbsp;&nbsp; ymq_queue = get_boto_session().resource(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='sqs',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://message-queue.api.cloud.yandex.net',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; region_name='ru-central1'<br />&nbsp;&nbsp;&nbsp; ).Queue(os.environ['YMQ_QUEUE_URL'])<br />&nbsp;&nbsp;&nbsp; return ymq_queue<br />def get_docapi_table():<br />&nbsp;&nbsp;&nbsp; global docapi_table<br />&nbsp;&nbsp;&nbsp; if docapi_table is not None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return docapi_table<br />&nbsp;&nbsp;&nbsp; docapi_table = get_boto_session().resource(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'dynamodb',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url=os.environ['DOCAPI_ENDPOINT'],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; region_name='ru-central1'<br />&nbsp;&nbsp;&nbsp; ).Table('tasks')<br />&nbsp;&nbsp;&nbsp; return docapi_table<br />def get_storage_client():<br />&nbsp;&nbsp;&nbsp; global storage_client<br />&nbsp;&nbsp;&nbsp; if storage_client is not None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return storage_client<br />&nbsp;&nbsp;&nbsp; storage_client = get_boto_session().client(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name='s3',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint_url='https://storage.yandexcloud.net',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; region_name='ru-central1'<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return storage_client<br /># API handler<br />def create_task(src_url):<br />&nbsp;&nbsp;&nbsp; task_id = str(uuid.uuid4())<br />&nbsp;&nbsp;&nbsp; get_docapi_table().put_item(Item={<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'task_id': task_id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ready': False<br />&nbsp;&nbsp;&nbsp; })<br />&nbsp;&nbsp;&nbsp; get_ymq_queue().send_message(MessageBody=json.dumps({'task_id': task_id, "src": src_url}))<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'task_id': task_id<br />&nbsp;&nbsp;&nbsp; }<br />def get_task_status(task_id):<br />&nbsp;&nbsp;&nbsp; task = get_docapi_table().get_item(Key={<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "task_id": task_id<br />&nbsp;&nbsp;&nbsp; })<br />&nbsp;&nbsp;&nbsp; if task['Item']['ready']:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ready': True,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'gif_url': task['Item']['gif_url']<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return {'ready': False}<br />def handle_api(event, context):<br />&nbsp;&nbsp;&nbsp; action = event['action']<br />&nbsp;&nbsp;&nbsp; if action == 'convert':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return create_task(event['src_url'])<br />&nbsp;&nbsp;&nbsp; elif action == 'get_task_status':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return get_task_status(event['task_id'])<br />&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {"error": "unknown action: " + action}<br /># Converter handler<br />def download_from_ya_disk(public_key, dst):<br />&nbsp;&nbsp;&nbsp; api_call_url = 'https://cloud-api.yandex.net/v1/disk/public/resources/download?' + \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; urlencode(dict(public_key=public_key))<br />&nbsp;&nbsp;&nbsp; response = requests.get(api_call_url)<br />&nbsp;&nbsp;&nbsp; download_url = response.json()['href']<br />&nbsp;&nbsp;&nbsp; download_response = requests.get(download_url)<br />&nbsp;&nbsp;&nbsp; with open(dst, 'wb') as video_file:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; video_file.write(download_response.content)<br />def upload_and_presign(file_path, object_name):<br />&nbsp;&nbsp;&nbsp; client = get_storage_client()<br />&nbsp;&nbsp;&nbsp; bucket = os.environ['S3_BUCKET']<br />&nbsp;&nbsp;&nbsp; client.upload_file(file_path, bucket, object_name)<br />&nbsp;&nbsp;&nbsp; return client.generate_presigned_url('get_object', Params={'Bucket': bucket, 'Key': object_name}, ExpiresIn=3600)<br />def handle_process_event(event, context):<br />&nbsp;&nbsp;&nbsp; for message in event['messages']:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; task_json = json.loads(message['details']['message']['body'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; task_id = task_json['task_id']<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Download video<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; download_from_ya_disk(task_json['src'], '/tmp/video.mp4')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Convert with ffmpeg<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subprocess.run(['ffmpeg', '-i', '/tmp/video.mp4', '-r', '10', '-s', '320x240', '/tmp/result.gif'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result_object = task_id + ".gif"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Upload to Object Storage and generate presigned url<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result_download_url = upload_and_presign('/tmp/result.gif', result_object)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Update task status in DocAPI<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_docapi_table().update_item(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key={'task_id': task_id},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AttributeUpdates={<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ready': {'Value': True, 'Action': 'PUT'},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'gif_url': {'Value': result_download_url, 'Action': 'PUT'},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; return "OK"<br />$ pipreqs $PWD --force<br />$ zip src.zip index.py requirements.txt ffmpeg<br />$ yc serverless function create \<br />&nbsp; --name ffmpeg-api \<br />&nbsp; --description "function for ffmpeg-api"<br />$ yc serverless function create \<br />&nbsp; --name ffmpeg-converter \<br />&nbsp; --description "function for ffmpeg-converter"<br />$ yc serverless function version create \<br />&nbsp; --function-name ffmpeg-api \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=index.handle_api \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --environment SECRET_ID=$SECRET_ID \<br />&nbsp; --environment YMQ_QUEUE_URL=$YMQ_QUEUE_URL \<br />&nbsp; --environment DOCAPI_ENDPOINT=$DOCAPI_ENDPOINT \<br />&nbsp; --package-bucket-name $S3_BUCKET \<br />&nbsp; --package-object-name src.zip<br />$ yc serverless function version create \<br />&nbsp; --function-name ffmpeg-converter \<br />&nbsp; --memory=2048m \<br />&nbsp; --execution-timeout=600s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=index.handle_process_event \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --environment SECRET_ID=$SECRET_ID \<br />&nbsp; --environment YMQ_QUEUE_URL=$YMQ_QUEUE_URL \<br />&nbsp; --environment DOCAPI_ENDPOINT=$DOCAPI_ENDPOINT \<br />&nbsp; --environment S3_BUCKET=$S3_BUCKET \<br />&nbsp; --package-bucket-name $S3_BUCKET \<br />&nbsp; --package-object-name src.zip<br />$ yc serverless trigger create message-queue \<br />&nbsp; --name ffmpeg \<br />&nbsp; --queue $YMQ_QUEUE_ARN \<br />&nbsp; --queue-service-account-id $SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --invoke-function-name ffmpeg-converter&nbsp; \<br />&nbsp; --invoke-function-service-account-id $SERVICE_ACCOUNT_FFMPEG_ID \<br />&nbsp; --batch-size 1 \<br />&nbsp; --batch-cutoff 10s<br />$ yc serverless trigger delete ffmpeg<br /><strong>Task:</strong><br />Сокращатель ссылок. <br />В рамках этого курса вы изучили несколько ключевых сервисов Yandex Cloud, относящихся к группе Serverless. <br />Давайте объединим их для решения ещё одной практической задачи и создадим сервис, который конвертирует длинные ссылки в короткие.<br /><strong>Decision:</strong><br />Шаг 1. Сервисный аккаунт<br />Создание аккаунта<br />Создайте сервисный аккаунт с именем serverless-shortener:<br />&nbsp;export SERVICE_ACCOUNT_SHORTENER_ID=$(yc iam service-account create --name serverless-shortener \<br />&nbsp; --description "service account for serverless" \<br />&nbsp; --format json | jq -r .) <br />Проверьте текущий список сервисных аккаунтов:<br />yc iam service-account list <br />После проверки запишите идентификатор созданного сервисного аккаунта в переменную SERVICE_ACCOUNT_SHORTENER_ID:<br />echo "export SERVICE_ACCOUNT_SHORTENER_ID=&lt;идентификатор сервисного аккаунта&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $SERVICE_ACCOUNT_SHORTENER_ID <br />Назначение ролей<br />Добавьте созданному сервисному аккаунту роли editor, storage.viewer и ydb.admin:<br />echo "export FOLDER_ID=$(yc config get folder-id)" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $FOLDER_ID<br />echo "export OAUTH_TOKEN=$(yc config get token)" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $OAUTH_TOKEN<br />echo "export CLOUD_ID=$(yc config get cloud-id)" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $CLOUD_ID<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_SHORTENER_ID \<br />&nbsp; --role editor<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_SHORTENER_ID \<br />&nbsp; --role ydb.admin<br />yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_SHORTENER_ID \<br />&nbsp; --role storage.viewer <br />Шаг 2. Создание бакета в Object Storage<br />Сделаем для нашего сервиса веб-интерфейс. Поскольку это будет статическая веб-страница, разместим её в объектном хранилище.<br />В консоли управления в вашем рабочем каталоге выберите сервис Object Storage. Нажмите кнопку Создать бакет.<br />На странице создания бакета:<br />&nbsp;&nbsp;&nbsp; Введите имя бакета. В нашем примере это будет storage-for-serverless-shortener.<br />&nbsp;&nbsp;&nbsp; Ограничьте максимальный размер бакета (например 1 ГБ).<br />&nbsp;&nbsp;&nbsp; Выберите тип доступа Публичный во всех случаях.<br />&nbsp;&nbsp;&nbsp; Выберите класс хранилища Стандартное.<br />Нажмите кнопку Создать бакет для завершения операции.<br />Создайте и загрузите файл index.html в созданный бакет &mdash; это будет стартовая страничка для нашего сокращателя:<br />&lt;!DOCTYPE html&gt;<br />&lt;html lang="en"&gt;<br />&lt;head&gt;<br />&nbsp;&nbsp;&nbsp; &lt;meta charset="UTF-8"&gt;<br />&nbsp;&nbsp;&nbsp; &lt;title&gt;Сокращатель URL&lt;/title&gt;<br />&nbsp;&nbsp;&nbsp; &lt;!-- предостережет от лишнего GET запроса на адрес /favicon.ico --&gt;<br />&nbsp;&nbsp;&nbsp; &lt;link rel="icon" href="data:;base64,iVBORw0KGgo="&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;h1&gt;Добро пожаловать&lt;/h1&gt;<br />&lt;form action="javascript:shorten()"&gt;<br />&nbsp;&nbsp;&nbsp; &lt;label for="url"&gt;Введите ссылку:&lt;/label&gt;&lt;br&gt;<br />&nbsp;&nbsp;&nbsp; &lt;input id="url" name="url" type="text"&gt;&lt;br&gt;<br />&nbsp;&nbsp;&nbsp; &lt;input type="submit" value="Сократить"&gt;<br />&lt;/form&gt;<br />&lt;p id="shortened"&gt;&lt;/p&gt;<br />&lt;/body&gt;<br />&lt;script&gt;<br />&nbsp;&nbsp;&nbsp; function shorten() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const link = document.getElementById("url").value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fetch("/shorten", {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; method: 'POST',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; headers: {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Content-Type': 'application/json'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body: link<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .then(response =&gt; response.json())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .then(data =&gt; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const url = data.url<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.getElementById("shortened").innerHTML = `&lt;a href=${url}&gt;${url}&lt;/a&gt;`<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .catch(error =&gt; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.getElementById("shortened").innerHTML = `&lt;p&gt;Произошла ошибка ${error}, попробуйте еще раз&lt;/p&gt;`<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })<br />&nbsp;&nbsp;&nbsp; }<br />&lt;/script&gt;<br />&lt;/html&gt; <br />Шаг 3. Создание базы данных<br />&nbsp;&nbsp;&nbsp; Создадим бессерверную базу данных YDB с именем for-serverless-shortener. Чтобы не переключаться из терминала, снова воспользуемся CLI. Обязательно укажите флаг --serverless для выбора типа создаваемой базы данных:<br />yc ydb database create for-serverless-shortener \<br />&nbsp; --serverless \<br />&nbsp; --folder-id $FOLDER_ID<br />yc ydb database list <br />&nbsp;&nbsp;&nbsp; Выполните команду:<br />yc ydb database get --name for-serverless-shortener <br />В выводе вы увидите значение endpoint. Оно состоит из двух частей: собственно эндпоинта (обычно это ydb.serverless.yandexcloud.net:2135) и пути базы данных (он указывается после ключевого слова database и начинается с символа /, например /ru-central1/...). Сохраним адрес эндпоинта в переменную YDB_ENDPOINT, а путь базы данных &mdash; в переменную YDB_DATABASE. Они пригодятся нам для подключения функции.<br />yc ydb database get --name for-serverless-shortener<br />echo "export YDB_ENDPOINT=&lt;YDB_ENDPOINT&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $YDB_ENDPOINT<br />echo "export YDB_DATABASE=&lt;YDB_DATABASE&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $YDB_DATABASE <br />&nbsp;&nbsp;&nbsp; Для дальнейшей работы нам понадобится утилита ydb:<br />curl https://storage.yandexcloud.net/yandexcloud-ydb/install.sh | bash <br />&nbsp;&nbsp;&nbsp; С помощью CLI создадим авторизованный ключ сервисного аккаунта serverless-shortener:<br />&nbsp;&nbsp;&nbsp; yc iam key create \<br />&nbsp;&nbsp;&nbsp; --service-account-name serverless-shortener \<br />&nbsp;&nbsp;&nbsp; --output serverless-shortener.sa <br />Сохраним путь к файлу с ключом в переменную окружения:<br />echo "export SA_KEY_FILE=$PWD/serverless-shortener.sa" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />echo $SA_KEY_FILE <br />&nbsp;&nbsp;&nbsp; Проверим работоспособность с помощью команды:<br />ydb \<br />&nbsp; --endpoint $YDB_ENDPOINT \<br />&nbsp; --database $YDB_DATABASE \<br />&nbsp; --sa-key-file $SA_KEY_FILE \<br />&nbsp; discovery whoami \<br />&nbsp; --groups <br />&nbsp;&nbsp;&nbsp; Сохраним в файл links.yql SQL-скрипт для создания таблицы:<br />CREATE TABLE links<br />(<br />&nbsp;&nbsp;&nbsp; id Utf8,<br />&nbsp;&nbsp;&nbsp; link Utf8,<br />&nbsp;&nbsp;&nbsp; PRIMARY KEY (id)<br />);<br />COMMIT; <br />&nbsp;&nbsp;&nbsp; Запустите создание таблицы, а затем проверьте результат:<br />ydb \<br />&nbsp; --endpoint $YDB_ENDPOINT \<br />&nbsp; --database $YDB_DATABASE \<br />&nbsp; --sa-key-file $SA_KEY_FILE \<br />&nbsp; scripting yql --file links.yql<br />ydb \<br />&nbsp; --endpoint $YDB_ENDPOINT \<br />&nbsp; --database $YDB_DATABASE \<br />&nbsp; --sa-key-file $SA_KEY_FILE \<br />&nbsp; scheme describe links <br />Шаг 4. Создание функции<br />&nbsp;&nbsp;&nbsp; В рабочем каталоге создайте файл index.py:<br />from kikimr.public.sdk.python import client as ydb<br />import urllib.parse<br />import hashlib<br />import base64<br />import json<br />import os<br />def decode(event, body):<br />&nbsp;&nbsp;&nbsp; # тело запроса может быть закодировано<br />&nbsp;&nbsp;&nbsp; is_base64_encoded = event.get('isBase64Encoded')<br />&nbsp;&nbsp;&nbsp; if is_base64_encoded:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body = str(base64.b64decode(body), 'utf-8')<br />&nbsp;&nbsp;&nbsp; return body<br />def response(statusCode, headers, isBase64Encoded, body):<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'headers': headers,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'isBase64Encoded': isBase64Encoded,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': body,<br />&nbsp;&nbsp;&nbsp; }<br />def get_config():<br />&nbsp;&nbsp;&nbsp; endpoint = os.getenv("endpoint")<br />&nbsp;&nbsp;&nbsp; database = os.getenv("database")<br />&nbsp;&nbsp;&nbsp; if endpoint is None or database is None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise AssertionError("Нужно указать обе переменные окружения")<br />&nbsp;&nbsp;&nbsp; credentials = ydb.construct_credentials_from_environ()<br />&nbsp;&nbsp;&nbsp; return ydb.DriverConfig(endpoint, database, credentials=credentials)<br />def execute(config, query, params):<br />&nbsp;&nbsp;&nbsp; with ydb.Driver(config) as driver:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.wait(timeout=5)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; except TimeoutError:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Connect failed to YDB")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Last reported errors by discovery:")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(driver.discovery_debug_details())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; session = driver.table_client.session().create()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prepared_query = session.prepare(query)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return session.transaction(ydb.SerializableReadWrite()).execute(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prepared_query,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; commit_tx=True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br />def insert_link(id, link):<br />&nbsp;&nbsp;&nbsp; config = get_config()<br />&nbsp;&nbsp;&nbsp; query = """<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE $id AS Utf8;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE $link AS Utf8;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UPSERT INTO links (id, link) VALUES ($id, $link);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; params = {'$id': id, '$link': link}<br />&nbsp;&nbsp;&nbsp; execute(config, query, params)<br />def find_link(id):<br />&nbsp;&nbsp;&nbsp; print(id)<br />&nbsp;&nbsp;&nbsp; config = get_config()<br />&nbsp;&nbsp;&nbsp; query = """<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE $id AS Utf8;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT link FROM links where id=$id;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; params = {'$id': id}<br />&nbsp;&nbsp;&nbsp; result_set = execute(config, query, params)<br />&nbsp;&nbsp;&nbsp; if not result_set or not result_set[0].rows:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None<br />&nbsp;&nbsp;&nbsp; return result_set[0].rows[0].link<br />def shorten(event):<br />&nbsp;&nbsp;&nbsp; body = event.get('body')<br />&nbsp;&nbsp;&nbsp; if body:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body = decode(event, body)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; original_host = event.get('headers').get('Origin')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link_id = hashlib.sha256(body.encode('utf8')).hexdigest()[:6]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # в ссылке могут быть закодированные символы, например, %. это помешает работе api-gateway при редиректе,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # поэтому следует избавиться от них вызовом urllib.parse.unquote<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert_link(link_id, urllib.parse.unquote(body))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return response(200, {'Content-Type': 'application/json'}, False, json.dumps({'url': f'{original_host}/r/{link_id}'}))<br />&nbsp;&nbsp;&nbsp; return response(400, {}, False, 'В теле запроса отсутствует параметр url')<br />def redirect(event):<br />&nbsp;&nbsp;&nbsp; link_id = event.get('pathParams').get('id')<br />&nbsp;&nbsp;&nbsp; redirect_to = find_link(link_id)<br />&nbsp;&nbsp;&nbsp; if redirect_to:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return response(302, {'Location': redirect_to}, False, '')<br />&nbsp;&nbsp;&nbsp; return response(404, {}, False, 'Данной ссылки не существует')<br /># эти проверки нужны, поскольку функция у нас одна<br /># в идеале сделать по функции на каждый путь в api-gw<br />def get_result(url, event):<br />&nbsp;&nbsp;&nbsp; if url == "/shorten":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return shorten(event)<br />&nbsp;&nbsp;&nbsp; if url.startswith("/r/"):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return redirect(event)<br />&nbsp;&nbsp;&nbsp; return response(404, {}, False, 'Данного пути не существует')<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; url = event.get('url')<br />&nbsp;&nbsp;&nbsp; if url:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # из API-gateway url может прийти со знаком вопроса на конце<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if url[-1] == '?':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; url = url[:-1]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return get_result(url, event)<br />&nbsp;&nbsp;&nbsp; return response(404, {}, False, 'Эту функцию следует вызывать при помощи api-gateway') <br />Создайте файл requirements.txt:<br />pipreqs $PWD --force <br />Находясь в директории с исходными файлами, упакуйте все нужные файлы в zip-архив:<br />zip src.zip index.py requirements.txt <br />&nbsp;&nbsp;&nbsp; В переменные окружения функции необходимо добавить:<br />&nbsp;&nbsp;&nbsp; endpoint &mdash; нужно указать протокол grpcs:// и добавить значение Эндпоинт из секции YDB эндпоинт, обычно получается grpcs://ydb.serverless.yandexcloud.net:2135.<br />&nbsp;&nbsp;&nbsp; database &mdash; это значение поля База данных из секции YDB эндпоинт (начинается с /ru-central1/....).<br />&nbsp;&nbsp;&nbsp; USE_METADATA_CREDENTIALS &mdash; выставите значение переменной в 1.<br />&nbsp;&nbsp;&nbsp; Создадим нашу функцию for-serverless-shortener. При этом сразу зададим все необходимые переменные, сервисный аккаунт и сделаем ее публичной:<br />yc serverless function create \<br />&nbsp; --name for-serverless-shortener \<br />&nbsp; --description "function for serverless-shortener"<br />yc serverless function version create \<br />&nbsp; --function-name for-serverless-shortener \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python37 \<br />&nbsp; --entrypoint=index.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_SHORTENER_ID \<br />&nbsp; --environment USE_METADATA_CREDENTIALS=1 \<br />&nbsp; --environment endpoint=grpcs://ydb.serverless.yandexcloud.net:2135 \<br />&nbsp; --environment database=$YDB_DATABASE \<br />&nbsp; --source-path src.zip<br />yc serverless function allow-unauthenticated-invoke for-serverless-shortener <br />Шаг 5. Конфигурирование Yandex API Gateway<br />&nbsp;&nbsp;&nbsp; Создадим спецификацию for-serverless-shortener.yml со следующим содержанием:<br />openapi: 3.0.0<br />info:<br />&nbsp; title: for-serverless-shortener<br />&nbsp; version: 1.0.0<br />paths:<br />&nbsp; /:<br />&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: object_storage<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bucket:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;bucket_name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # &lt;-- имя бакета<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;html_file&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # &lt;-- имя html-файла<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; presigned_redirect: false<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_account:&nbsp;&nbsp;&nbsp; &lt;service_account_id&gt; # &lt;-- идентификатор сервисного аккаунта<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: static<br />&nbsp; /shorten:<br />&nbsp;&nbsp;&nbsp; post:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: cloud_functions<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function_id:&nbsp; &lt;function_id&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # &lt;-- идентификатор функции<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: shorten<br />&nbsp; /r/{id}:<br />&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: cloud_functions<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function_id:&nbsp; &lt;function_id&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # &lt;-- идентификатор функции<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: redirect<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameters:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - description: id of the url<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explode: false<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in: path<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name: id<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; required: true<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schema:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: string<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style: simple <br />Не забудьте подставить в спецификацию актуальные для вас значения переменных.<br />&nbsp;&nbsp;&nbsp; Используем спецификацию для инициализации:<br />yc serverless api-gateway create \<br />&nbsp; --name for-serverless-shortener \<br />&nbsp; --spec=for-serverless-shortener.yml \<br />&nbsp; --description "for serverless shortener" <br />В результате успешного создания API-шлюза получим значение параметра domain:<br />yc serverless api-gateway list<br />yc serverless api-gateway get --name for-serverless-shortener <br />&nbsp;&nbsp;&nbsp; Чтобы проверить работоспособность API-шлюза и созданного приложения целиком, скопируйте служебный домен (вида https://&lt;идентификатор API Gateway&gt;.apigw.yandexcloud.net/) и вставьте адрес в браузер.<br />Добавляйте адреса сайтов в форму, они будут сохранятся в базу данных. А вам будет доступна ссылка, за которой будет скрываться оригинальный адрес. Ваше приложение полностью работоспособно. Теперь вы умеете использовать serverless-стеком технологий Yandex Cloud.<br />Итак, вы создали приложение с использованием Cloud Functions, API Gateway, Object Storage и Yandex Database. Конечно, вы можете развивать его и дальше, расширяя функциональность.<br /><strong>Decision:</strong><br />$ export SERVICE_ACCOUNT_SHORTENER_ID=$(yc iam service-account create --name serverless-shortener \<br />&nbsp; --description "service account for serverless" \<br />&nbsp; --format json | jq -r .)<br />$ yc iam service-account list<br />$ echo "export SERVICE_ACCOUNT_SHORTENER_ID=&lt;идентификатор сервисного аккаунта&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $SERVICE_ACCOUNT_SHORTENER_ID<br />$ echo "export FOLDER_ID=$(yc config get folder-id)" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $FOLDER_ID<br />$ echo "export OAUTH_TOKEN=$(yc config get token)" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $OAUTH_TOKEN<br />$ echo "export CLOUD_ID=$(yc config get cloud-id)" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $CLOUD_ID<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_SHORTENER_ID \<br />&nbsp; --role editor<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_SHORTENER_ID \<br />&nbsp; --role ydb.admin<br />$ yc resource-manager folder add-access-binding $FOLDER_ID \<br />&nbsp; --subject serviceAccount:$SERVICE_ACCOUNT_SHORTENER_ID \<br />&nbsp; --role storage.viewer<br />$ vim index.html<br />$ cat index.html<br />&lt;!DOCTYPE html&gt;<br />&lt;html lang="en"&gt;<br />&lt;head&gt;<br />&nbsp;&nbsp;&nbsp; &lt;meta charset="UTF-8"&gt;<br />&nbsp;&nbsp;&nbsp; &lt;title&gt;Сокращатель URL&lt;/title&gt;<br />&nbsp;&nbsp;&nbsp; &lt;!-- предостережет от лишнего GET запроса на адрес /favicon.ico --&gt;<br />&nbsp;&nbsp;&nbsp; &lt;link rel="icon" href="data:;base64,iVBORw0KGgo="&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;h1&gt;Добро пожаловать&lt;/h1&gt;<br />&lt;form action="javascript:shorten()"&gt;<br />&nbsp;&nbsp;&nbsp; &lt;label for="url"&gt;Введите ссылку:&lt;/label&gt;&lt;br&gt;<br />&nbsp;&nbsp;&nbsp; &lt;input id="url" name="url" type="text"&gt;&lt;br&gt;<br />&nbsp;&nbsp;&nbsp; &lt;input type="submit" value="Сократить"&gt;<br />&lt;/form&gt;<br />&lt;p id="shortened"&gt;&lt;/p&gt;<br />&lt;/body&gt;<br />&lt;script&gt;<br />&nbsp;&nbsp;&nbsp; function shorten() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const link = document.getElementById("url").value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fetch("/shorten", {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; method: 'POST',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; headers: {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Content-Type': 'application/json'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body: link<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .then(response =&gt; response.json())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .then(data =&gt; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const url = data.url<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.getElementById("shortened").innerHTML = `&lt;a href=${url}&gt;${url}&lt;/a&gt;`<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .catch(error =&gt; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.getElementById("shortened").innerHTML = `&lt;p&gt;Произошла ошибка ${error}, попробуйте еще раз&lt;/p&gt;`<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })<br />&nbsp;&nbsp;&nbsp; }<br />&lt;/script&gt;<br />&lt;/html&gt;<br />$ yc ydb database create for-serverless-shortener \<br />&nbsp; --serverless \<br />&nbsp; --folder-id $FOLDER_ID<br />$ yc ydb database list<br />$ yc ydb database get --name for-serverless-shortener<br />$ echo "export YDB_ENDPOINT=&lt;YDB_ENDPOINT&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $YDB_ENDPOINT<br />$ echo "export YDB_DATABASE=&lt;YDB_DATABASE&gt;" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $YDB_DATABASE<br />$ curl https://storage.yandexcloud.net/yandexcloud-ydb/install.sh | bash<br />$ yc iam key create \<br />--service-account-name serverless-shortener \<br />--output serverless-shortener.sa<br />$ echo "export SA_KEY_FILE=$PWD/serverless-shortener.sa" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc<br />$ echo $SA_KEY_FILE<br />$ ydb \<br />&nbsp; --endpoint $YDB_ENDPOINT \<br />&nbsp; --database $YDB_DATABASE \<br />&nbsp; --sa-key-file $SA_KEY_FILE \<br />&nbsp; discovery whoami \<br />&nbsp; --groups<br />$ vim links.yql<br />$ cat links.yql<br />CREATE TABLE links<br />(<br />&nbsp;&nbsp;&nbsp; id Utf8,<br />&nbsp;&nbsp;&nbsp; link Utf8,<br />&nbsp;&nbsp;&nbsp; PRIMARY KEY (id)<br />);<br />COMMIT;<br />$ ydb \<br />&nbsp; --endpoint $YDB_ENDPOINT \<br />&nbsp; --database $YDB_DATABASE \<br />&nbsp; --sa-key-file $SA_KEY_FILE \<br />&nbsp; scripting yql --file links.yql<br />$ ydb \<br />&nbsp; --endpoint $YDB_ENDPOINT \<br />&nbsp; --database $YDB_DATABASE \<br />&nbsp; --sa-key-file $SA_KEY_FILE \<br />&nbsp; scheme describe links<br />$ vim index1.py<br />$ cat index1.py<br />import ydb<br />import urllib.parse<br />import hashlib<br />import base64<br />import json<br />import os<br />def decode(event, body):<br />&nbsp;&nbsp;&nbsp; # тело запроса может быть закодировано<br />&nbsp;&nbsp;&nbsp; is_base64_encoded = event.get('isBase64Encoded')<br />&nbsp;&nbsp;&nbsp; if is_base64_encoded:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body = str(base64.b64decode(body), 'utf-8')<br />&nbsp;&nbsp;&nbsp; return body<br />def response(statusCode, headers, isBase64Encoded, body):<br />&nbsp;&nbsp;&nbsp; return {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'statusCode': statusCode,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'headers': headers,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'isBase64Encoded': isBase64Encoded,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'body': body,<br />&nbsp;&nbsp;&nbsp; }<br />def get_config():<br />&nbsp;&nbsp;&nbsp; endpoint = os.getenv("endpoint")<br />&nbsp;&nbsp;&nbsp; database = os.getenv("database")<br />&nbsp;&nbsp;&nbsp; if endpoint is None or database is None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise AssertionError("Нужно указать обе переменные окружения")<br />&nbsp;&nbsp;&nbsp; credentials = ydb.construct_credentials_from_environ()<br />&nbsp;&nbsp;&nbsp; return ydb.DriverConfig(endpoint, database, credentials=credentials)<br />def execute(config, query, params):<br />&nbsp;&nbsp;&nbsp; with ydb.Driver(config) as driver:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.wait(timeout=5)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; except TimeoutError:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Connect failed to YDB")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Last reported errors by discovery:")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(driver.discovery_debug_details())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; session = driver.table_client.session().create()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prepared_query = session.prepare(query)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return session.transaction(ydb.SerializableReadWrite()).execute(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prepared_query,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; commit_tx=True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br />def insert_link(id, link):<br />&nbsp;&nbsp;&nbsp; config = get_config()<br />&nbsp;&nbsp;&nbsp; query = """<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE $id AS Utf8;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE $link AS Utf8;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UPSERT INTO links (id, link) VALUES ($id, $link);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; params = {'$id': id, '$link': link}<br />&nbsp;&nbsp;&nbsp; execute(config, query, params)<br />def find_link(id):<br />&nbsp;&nbsp;&nbsp; print(id)<br />&nbsp;&nbsp;&nbsp; config = get_config()<br />&nbsp;&nbsp;&nbsp; query = """<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE $id AS Utf8;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT link FROM links where id=$id;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp; params = {'$id': id}<br />&nbsp;&nbsp;&nbsp; result_set = execute(config, query, params)<br />&nbsp;&nbsp;&nbsp; if not result_set or not result_set[0].rows:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None<br />&nbsp;&nbsp;&nbsp; return result_set[0].rows[0].link<br />def shorten(event):<br />&nbsp;&nbsp;&nbsp; body = event.get('body')<br />&nbsp;&nbsp;&nbsp; if body:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body = decode(event, body)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; original_host = event.get('headers').get('Origin')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link_id = hashlib.sha256(body.encode('utf8')).hexdigest()[:6]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # в ссылке могут быть закодированные символы, например, %. это помешает работе api-gateway при редиректе,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # поэтому следует избавиться от них вызовом urllib.parse.unquote<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert_link(link_id, urllib.parse.unquote(body))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return response(200, {'Content-Type': 'application/json'}, False, json.dumps({'url': f'{original_host}/r/{link_id}'}))<br />&nbsp;&nbsp;&nbsp; return response(400, {}, False, 'В теле запроса отсутствует параметр url')<br />def redirect(event):<br />&nbsp;&nbsp;&nbsp; link_id = event.get('pathParams').get('id')<br />&nbsp;&nbsp;&nbsp; redirect_to = find_link(link_id)<br />&nbsp;&nbsp;&nbsp; if redirect_to:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return response(302, {'Location': redirect_to}, False, '')<br />&nbsp;&nbsp;&nbsp; return response(404, {}, False, 'Данной ссылки не существует')<br /># эти проверки нужны, поскольку функция у нас одна<br /># в идеале сделать по функции на каждый путь в api-gw<br />def get_result(url, event):<br />&nbsp;&nbsp;&nbsp; if url == "/shorten":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return shorten(event)<br />&nbsp;&nbsp;&nbsp; if url.startswith("/r/"):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return redirect(event)<br />&nbsp;&nbsp;&nbsp; return response(404, {}, False, 'Данного пути не существует')<br />def handler(event, context):<br />&nbsp;&nbsp;&nbsp; url = event.get('url')<br />&nbsp;&nbsp;&nbsp; if url:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # из API-gateway url может прийти со знаком вопроса на конце<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if url[-1] == '?':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; url = url[:-1]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return get_result(url, event)<br />&nbsp;&nbsp;&nbsp; return response(404, {}, False, 'Эту функцию следует вызывать при помощи api-gateway')<br />$ vim requirements.txt <br />$ cat requirements.txt <br />...<br />ydb==2.13.3<br />$ zip src.zip index1.py requirements.txt<br />$ yc serverless function create \<br />&nbsp; --name for-serverless-shortener \<br />&nbsp; --description "function for serverless-shortener"<br />$ yc serverless function version create \<br />&nbsp; --function-name for-serverless-shortener \<br />&nbsp; --memory=256m \<br />&nbsp; --execution-timeout=5s \<br />&nbsp; --runtime=python39 \<br />&nbsp; --entrypoint=index.handler \<br />&nbsp; --service-account-id $SERVICE_ACCOUNT_SHORTENER_ID \<br />&nbsp; --environment USE_METADATA_CREDENTIALS=1 \<br />&nbsp; --environment endpoint=grpcs://ydb.serverless.yandexcloud.net:2135 \<br />&nbsp; --environment database=$YDB_DATABASE \<br />&nbsp; --source-path src.zip<br />$ yc serverless function allow-unauthenticated-invoke for-serverless-shortener<br />$ vim for-serverless-shortener.yml<br />$ cat for-serverless-shortener.yml<br />openapi: 3.0.0<br />info:<br />&nbsp; title: for-serverless-shortener<br />&nbsp; version: 1.0.0<br />paths:<br />&nbsp; /:<br />&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: object_storage<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bucket:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;bucket_name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # &lt;-- имя бакета<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;html_file&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # &lt;-- имя html-файла<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; presigned_redirect: false<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_account:&nbsp;&nbsp;&nbsp; &lt;service_account_id&gt; # &lt;-- идентификатор сервисного аккаунта<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: static<br />&nbsp; /shorten:<br />&nbsp;&nbsp;&nbsp; post:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: cloud_functions<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function_id:&nbsp; &lt;function_id&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # &lt;-- идентификатор функции<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: shorten<br />&nbsp; /r/{id}:<br />&nbsp;&nbsp;&nbsp; get:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x-yc-apigateway-integration:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: cloud_functions<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function_id:&nbsp; &lt;function_id&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # &lt;-- идентификатор функции<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operationId: redirect<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameters:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - description: id of the url<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explode: false<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in: path<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name: id<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; required: true<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schema:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: string<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style: simple<br />$ yc serverless api-gateway create \<br />&nbsp; --name for-serverless-shortener \<br />&nbsp; --spec=for-serverless-shortener.yml \<br />&nbsp; --description "for serverless shortener"<br />$ yc serverless api-gateway list<br />$ yc serverless api-gateway get --name for-serverless-shortener</p>
