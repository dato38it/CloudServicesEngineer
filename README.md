# Инженер облачных сервисов Yandex
<p>В рамках программы "Инженер облачных сервисов Yandex" защитил практические работы по темам "Хранение и анализ данных", "Devops и автоматизация", "Serverless" и "Безопасность":<br>- развернул пять кластеров баз данных MySQL, PostgreSQL, MongoDB, ClickHouse и Ydb<br>- добавил данные из файлов в БД ClickHouse для анализа прогноза за всю историю наблюдений за последние несколько лет с помощью SQL-запросов<br>- добавил данные из тестового приложения для подключения к БД YDB и запуска тестового приложения, чтобы создать в ней несколько таблиц с данными о популярных сериалах<br>- реализовал систему хранения рентгеновских снимков для клиники<br>- развернул кластер Hadoop с помощью сервиса Yandex Data Proc<br>- поднял кластер Kubernetes в Yandex Cloud<br>- развернул приложение веб-сервер NGINX c Балансировкой нагрузки и Автомасштабированием в Yandex Managed Kubernetes<br>- проверил на отказоустойчивость по основным сценариям сбоев<br>- разработал навык Алисы, которая повторяет всё, что вы ему напишете с сохранением фраз в новом файле в бакете<br>- разработал функцию для проверки доступности сайта ya.ru, которая будет измерять время ответа, передавать в БД PostgreSQL результаты работы функции, запускать триггер-таймер для регулярного опроса сайта ya.ru <br>- с помощью REST API получил до 50 результатов проверки из БД, <br>- реализовал проекты, которые позволят пользователям конвертировать видеофайлы в GIF и конвертировать длинные ссылки в короткие<br>- реализовал права на управление сервисным аккаунтом<br>- организовал защищённый канал настроив IPSec VPN-туннель между двумя VPN-шлюзами в ВМ с помощью демона strongSwan<br>- реализовал для домена втоматический выпуск сертификата с помощью Certificate Manager</p>

<p><strong>Task:</strong><br>Хранение и анализ данных в Yandex Cloud</p>
<p><strong>Task:</strong><br>Создание бакетов и загрузка объектов<br>Потренируемся работать с объектным хранилищем на практике. Представьте, что вы создаёте облачную систему хранения рентгеновских снимков для крупной клиники.<br>Рентгеновские снимки — это неструктурированные данные, которые нельзя изменять, нужно надежно хранить и легко находить. <br>Загруженные файлы будут скачивать нечасто. Также важно предоставлять доступ к файлам другим клиникам (это пригодится, если пациента переводят или врачу надо посоветоваться с коллегами). Объектное хранилище — подходящее решение задачи.<br><strong>Decision:</strong><br>Выберите на стартовой странице консоли управления сервис Object Storage.<br>Давайте создадим бакет для рентгеновских снимков.<br>Нажмите кнопку Создать бакет. Откроется окно с основными параметрами: <br>Имя. Придумайте его с учетом правил. Обратите внимание, что дать бакету имя hospital не получится. Имена бакетов во всем Yandex Object Storage уникальны — назвать два бакета одинаково нельзя даже в разных облаках. Помните об этом, если будете создавать бакеты автоматически.<br>Макс. размер. У вас есть два варианта: Выбрать опцию Без ограничения. Размер бакета будет увеличиваться, сколько бы объектов в него ни помещали. Указать максимальный размер. Это убережёт вас от финансовых потерь, если что-то пойдёт не так и в бакет загрузится слишком много объектов.<br>Другие опции. Далее для всех типов операций оставьте ограниченный доступ (публичный позволяет выполнять операции всем пользователям интернета), выберите стандартный класс хранилища и нажмите кнопку Создать бакет.<br>На странице объектного хранилища появился пустой бакет. Мы приготовили два рентгеновских снимка: image01.dat и image02.dat. Файлы можно загрузить в бакет с помощью: консоли управления; приложений; S3-совместимого HTTP API; HTML-форм на сайте.<br>Разберём два способа: ручную загрузку через консоль управления и автоматическую с помощью утилиты S3cmd.<br>Для загрузки файла через консоль управления выберите созданный бакет и в открывшемся окне нажмите кнопку Загрузить объекты.<br>Выберем файл image01.dat. В появившейся форме нажмите кнопку Загрузить — и вы увидите, что файл оказался в хранилище.<br>Загрузите второй файл с помощью утилиты S3cmd — консольного клиента для Linux и MacOS, предназначенного для работы с S3-совместимым HTTP API. Для работы в Windows используйте один из вариантов:  установите другой консольный клиент для объектных хранилищ, например AWS CLI;  установите подсистему Linux на Windows с помощью утилиты WSL (Windows Subsystem for Linux) и работайте с S3cmd в ней; создайте в облаке виртуальную машину с Ubuntu и работайте с S3cmd в ней. Для загрузки файла-примера в виртуальную машину воспользуйтесь командой:<br>$ wget "https://disk.yandex.ru/i/2UlugGkurhcxWw" -O image02.dat <br>Установите S3cmd (в Ubuntu, например, это делается с помощью команды sudo apt-get install s3cmd). Теперь настройте S3cmd для работы с Yandex Object Storage:<br>$ s3cmd --configure<br>Инструкции о настройке клиента вы найдете в документации.<br>После ввода параметров утилита попытается установить соединение с объектным хранилищем и в случае успеха покажет такое сообщение: Success. Your access key and secret key worked fine :-)<br>Загрузим в бакет второй файл (image02.dat) и затем получим список хранящихся в бакете объектов:<br>s3cmd put &lt;путь к второму файлу&gt;/image02.dat s3://&lt;имя бакета&gt;<br>s3cmd ls s3://&lt;имя бакета&gt;<br>Вернемся в консоль управления.<br>Мы видим, что класс хранилища у обоих объектов — стандартное. Напомним: стандартное хранилище подходит для данных, к которым обращаются часто, а тариф за размещение данных в нем примерно в два раза выше, чем в холодном хранилище.<br>Спустя несколько недель после того, как рентгеновский снимок сделан, к нему будут редко обращаться (если вообще будут), потому что пациент, скорее всего, выздоровеет.<br>Чтобы оптимизировать затраты на хранение данных, настроим жизненный цикл объектов в бакете. Создадим правило, согласно которому через 30 дней после загрузки объектов в бакет класс их хранилища будет автоматически меняться со стандартного на холодное.<br>Перейдите на вкладку Жизненный цикл и нажмите кнопку Настроить. Задайте произвольное описание. В поле Префикс укажите Все объекты. Выберите тип операции Transition. В качестве Условия срабатывания правила задайте Точную дату или Количество дней. В первом случае правило сработает в 00:00 установленной даты. Во втором — через указанное количество дней после загрузки объекта в бакет.<br>Если понадобится настроить автоматическое удаление объектов, выберите тип операции Expiration. Нажмите кнопку Сохранить.<br>Представим теперь, что объекты в хранилище — это оцифрованные рентгеновские снимки пациента Петрова. Первый из них (image01.dat) сделали несколько месяцев назад в ходе профосмотра, а второй (image02.dat) — вчера, после того как Петров обратился к врачу с жалобой на недомогание. В обоих случаях на снимках не увидели патологий.<br>Опишите с помощью пользовательских метаданных эти снимки, и позже вы быстро найдете их среди множества объектов в бакете.<br>С помощью утилиты S3cmd задайте для загруженных объектов метаданные с фамилией пациента (x-amz-meta-patient:petrov) и с результатами обследования (x-amz-meta-status:ok):<br>s3cmd modify --add-header=x-amz-meta-patient:petrov --add-header=x-amz-meta-status:ok s3://hospital/image01.dat s3://hospital/image02.dat<br>Выведите на экран информацию об этих объектах, чтобы проверить, что получилось:<br>s3cmd info s3://hospital/image01.dat s3://hospital/image02.dat<br>В результате вы должны увидеть информацию об объектах в бакете.<br>s3://hospital/image01.dat (object):<br>  File size: 33<br>  Last mod:  Thu, 04 Mar 2021 22:05:31 GMT<br>  MIME type: application/x-www-form-urlencoded<br>  Storage:   STANDARD<br>  MD5 sum:   6f6d5a1cb79839e523582ed8810a42fd<br>  SSE:&nbsp;&nbsp;   none<br>  Policy:&nbsp;&nbsp;none<br>  CORS:&nbsp;&nbsp;  none<br>  x-amz-meta-patient: petrov<br>  x-amz-meta-status: ok<br>s3://hospital/image02.dat (object):<br>  File size: 16<br>  Last mod:  Thu, 04 Mar 2021 23:11:27 GMT<br>  MIME type: text/plain<br>  Storage:   STANDARD<br>  MD5 sum:   0366a1d19e584ce79d5c05ddedc69310<br>  SSE:&nbsp;&nbsp;   none<br>  Policy:&nbsp;&nbsp;none<br>  CORS:&nbsp;&nbsp;  none<br>  x-amz-meta-patient: petrov<br>  x-amz-meta-status: ok <br>Предположим, Петров чувствует себя хуже. Судя по анализам, он действительно болен. Лечащий врач решает проконсультироваться с более опытной коллегой Ивановой из профильной клиники. Объекты в бакете недоступны для внешних пользователей, поскольку при его создании мы ограничили доступ. Чтобы Иванова увидела рентгеновский снимок Петрова, отправим ей временную ссылку на объект image02.dat.<br>Для этого в консоли управления кликните на объект и в открывшемся окне информации об объекте нажмите кнопку Получить ссылку. Укажите время жизни ссылки в часах или днях.<br>Можно поделиться ссылкой или использовать ее в любом сервисе для доступа к файлу.<br>После консультации Иванова поставила Петрову правильный диагноз: вирусная пневмония (код J12 по Международной классификации болезней). Вам осталось исправить метаданные объекта image02.dat. Замените значение метаданных с результатами обследования с ok на J12 самостоятельно.<br><strong>Decision:</strong><br>$ wget "https://disk.yandex.ru/i/2UlugGkurhcxWw" -O image02.dat <br>$ wget "https://disk.yandex.ru/i/qpl0T4u-nWPgiw" -O image01.dat <br>$ ls *.dat<br>image01.dat  image02.dat<br>$ sudo apt-get install s3cmd<br>$ s3cmd --configure<br>$ s3cmd ls<br>2023-12-06 02:37  s3://klinika138<br>$ s3cmd put /YOUR-DIR/image02.dat s3://klinika138<br>$ s3cmd modify \<br>--add-header=x-amz-meta-patient:petrov \<br>--add-header=x-amz-meta-status:ok \<br>s3://klinika138/image01.dat \<br>s3://klinika138/image02.dat<br>$ s3cmd info \<br>s3://klinika138/image01.dat \<br>s3://klinika138/image02.dat <br><strong>Task:</strong><br>Хранение статических веб-сайтов в Object Storage<br>Представьте, что вам нужно выбрать оптимальный хостинг для сайта клиники. Главные критерии: отказоустойчивый, недорогой и простой в обслуживании. <br>Один из вариантов решения такой задачи — использовать объектное хранилище. Вы можете, не настраивая никаких серверов, просто загрузить HTML-файлы, скрипты, стили и другие файлы в хранилище. Пользователи будут открывать в браузере ваш сайт, а по сути — скачивать файлы прямо из бакета.<br>Важно понимать, что этот вариант подойдет только для полностью статических сайтов. Иными словами, сайт должен быть сделан с помощью клиентских технологий (HTML, CSS и JavaScript) и не требовать запуска чего-либо на стороне веб-сервера.<br>Предположим, что сайт нашей клиники как раз такой — полностью статический. Опубликуйте его с помощью объектного хранилища. Прежде всего для него нужно создать бакет:<br>Decision<br>Обратите внимание на несколько особенностей: Если вы планируете использовать собственный домен (например www.example.com), то присвойте бакету точно такое же имя. Откройте публичный доступ на чтение объектов. Это позволит пользователям интернета скачивать объекты из бакета и просматривать сайт в браузере.<br>Задайте необходимые настройки и нажмите кнопку Создать бакет.<br>Теперь загрузите в бакет файлы сайта (например, этот и этот) любым удобным способом.<br>Чтобы настроить хостинг, перейдите на страницу бакета в консоли управления. Выберите вкладку Веб-сайт на левой панели и включите опцию Хостинг.<br>Укажите файл с главной страницей сайта (как правило, это index.html), а поле со страницей ошибки можно не заполнять.<br>Сохраните настройки, и сайт станет доступен по адресам: <br>http(s)://&lt;имя_бакета&gt;.website.yandexcloud.net<br>http(s)://website.yandexcloud.net/&lt;имя_бакета&gt;<br>По умолчанию сайт будет доступен только по протоколу HTTP. Для поддержки HTTPS нужно загрузить в объектное хранилище TLS-сертификат. Вам предстоит это сделать в одной из практических работ курса «Безопасность».<br>Если у вас есть собственный домен и вы хотите опубликовать сайт на нём, то настройте CNAME-запись у DNS-провайдера или на своем DNS-сервере. Например, для домена www.example.com CNAME-запись выглядела бы так: www.example.com CNAME www.example.com.website.yandexcloud.net <br>В этом случае можно использовать домены не ниже третьего уровня (то есть использовать домен example.com не получится, только www.example.com). Это связано с особенностями обработки CNAME-записей на DNS-хостингах.<br><strong>Decision:</strong><br>$ wget "https://disk.yandex.ru/d/KcpMuYBwKjIa6Q" -O index.html<br>$ wget "https://disk.yandex.ru/i/uTai62_esPSaEw" -O doctor.png<br>$ s3cmd put /YOUR-DIR/doctor.png s3://www.aibloit.healthcare138<br>$ s3cmd put /YOUR-DIR/index.html s3://www.aibloit.healthcare138<br><strong>Task:</strong><br>Создание кластера базы данных MySQL. Object Storage — удобный и полезный инструмент для хранения данных в облаке. Но для решения практических задач важно не просто хранить данные, но и иметь возможность их изменять и выполнять с ними различные операции (сортировать, группировать, делать выборки и так далее). Для этого используются базы данных. В этой и следующих темах вы научитесь работать с несколькими управляемыми БД. И начнем мы с одной из самых популярных — MySQL.<br>На этом уроке вы создадите и настроите кластер управляемой БД MySQL, подключитесь к нему, перенесёте данные в облако, познакомитесь с возможностями резервного копирования и мониторинга. Эти навыки пригодятся вам и в других сервисах управляемых БД, поскольку принципы работы в них очень похожи.<br>Предположим, вы решили добавить в разрабатываемый вами мессенджер новую функциональность. Вы написали микросервис, который позволяет оценивать сообщения в групповых чатах и хранит оценки в БД MySQL. Давайте поместим эту БД в Yandex Cloud.<br><strong>Decision:</strong><br>Прежде всего понадобится создать кластер: набор виртуальных машин (ВМ, или хостов), на которых будет развёрнута БД. Это обязательный первый шаг при использовании любого сервиса управляемых БД.<br>Войдите в консоль управления Yandex Cloud и выберите каталог для кластера. Вверху справа нажмите кнопку Создать ресурс и выберите из выпадающего списка Кластер MySQL.<br>Откроется страница с основными настройками кластера. Рассмотрим их подробнее.<br>Базовые параметры. Имя кластера может включать только цифры, прописные и строчные латинские буквы, дефисы.<br>Поле Описание заполнять необязательно. Оно полезно, если вам нужно создать несколько кластеров для разных целей, чтобы в них было проще ориентироваться.<br>О том, какое бывает Окружение кластера и чем различаются PRESTABLE и PRODUCTION, мы говорили на одном из предыдущих уроков. Поскольку микросервис только разрабатывается, выберите окружение PRESTABLE.<br>Версия. В качестве сервера MySQL в Yandex Cloud используется Percona Server версии 5.7 или 8.0. У этих реализаций сервера улучшенная производительность на многоядерных машинах. Если для вас критична стабильность работы микросервиса, выбирайте проверенную временем 5.7. Для нашей задачи подойдёт 8.0: в ней много новых функций, но она ещё не полностью обкатана.<br>Класс хостов. Следующий шаг — выбор класса хостов, или шаблона ВМ. Хосты кластера будут развёрнуты на базе ВМ Compute Cloud с использованием этого шаблона.<br>Платформа определяет тип физического процессора (Intel Broadwell или Intel Cascade Lake), а также конфигурации числа ядер виртуального процессора (vCPU) и размера оперативной памяти.<br>Если тип процессора для вас неважен, выбирайте более современную платформу Intel Cascade Lake. Она предоставляет широкий выбор конфигураций вычислительных ресурсов.<br>Также на конфигурации влияет тип ВМ, на которой будет развёрнута БД.<br>Standard — это обычные ВМ с 4 ГБ RAM на ядро vCPU. Это оптимальный баланс между количеством запущенных процессов, быстродействием и потребляемой оперативной памятью.<br>Memory-optimized — машины с вдвое увеличенным объёмом RAM на каждое ядро. Выбирайте их для высоконагруженных сервисов с повышенными требованиями к кешу.<br>Burstable — машины, для которых гарантируется использование лишь доли ядра vCPU (5, 20 или 50%) с вероятностью временного повышения вплоть до 100%. Они стоят дешевле и подходят для задач, где не нужен постоянный уровень производительности, т. е. для тестирования или разработки.<br>Выберем для микросервиса следующий класс хоста: платформа — Intel Cascade Lake; тип — standard; конфигурация вычислительных ресурсов — s2.micro (два ядра vCPU, 8 ГБ RAM).<br>Хранилище данных. Хранилище БД может быть сетевым или локальным. В первом случае данные находятся на виртуальных дисках в инфраструктуре Yandex Cloud. Локальное хранилище — это диски, которые физически размещаются в серверах хостов БД.<br>При создании кластера можно выбирать между следующими типами хранилища:<br>- Стандартное сетевое (network-hdd) — это наиболее экономичный вариант. Выбирайте его, если к скорости записи и чтения нет особых требований.<br>- Быстрое сетевое (network-ssd) стоит примерно в четыре раза дороже, но при размере хранилища от 100 ГБ работает быстрее стандартного в десять и более раз (чем больше размер, тем заметнее разница в скорости).<br>- Сетевое на нереплицируемых SSD-дисках (network-ssd-nonreplicated) — использует сетевые SSD-диски с повышенной производительностью, реализованной за счет устранения избыточности. Объём такого хранилища можно увеличивать только с шагом 93 ГБ.<br>- Быстрое локальное (local-ssd) — самое быстрое и дорогое. Если локальный диск откажет, все сохранённые на нём данные будут потеряны. Чтобы этого избежать, при выборе локального хранилища сервис автоматически создаст отказоустойчивый кластер минимум из трёх хостов.<br>При создании кластера внимательно выбирайте тип хранилища. Размер хранилища можно будет позже изменить, а тип — нет.<br>Выберите для кластера стандартное сетевое хранилище network-hdd размером 50 ГБ.<br>База данных. В этом разделе настроек задаются атрибуты базы: Имя БД, уникальное в рамках кластера, Имя пользователя (владельца БД) и Пароль пользователя.<br>Сеть. Здесь можно выбрать облачную сеть для кластера и группы безопасности для его сетевого трафика.<br>Оставьте сеть по умолчанию (default) или выберите сеть, которую создали на предыдущем курсе. Кластер будет доступен для всех ВМ, которые подключены к вашей облачной сети.<br>Параметры хостов. В этом блоке можно добавить количество хостов, которые будут созданы вместе с кластером, и изменить их параметры. Дополнительные хосты могут понадобиться, например, для репликации БД или снижения нагрузки на хост-мастер.<br>Для наших целей достаточно кластера из одного хоста. Нажмите значок редактирования параметров хоста и в открывшемся окне выберите опцию Публичный доступ. Это означает, что к хосту можно будет подключиться из интернета, а не только из облачной сети. Остальные параметры оставьте без изменений.<br>Дополнительные настройки.Здесь можно: указать время Начала резервного копирования и Окна обслуживания. Это пригодится, если вы хотите, чтобы резервное копирование и техобслуживание хостов кластера не совпадали с периодами пиковых нагрузок на БД; разрешить Доступ из DataLens, если вы планируете анализировать в DataLens данные из базы. Подробнее о DataLens вы узнаете на одном из следующих занятий; разрешить Доступ из консоли управления, чтобы выполнять SQL-запросы к БД из консоли управления Yandex Cloud. Отметьте этот пункт: доступ из консоли понадобится нам на следующих практических работах; разрешить Доступ из Data Transfer, чтобы разрешить доступ к кластеру из сервиса Yandex Data Transfer в Serverless-режиме; разрешить Сбор статистики, чтобы воспользоваться инструментом Диагностика производительности в кластере; установить Защиту от удаления, чтобы защитить кластер от непреднамеренного удаления пользователем.<br>В этом блоке также можно задать настройки БД (например используемую сервером MySQL кодировку при работе с данными и обмене информацией с клиентами). По умолчанию при создании кластера сервис выбирает оптимальные настройки. Изменяйте их, если уверены, что это необходимо.<br>Настройка завершена. Осталось только нажать кнопку Создать кластер.<br>Создание кластера займёт несколько минут. Когда он будет готов к работе, его статус на панели Managed Service for MySQL сменится с Creating на Running, а состояние — на Alive.<br>Статус показывает, что происходит с кластером: Creating — создаётся; Running — работает; Error — не отвечает, возникла проблема; Updating — обновляется; Stopped — остановлен; Unknown — статус неизвестен (так может быть, например, когда кластер не виден из интернета).<br>Состояние — это показатель доступности кластера: Alive — все хосты кластера работают; Degraded — часть хостов (один или больше) не работает; Dead — все хосты не работают.<br><strong>Task:</strong><br>Подключение к БД и добавление данных<br>Доступ из консоли управления. В кластере, который вы создали, уже есть БД. Она пока пустая. Поскольку при создании кластера вы выбрали в настройках пункт Доступ из консоли управления, в консоли управления Yandex Cloud появилась вкладка с интерфейсом для выполнения SQL-запросов к БД.<br>Давайте зайдём туда и создадим в БД таблицу для нашего микросервиса.<br><strong>Decision:</strong><br>На странице Managed Service for MySQL выберите строку с созданным вами кластером. В панели консоли управления перейдите на вкладку SQL. Вам будет предложено выбрать БД для SQL-запросов и имя пользователя, а также ввести пароль. Все эти атрибуты вы задавали при создании  кластера.<br>Нажмите кнопку Подключиться. Откроется структура БД (сейчас там написано, что данных нет) и окно ввода для SQL-запросов.<br>Теперь создадим таблицу. Введите в окне ввода следующий запрос и нажмите кнопку Выполнить.<br>CREATE TABLE IF NOT EXISTS ratings (<br>&nbsp;&nbsp;rating_id INT AUTO_INCREMENT PRIMARY KEY,<br>&nbsp;&nbsp;user_id INT NOT NULL,<br>&nbsp;&nbsp;message_id INT NOT NULL,<br>&nbsp;&nbsp;rating INT NOT NULL<br>) ENGINE=INNODB; <br>Обратите внимание, что в качестве движка в сервисе управляемых БД MySQL используется только InnoDB.<br>В таблицу можно добавить данные с помощью команды INSERT.<br>INSERT INTO ratings (user_id,message_id,rating) VALUES (44,368,4); <br>Чтобы отобразить обновлённую структуру БД, нажмите на имя БД и выберите таблицу ratings.<br>Наведите указатель на заголовок столбца, чтобы увидеть тип данных в нём.<br>SQL-запросы через консоль управления Yandex Cloud — нетипичный способ работы с БД. Используйте его для небольших, разовых задач, когда быстрее и проще открыть подключение в браузере. Этот способ не очень удобен: текст запроса и результат его выполнения доступны, только пока вы не закрыли или не перезагрузили страницу в браузере. Конечно, если запрос успешно запущен, то сервис обработает его независимо от состояния консоли управления.<br>В консоли выводятся только первые 1000 строк результата запроса, даже если данных больше. Чтобы увидеть строку, введите её номер в поле Номер первой строки.<br>Подключение к кластеру<br>В основном вы будете работать с БД из приложений или из командной строки. Однако для этого нужно подключиться к хосту, на котором развёрнута БД.<br>Есть два варианта подключения. Если публичный доступ к хосту открыт, подключитесь к нему через интернет с помощью защищённого SSL-соединения. Если публичного доступа нет, подключитесь к хосту с виртуальной машины, созданной в той же виртуальной сети. SSL-соединение можно не использовать, но тогда трафик между виртуальной машиной и БД шифроваться не будет.<br>Давайте подключимся к БД через интернет и создадим в ней ещё одну таблицу. Для выполнения этого задания вы можете использовать виртуальную машину с Ubuntu.<br>Для создания таблицы сделаем в текстовом редакторе файл createTables.sql с командами. Например, такой:<br>CREATE TABLE IF NOT EXISTS users (<br>&nbsp;&nbsp;user_id INT AUTO_INCREMENT,<br>&nbsp;&nbsp;nickname VARCHAR(128) NOT NULL,<br>&nbsp;&nbsp;avatar VARCHAR(255),<br>&nbsp;&nbsp;mail VARCHAR(255),<br>&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY KEY (user_id)<br>) ENGINE=INNODB; <br>Чтобы выполнить этот запрос в БД, подключимся к хосту. Для этого понадобится SSL-сертификат. Команды для его получения в Ubuntu:<br>mkdir ~/.mysql<br>wget "https://storage.yandexcloud.net/cloud-certs/CA.pem" -O ~/.mysql/root.crt<br>chmod 0600 ~/.mysql/root.crt <br>Чтобы получить команды для подключения к БД, в консоли управления перейдите на страницу кластера, на вкладке Обзор нажмите кнопку Подключиться. В результате их выполнения в директории /home/&lt;домашняя_директория&gt;/.mysql/ сохранится SSL-сертификат root.crt.<br>Установите утилиту mysql-client, если на вашем компьютере или виртуальной машине её нет.<br>sudo apt update<br>sudo apt install -y mysql-client <br>Чтобы подключиться к БД, введите команду mysql. Для запуска нашего скрипта она выглядит следующим образом:<br>mysql --host=&lt;адрес хоста&gt; \<br>&nbsp;&nbsp;&nbsp;&nbsp;--port=3306 \<br>&nbsp;&nbsp;&nbsp;&nbsp;--ssl-ca=~/.mysql/root.crt \<br>&nbsp;&nbsp;&nbsp;&nbsp;--ssl-mode=VERIFY_IDENTITY \<br>&nbsp;&nbsp;&nbsp;&nbsp;--user=&lt;имя пользователя&gt; \<br>&nbsp;&nbsp;&nbsp;&nbsp;--password \<br>&nbsp;&nbsp;&lt;имя_базы_данных&gt; &lt; createTables.sql <br>Сервис помогает заполнить параметры в команде. Чтобы посмотреть пример команды с адресом хоста, именами пользователя и БД, в консоли управления перейдите на страницу кластера, на вкладке Обзор нажмите кнопку Подключиться.<br>После запуска команды введите пароль к БД, после чего в ней будет создана таблица users.<br>Если при создании кластера вы не включили публичный доступ, то к БД можно подключиться с виртуальной машины из той же облачной сети без использования шифрования. \\Следовательно, в этом случае в команде для подключения опускается параметр --ssl-ca, а --ssl-mode передаётся со значением DISABLED:<br>mysql --host=адрес_хоста \<br>&nbsp;&nbsp;  --port=3306 \<br>&nbsp;&nbsp;  --ssl-mode=DISABLED \<br>&nbsp;&nbsp;  --user=&lt;имя пользователя&gt; \<br>&nbsp;&nbsp;  --password \<br>&nbsp;&nbsp;  &lt;имя_базы_данных&gt; &lt; createTables.sql <br>Естественно, подключаться к БД можно не только из командной оболочки, но и из приложений. Нажмите уже знакомую вам кнопку Подключиться и посмотрите примеры кода для Python, PHP, Java, Node.js, Go, Ruby или настроек для драйвера ODBC.<br>Если вы хотите перенести БД в облако, то понадобится создать дамп и восстановить его в нужном кластере. Дамп — это копия БД или её части, представляющая собой текстовый файл с командами SQL (например, CREATE TABLE или INSERT). Его создают с помощью утилиты mysqldump.<br>Давайте попробуем перенести данные в кластер с помощью дампа. Для этого воспользуемся тестовой БД с данными о сотрудниках компании (имя, дата рождения, дата найма, место работы, зарплата и т. д.). Размер БД — около 167 Мб.<br>Скачайте из репозитория и сохраните на компьютере файлы с расширениями .sql и .dump. В файле employees.sql содержатся SQL команды, необходимые для создания таблиц и добавления в них данных из dump-файлов. Для переноса тестовой БД в облако понадобится запустить этот файл. Но, прежде чем приступить к переносу БД, откройте этот файл и удалите или закомментируйте (допишите в начало строки --) в нём строку 110. В этой строке расположена команда FLUSH LOGS, которая закрывает и снова открывает файлы журналов, а они в этой тестовой БД отсутствуют.<br>Создайте базу данных employees через консоль управления. Для этого на странице кластера перейдите на вкладку Базы данных и нажмите кнопку Добавить.<br>Добавьте пользователю, например user1, разрешение на доступ к БД employees. Для этого на странице кластера перейдите на вкладку Пользователи, напротив пользователя user1 нажмите кнопку ··· и выберите Настроить. Во всплывающем окне нажмите Добавить базу данных, выберите employees, добавьте роль ALL_PRIVILEGES и нажмите Сохранить.<br>Затем в командной строке перейдите в папку сохраненными файлами .sql и .dump и восстановите данные из дампа с помощью команды:<br>mysql --host=&lt;адрес хоста&gt; \<br>&nbsp;&nbsp;&nbsp;&nbsp;--port=3306 \<br>&nbsp;&nbsp;&nbsp;&nbsp;--ssl-ca=~/.mysql/root.crt \<br>&nbsp;&nbsp;&nbsp;&nbsp;--ssl-mode=VERIFY_IDENTITY \<br>&nbsp;&nbsp;&nbsp;&nbsp;--user=&lt;имя_пользователя&gt; \<br>&nbsp;&nbsp;&nbsp;&nbsp;--password \<br>&nbsp;&nbsp;employees &lt; ~/employees.sql <br>После того как данные скопируются, ваш кластер и БД будут готовы к работе. Подключитесь к БД в консоли управления и убедитесь, что данные перенесены.<br><strong>Decision:</strong><br>$ mkdir ~/.mysql<br>$ wget "https://storage.yandexcloud.net/cloud-certs/CA.pem" -O ~/.mysql/root.crt<br>$ chmod 0600 ~/.mysql/root.crt <br>$ sudo apt update<br>$ sudo apt install mysql-client <br>$ vim createTables.sql<br>$ cat createTables.sql<br>CREATE TABLE IF NOT EXISTS users (<br>&nbsp;&nbsp;user_id INT AUTO_INCREMENT,<br>&nbsp;&nbsp;nickname VARCHAR(128) NOT NULL,<br>&nbsp;&nbsp;avatar VARCHAR(255),<br>&nbsp;&nbsp;mail VARCHAR(255),<br>&nbsp;&nbsp;PRIMARY KEY (user_id)<br>) ENGINE=INNODB;<br>$ mysql --host=rc1a-642tdtv6ope6gk7u.mdb.yandexcloud.net \<br>&nbsp;&nbsp;  --port=3306 \<br>&nbsp;&nbsp;  --ssl-ca=~/.mysql/root.crt \<br>&nbsp;&nbsp;  --ssl-mode=VERIFY_IDENTITY \<br>&nbsp;&nbsp;  --user=tuser \<br>&nbsp;&nbsp;  --password \<br>&nbsp;&nbsp;  tdb &lt; createTables.sql <br>$ wget https://github.com/datacharmer/test_db/archive/refs/heads/master.zip<br>$ unzip master.zip<br>$ ls test_db-master/<br>Changelog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  employees.sql&nbsp;&nbsp;&nbsp;&nbsp;  load_dept_emp.dump&nbsp;&nbsp;  load_salaries1.dump  load_titles.dump  sakila&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_employees_md5.sql<br>employees_partitioned_5.1.sql  images&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; load_dept_manager.dump  load_salaries2.dump  objects.sql&nbsp;&nbsp;   show_elapsed.sql  test_employees_sha.sql<br>employees_partitioned.sql&nbsp;&nbsp;  load_departments.dump  load_employees.dump&nbsp;&nbsp; load_salaries3.dump  README.md&nbsp;&nbsp;&nbsp;&nbsp; sql_test.sh&nbsp;&nbsp;   test_versions.sh<br>$ cat test_db-master/employees.sql | grep flush<br>flush /*!50503 binary */ logs;<br>$ vim test_db-master/employees.sql<br>$ cat test_db-master/employees.sql | grep flush<br>$ cd test_db-master/<br>$ mysql --host=rc1a-642tdtv6ope6gk7u.mdb.yandexcloud.net \<br>&nbsp;&nbsp;  --port=3306 \<br>&nbsp;&nbsp;  --ssl-ca=~/.mysql/root.crt \<br>&nbsp;&nbsp;  --ssl-mode=VERIFY_IDENTITY \<br>&nbsp;&nbsp;  --user=tuser1 \<br>&nbsp;&nbsp;  --password \<br>&nbsp;&nbsp;  employees &lt; employees.sql <br>$ mysql --host=rc1a-642tdtv6ope6gk7u.mdb.yandexcloud.net \<br>&nbsp;&nbsp;  --port=3306 \<br>&nbsp;&nbsp;  --ssl-ca=~/.mysql/root.crt \<br>&nbsp;&nbsp;  --ssl-mode=VERIFY_IDENTITY \<br>&nbsp;&nbsp;  --user=tuser1 \<br>&nbsp;&nbsp;  --password \<br>&nbsp;&nbsp;  employees<br>mysql&gt; show tables;<br><strong>Task:</strong><br>Создание кластера базы данных PostgreSQL. <br>В этой практической работе вы создадите кластер еще одной управляемой БД, на этот раз PostgreSQL, подключитесь к ней и загрузите в нее данные. <br><strong>Decision:</strong><br>Создание кластера управляемой базы данных PostgreSQL аналогично созданию кластера базы данных MySQL.<br>Перейдите в сервис управляемых баз данных PostgreSQL и нажмите кнопку Создать кластер.<br>В появившемся окне настроек задайте необходимые параметры.<br>- Имя кластера и его описание. Выберите уникальное в облаке имя кластера. Описание опционально, поэтому можно оставить это поле пустым.<br>- В поле Окружение выберите PRODUCTION.<br>- Выберите версию PostgreSQL и класс хоста.<br>- Выберите размер и тип сетевого хранилища.<br>- Задайте атрибуты базы данных.<br>- Выберите из списка сеть, в которой будут находиться хосты кластера (для подключения потребуются публичные хосты).<br>- В блоке Хосты добавьте ещё два хоста в других зонах доступности для обеспечения отказоустойчивости кластера. База автоматически реплицируется.<br>- В блоке Дополнительные настройки задайте время начала резервного копирования и включите доступ из консоли управления.<br>- Нажмите кнопку Создать кластер.<br>Как и в случае с MySQL, к хостам кластера Managed Service for PostgreSQL можно подключиться двумя способами.<br>Через интернет. Если вы настроили публичный доступ для нужного хоста, то подключиться к нему можно с помощью SSL-соединения.<br>С виртуальных машин Yandex Cloud. Они должны быть расположены в той же облачной сети. Если к хосту нет публичного доступа, для подключения с таких виртуальных машин SSL-соединение использовать необязательно. Обратите внимание, что если публичный доступ в вашем кластере настроен только для некоторых хостов, автоматическая смена мастера может привести к тому, что вы не сможете подключиться к мастеру из интернета.<br>Установите клиент для подключения к БД PostgreSQL. Команда установки в Ubuntu: sudo apt update && sudo apt install -y postgresql-client <br>Скачайте сертификат для подключения к БД PostgreSQL:<br>mkdir -p ~/.postgresql<br>wget "https://storage.yandexcloud.net/cloud-certs/CA.pem" -O ~/.postgresql/root.crt <br>chmod 0600 ~/.postgresql/root.crt <br>Пример команды для подключения можно посмотреть в консоли управления, нажав на кнопку Подключиться на странице кластера. Подключение с SSL происходит при помощи следующей команды:<br>psql "host=&lt;FQDN_хоста&gt; \ <br>&nbsp;&nbsp;  port=6432 \<br>&nbsp;&nbsp;  sslmode=verify-full \<br>&nbsp;&nbsp;  dbname=&lt;имя базы данных&gt; \<br>&nbsp;&nbsp;  user=&lt;имя пользователя базы данных&gt; \<br>&nbsp;&nbsp;  target_session_attrs=read-write"<br>Загрузка данных в базу данных из CSV. Одним из способов добавления данных в базу является их загрузка из csv-файла.<br>Предположим, вы используете БД для организации работы транспортной службы интернет-магазина. Вам нужно добавить в базу таблицу, содержащую данные о расстояниях между складом и пунктами самовывоза, а также о стандартном времени доставки товаров со склада в эти пункты. Создадим csv-файл, например DTM.csv, который содержит такие данные (100 - код склада, 101-109 - коды пунктов, Time - стандартное время доставки в минутах, Distance - расстояние в километрах):<br>"depot","store","time","distance"<br>"100","101",31,12<br>"100","102",38,17<br>"100","103",56,33<br>"100","104",70,60<br>"100","105",41,25<br>"100","106",21,8<br>"100","107",33,14<br>"100","108",62,42<br>"100","109",45,29 <br>Важные моменты при миграции из CSV:<br>- Названия колонок в файле и в таблице необязательно совпадают.<br>- Файл содержит заголовок, который не нужно импортировать.<br>- Первые 2 колонки конвертируем из строк (string) в целые числа (int).<br>PostgreSQL позволяет импортировать данные из файла несколькими способами:<br>- Командой copy.<br>- Через функции pl/pgsql.<br>- Средствами другого языка, например Python.<br>Воспользуемся первым способом. Сначала нам понадобится создать таблицу, в которую будет осуществлена миграция данных. Подключитесь к БД согласно инструкциям выше. Выполните следующую команду:<br>CREATE TABLE dtm (<br>&nbsp;&nbsp;id serial PRIMARY KEY,<br>&nbsp;&nbsp;depot int NOT NULL,<br>&nbsp;&nbsp;store int  NOT NULL,<br>&nbsp;&nbsp;time int NOT NULL,<br>&nbsp;&nbsp;  distance int  NOT NULL<br>);<br>Загрузите данные: \copy dtm(depot,store,time,distance) from '/&lt;путь к файлу&gt;/DTM.csv' DELIMITERS ',' CSV HEADER;<br>В этой команде мы учли те моменты, о которых говорили вначале:<br>- dtm (depot, store, time, distance) маппинг колонок связывает колонки в файле с колонками в таблице, их имена могут не совпадать<br>- CSV HEADER показывает, что заголовок импортировать не нужно<br>- Колонки в таблице уже имеют правильные типы данных, конвертация будет выполнена автоматически.<br>В консоли управления на странице кластера перейдите на вкладку SQL. Введите пароль пользователя БД и нажмите кнопку Подключиться. Выберите таблицу dtm, чтобы убедиться, что добавление данных выполнено правильно.<br><strong>Decision:</strong><br>$ sudo apt update && sudo apt install postgresql-client<br>$ mkdir -p ~/.postgresql<br>$ wget "https://storage.yandexcloud.net/cloud-certs/CA.pem" -O ~/.postgresql/root.crt<br>$ chmod 0600 ~/.postgresql/root.crt<br>$ vim DTM.csv<br>$ cat DTM.csv<br>"deport","store","time","distance"<br>"100","101",31,12<br>"100","102",38,17<br>"100","103",56,33<br>"100","104",70,60<br>"100","105",41,25<br>"100","106",21,8<br>"100","107",33,14<br>"100","108",62,42<br>"100","109",45,29<br>$ psql "host=rc1a-w3usdays081v0itf.mdb.yandexcloud.net,rc1c-qga7rd1sqe5jm8io.mdb.yandexcloud.net,rc1d-l1vzj1210qj68s8n.mdb.yandexcloud.net \<br>&nbsp;&nbsp;port=6432 \<br>&nbsp;&nbsp;sslmode=verify-full \<br>&nbsp;&nbsp;dbname=YOUR-DB \<br>&nbsp;&nbsp;user=YOUR-USERNAME \<br>&nbsp;&nbsp;target_session_attrs=read-write"<br>YOUR-DB=&gt; CREATE TABLE dtm (<br>YOUR-DB(&gt;&nbsp;&nbsp; id serial PRIMARY KEY,<br>YOUR-DB(&gt;&nbsp;&nbsp; depot int NOT NULL,<br>YOUR-DB(&gt;&nbsp;&nbsp; store int  NOT NULL,<br>YOUR-DB(&gt;&nbsp;&nbsp; time int NOT NULL,<br>YOUR-DB(&gt;&nbsp;&nbsp; distance int  NOT NULL<br>YOUR-DB(&gt; );<br>YOUR-DB=&gt; \copy dtm(depot,store,time,distance) from '/home/test/DTM.csv' DELIMITERS ',' CSV HEADER;<br>YOUR-DB=&gt; exit<br><strong>Task:</strong><br>Создание кластера MongoDB. <br>На этом уроке вы создадите кластер MongoDB, подключитесь к нему и загрузите в него данные. <br>Раньше вы работали только с реляционными БД, но использование кластера MongoDB принципиально не отличается от работы с кластером MySQL или PostgreSQL, так что многое будет вам знакомо.<br><strong>Decision:</strong><br>Выберите в консоли управления Yandex Cloud каталог для кластера БД. На дашборде каталога откройте раздел Managed Service for MongoDB. В открывшемся окне нажмите кнопку Создать кластер.<br>Установите основные настройки кластера. Для этого урока создайте кластер с минимальной конфигурацией: тип хоста burstable, класс b2.nano, стандартное сетевое хранилище размером 10 ГБ. Откройте публичный доступ к хосту и задайте пароль пользователя БД. Остальные значения оставьте по умолчанию.<br>В сервисе управляемых БД MongoDB к хостам можно подключаться через интернет или с виртуальных машин в той же сети. Порт для подключения — 27018.<br>Для подключения через интернет хосты кластера должны находиться в публичном доступе. Подключаться можно только через зашифрованное соединение.<br>Обратите внимание: если публичный доступ настроен только для некоторых хостов в кластере, то при автоматической смене основной реплики она может оказаться недоступной из интернета.<br>Если к хосту нет публичного доступа и вы подключаетесь к нему с виртуальных машин Yandex Cloud, то зашифрованное соединение необязательно.<br>Подключитесь к созданной БД из интернета. Используйте SSL-сертификат, который вы подготовили на одной из предыдущих практических работ, или команду (для Ubuntu):<br>sudo mkdir -p /usr/local/share/ca-certificates/Yandex && \<br>sudo wget "https://storage.yandexcloud.net/cloud-certs/CA.pem" -O /usr/local/share/ca-certificates/Yandex/YandexInternalRootCA.crt <br>Если всё пройдет успешно — вы получите сообщение операционной системы о том, что сертификат сохранён.<br>Установите утилиту Mongo Shell:<br>sudo apt install mongodb-clients <br>Подключитесь к БД с помощью команды mongo. Чтобы получить строку подключения, на основной странице сервиса в консоли управления выберите кластер, на вкладке Обзор нажмите кнопку Подключиться.<br>Сервис сформирует пример строки подключения для кластера. Там же вы можете посмотреть примеры кода на Python, PHP, Java, Node.js, Go для подключения из приложений.<br>Подключитесь к кластеру из командной строки.<br>mongo --norc \<br>&nbsp;&nbsp;&nbsp;&nbsp;--ssl \<br>&nbsp;&nbsp;&nbsp;&nbsp;--sslCAFile /usr/local/share/ca-certificates/Yandex/YandexInternalRootCA.crt \<br>&nbsp;&nbsp;&nbsp;&nbsp;--host '&lt;FQDN хоста MongoDB&gt;:27018' \<br>&nbsp;&nbsp;&nbsp;&nbsp;-u &lt;имя пользователя БД&gt; \<br>&nbsp;&nbsp;&nbsp;&nbsp;-p &lt;пароль пользователя БД&gt; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;имя БД&gt; <br>Создадим в БД коллекцию users. Предположим, в ней содержится информация о пользователях вашего приложения.<br>db.createCollection("users") <br>Загрузим в коллекцию тестовые данные с помощью методов добавления одного документа db.insertOne(...) и сразу нескольких db.insertMany(...).<br>Сначала добавим один документ (данные одного пользователя).<br>db.users.insertOne({firstName: "Adam", lastName: "Smith", age: 37, email: "adam.smith@test.com"}); <br>Дополним коллекцию данными еще двух пользователей.<br>db.users.insertMany( [<br>&nbsp;&nbsp;  {firstName: "Viktoria", lastName: "Holmes", age: 73, email: "viktoria.holmes@test.com", phone: "737772727"},<br>&nbsp;&nbsp;  {firstName: "Tina", lastName: "Anders", age: 29, email: "tina.anders@test.com", children: [{firstName: "Sam", lastName: "Anders"},{firstName: "Anna", lastName: "Anders"}]}<br>  ] ); <br>Обратите внимание, что документы в коллекции users содержат разный набор данных. С помощью MongoDB мы можем работать с данными, структура которых частично не совпадает.<br>Теперь посмотрим на содержимое коллекции с помощью команды db.users.find(). Результат показывает, что все данные успешно добавлены:<br>Проверим, есть ли среди пользователей те, кому больше 37 лет. Сделаем запрос к БД с помощью метода find.<br>db.users.find({age: {$gt: 37}}); <br><strong>Decision:</strong><br>$ sudo mkdir -p /usr/local/share/ca-certificates/Yandex && \<br>sudo wget "https://storage.yandexcloud.net/cloud-certs/CA.pem" -O /usr/local/share/ca-certificates/Yandex/YandexInternalRootCA.crt<br>$ wget https://downloads.mongodb.com/linux/mongodb-linux-x86_64-enterprise-ubuntu2004-6.0.2.tgz<br>$ tar -zxvf mongodb-linux-x86_64-enterprise-ubuntu2004-6.0.2.tgz<br>$ sudo ln -s /path/to/the/mongodb-directory/bin/* /usr/local/bin/<br>$ sudo apt install mongodb-clients<br>$ mongo --norc \<br>&nbsp;&nbsp;&nbsp;&nbsp;--ssl \<br>&nbsp;&nbsp;&nbsp;&nbsp;--sslCAFile /usr/local/share/ca-certificates/Yandex/YandexInternalRootCA.crt \<br>&nbsp;&nbsp;&nbsp;&nbsp;--host 'rs01/rc1b-b7xwau9lvu3hdt0w.mdb.yandexcloud.net:27018' \<br>&nbsp;&nbsp;&nbsp;&nbsp;-u YOUR-USERNAME \<br>&nbsp;&nbsp;&nbsp;&nbsp;-p YOUR-PASSWORD \<br>&nbsp;&nbsp;&nbsp;&nbsp;YOUR-DB<br>rs01:PRIMARY&gt; db.createCollection("users")<br>rs01:PRIMARY&gt; db.users.insertOne({firstName: "Adam", lastName: "Smith", age: 37, email: "adam.smith@test.com"});<br>rs01:PRIMARY&gt; db.users.insertMany( [<br>&nbsp;&nbsp;  {firstName: "Viktoria", lastName: "Holmes", age: 73, email: "viktoria.holmes@test.com", phone: "737772727"},<br>&nbsp;&nbsp;  {firstName: "Tina", lastName: "Anders", age: 29, email: "tina.anders@test.com", children: [{firstName: "Sam", lastName: "Anders"},{firstName: "Anna", lastName: "Anders"}]}<br>  ] );<br>rs01:PRIMARY&gt; db.users.find({age: {$gt: 37}});<br><strong>Task:</strong><br>Создание кластера ClickHouse и подключение к нему.<br>В этой практической работе вы создадите кластер ClickHouse. Вы уже знаете, как создавать кластеры и выставлять их основные настройки в сервисах платформы данных. Но у БД ClickHouse есть свои особенности.<br>Когда вы создадите кластер из двух или более хостов, сервис дополнительно создаст ещё один кластер из трёх хостов, где развернёт Apache ZooKeeper. Это служба для распределенных систем, которая управляет конфигурацией, репликацией и распределением запросов по хостам БД. Без неё кластер ClickHouse работать не будет. К ZooKeeper у пользователей доступа нет, однако его хосты учитываются при расчёте квоты ресурсов облака и стоимости сервиса.<br>ZooKeeper синхронизирует шарды (т. е. хосты) ClickHouse. В отличие от классических реляционных БД, у ClickHouse нет главного узла (мастера), через который добавляются данные. В ClickHouse данные можно и записывать, и читать с любого узла.<br><strong>Decision:</strong><br>Перейдите в каталог, где нужно создать кластер БД, выберите Managed Service for ClickHouse и нажмите кнопку Создать кластер.<br>Для практической работы нам понадобится кластер с минимальной конфигурацией: тип хоста burstable, класс b2.nano и стандартное сетевое хранилище размером 10 ГБ.<br>Задайте настройки: введите имена для кластера и БД, а также имя и пароль пользователя. Откройте публичный доступ к хосту.<br>Обратите внимание: в отличие от сервисов, которые мы уже рассматривали, здесь в разделе База данных можно включить опции управления пользователями и БД с помощью SQL-запросов.<br>Кроме того, в дополнительных настройках можно включить доступ к БД из консоли управления, сервисов DataLens, Яндекс Метрики и AppMetrica, а также возможность использовать бессерверные вычисления (подробно о них мы расскажем на курсе «Serverless»). С помощью DataLens, например, вы визуализируете результаты поисковых запросов в виде графиков, диаграмм и дашбордов, а подключение AppMetrica позволит импортировать данные из этого сервиса в кластер.<br>Отметьте пункт Доступ из DataLens: он понадобится вам на одном из следующих уроков. Нажмите кнопку Создать кластер.<br>К хостам кластера ClickHouse можно подключаться через интернет или с виртуальных машин в той же виртуальной сети. Если к хостам БД открыт публичный доступ, то для подключения к ним используется шифрованное соединение.<br>Подключайтесь к кластеру с помощью HTTP-протокола или более низкоуровневого Native TCP-протокола. В большинстве случаев рекомендуется взаимодействовать с ClickHouse не напрямую, а с помощью инструмента или библиотеки. Официально поддерживаются консольный клиент, драйверы JDBC и ODBC, клиентская библиотека для C++. Также можно использовать библиотеки сторонних разработчиков для Python, PHP, Go, Ruby и т. д.<br>Примеры строк подключения приводятся в документации и консоли управления на вкладке Обзор страницы кластера.<br>С БД удобно работать в приложении с графическим интерфейсом. Один из вариантов — универсальный клиент DBeaver. Другие варианты вы найдёте в полном списке клиентов.<br>Подробная информация о настройке подключения приведена в документации. Чтобы создать подключение к ClickHouse в DBeaver, помимо обычных параметров (адреса хоста, порта, имени БД, логина и пароля) задайте на вкладке Свойства драйвера настройки свойств драйвера JDBC. Укажите следующие параметры: ssl = true; sslmode = strict; sslrootcert = &lt;путь к SSL-сертификату&gt;. Как получить SSL-сертификат, вы уже узнали на предыдущих уроках.<br>При подключении DBeaver покажет номер версии ClickHouse и пинг до хоста.<br>В двух следующих практических работах мы используем кластер для аналитической работы с датасетами и для создания БД ClickHouse.<br><strong>Decision:</strong><br>$ wget https://dbeaver.io/files/dbeaver-ce_latest_amd64.deb<br>$ sudo dpkg -i dbeaver-ce_latest_amd64.deb<br>$ dbeaver-ce &<br>$ mkdir -p ~/.clickhouse-client<br>$ sudo wget "https://storage.yandexcloud.net/mdb/clickhouse-client.conf.example" -O ~/.clickhouse-client/config.xml<br>$ sudo apt-get install -y apt-transport-https ca-certificates dirmngr<br>$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 8919F6BD2B48D754<br>$ echo "deb https://packages.clickhouse.com/deb stable main" | sudo tee \<br>&nbsp;&nbsp;/etc/apt/sources.list.d/clickhouse.list<br>$ sudo apt-get update<br>$ sudo apt-get install -y clickhouse-server clickhouse-client<br>$ clickhouse-client --host rc1a-mg8yquor7pspcwkc.mdb.yandexcloud.net \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  --secure \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  --user YOUR-USERNAME \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  --database YOUR-DB \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  --port 9440 \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  --ask-password<br><strong>Task:</strong><br>Работа с данными из объектного хранилища.<br>В интернете выложено множество датасетов —  структурированных наборов данных, связанных общей темой. Например в репозитории проекта Our World in Data находится около тысячи разнообразных датасетов: от численности населения государств до сведений об употреблении алкоголя в США с 1850 года.<br>Датасеты часто выкладывают в виде CSV- или TSV-файлов. В них значения разделены запятой (comma separated values, CSV) или табуляцией (tab separated values, TSV).<br>Сохраняйте датасеты в объектное хранилище и анализируйте данные с помощью ClickHouse. При этом не требуется создавать БД и копировать в неё данные из датасета. Отправляйте запросы к ClickHouse — а ClickHouse сходит за данными напрямую в объектное хранилище.<br><strong>Decision:</strong><br>В качестве примера возьмем датасет с историей метеонаблюдений за 10 лет и попробуем развеять мифы о разнице погоды в Москве и Санкт-Петербурге. Датасет содержит примерно 50 тысяч записей, он выложен в объектном хранилище Yandex Cloud и доступен всем.<br>Воспользуемся кластером БД, который мы создали на предыдущем уроке. Откройте его в консоли управления. Запросы к датасету будем делать через SQL-консоль. На панели слева выберите вкладку SQL и введите пароль пользователя. В правом поле открывшейся консоли мы и станем вводить SQL-запросы.<br>Как вы думаете, где зарегистрирована самая низкая температура? Наверняка в Санкт-Петербурге! Давайте проверим.<br>Выполните запрос:<br>SELECT<br>&nbsp;&nbsp;City,<br>&nbsp;&nbsp;LocalDate,<br>&nbsp;&nbsp;TempC<br>FROM s3(<br>&nbsp;&nbsp;&nbsp;&nbsp;'https://storage.yandexcloud.net/arhipov/weather_data.tsv',<br>&nbsp;&nbsp;&nbsp;&nbsp;'TSV',<br>&nbsp;&nbsp;&nbsp;&nbsp;'LocalDateTime DateTime, LocalDate Date, Month Int8, Day Int8, TempC Float32,Pressure Float32, RelHumidity Int32, WindSpeed10MinAvg Int32, VisibilityKm Float32, City String')<br>ORDER BY TempC ASC<br>LIMIT 1 <br>Всё-таки наши интуитивные представления не всегда верны и могут опровергаться данными.<br>А что насчет самой высокой температуры, скорости ветра и влажности? Проверьте сами, изменив поля в запросе (средняя скорость ветра за 10 минут — WindSpeed10MinAvg, относительная влажность — RelHumidity; сортировка по возрастанию — ASC, по убыванию — DESC). Увеличив количество выводимых данных, вы получите более точное представление (измените параметр LIMIT c 1 до 10).<br>Но это были крайние значения. Давайте проверим, насколько в этих городах отличается климат в целом. Узнаем, например, разницу среднегодовых температур.<br>SELECT<br>&nbsp;&nbsp;Year,<br>&nbsp;&nbsp;msk.t - spb.t<br>FROM<br>(<br>&nbsp;&nbsp;SELECT<br>&nbsp;&nbsp;&nbsp;&nbsp;toYear(LocalDate) AS Year,<br>&nbsp;&nbsp;&nbsp;&nbsp;avg(TempC) AS t<br>&nbsp;&nbsp;FROM s3(<br>&nbsp;&nbsp;&nbsp;&nbsp;'https://storage.yandexcloud.net/arhipov/weather_data.tsv',<br>&nbsp;&nbsp;&nbsp;&nbsp;'TSV',<br>&nbsp;&nbsp;&nbsp;&nbsp;'LocalDateTime DateTime, LocalDate Date, Month Int8, Day Int8, TempC Float32,Pressure Float32, RelHumidity Int32, WindSpeed10MinAvg Int32, VisibilityKm Float32, City String')<br>&nbsp;&nbsp;WHERE City = 'Moscow'<br>&nbsp;&nbsp;GROUP BY Year<br>&nbsp;&nbsp;ORDER BY Year ASC<br>) AS msk<br>INNER JOIN<br>(<br>&nbsp;&nbsp;SELECT<br>&nbsp;&nbsp;&nbsp;&nbsp;toYear(LocalDate) AS Year,<br>&nbsp;&nbsp;&nbsp;&nbsp;avg(TempC) AS t<br>&nbsp;&nbsp;FROM s3(<br>&nbsp;&nbsp;&nbsp;&nbsp;'https://storage.yandexcloud.net/arhipov/weather_data.tsv',<br>&nbsp;&nbsp;&nbsp;&nbsp;'TSV',<br>&nbsp;&nbsp;&nbsp;&nbsp;'LocalDateTime DateTime, LocalDate Date, Month Int8, Day Int8, TempC Float32,Pressure Float32, RelHumidity Int32, WindSpeed10MinAvg Int32, VisibilityKm Float32, City String')<br>&nbsp;&nbsp;WHERE City = 'Saint-Petersburg'<br>&nbsp;&nbsp;GROUP BY Year<br>&nbsp;&nbsp;ORDER BY Year ASC<br>) AS spb ON msk.Year = spb.Year <br>Измените поля в запросе, чтобы проверить разницу относительной влажности.<br>Давайте теперь рассчитаем, где раньше начинается лето. Будем считать началом лета день, начиная с которого температура поднималась выше +15 °С хотя бы пять раз в течение 10-дневного периода (864 тысячи секунд).<br>SELECT<br>&nbsp;&nbsp;City,<br>&nbsp;&nbsp;toYear(LocalDate) AS year,<br>&nbsp;&nbsp;MIN(LocalDate)<br>FROM<br>(<br>&nbsp;&nbsp;SELECT<br>&nbsp;&nbsp;&nbsp;&nbsp;City,<br>&nbsp;&nbsp;&nbsp;&nbsp;LocalDate,<br>&nbsp;&nbsp;&nbsp;&nbsp;windowFunnel(864000)(LocalDateTime, TempC &gt;= 15, TempC &gt;= 15, TempC &gt;= 15, TempC &gt;= 15, TempC &gt;= 15) AS warmdays<br>&nbsp;&nbsp;FROM s3(<br>&nbsp;&nbsp;&nbsp;&nbsp;'https://storage.yandexcloud.net/arhipov/weather_data.tsv',<br>&nbsp;&nbsp;&nbsp;&nbsp;'TSV',<br>&nbsp;&nbsp;&nbsp;&nbsp;'LocalDateTime DateTime, LocalDate Date, Month Int8, Day Int8, TempC Float32,Pressure Float32, RelHumidity Int32, WindSpeed10MinAvg Int32, VisibilityKm Float32, City String')<br>&nbsp;&nbsp;GROUP BY<br>&nbsp;&nbsp;&nbsp;&nbsp;City,<br>&nbsp;&nbsp;&nbsp;&nbsp;LocalDate<br>)<br>WHERE warmdays = 5<br>GROUP BY<br>&nbsp;&nbsp;year,<br>&nbsp;&nbsp;City<br>ORDER BY<br>&nbsp;&nbsp;year ASC,<br>&nbsp;&nbsp;City ASC <br><strong>Task:</strong><br>Добавление данных. <br>Предположим, вы работаете в метеорологической службе и постоянно изучаете датасеты с погодными данными. <br>Сбор данных о погоде автоматизирован: на территории области расположены несколько десятков пунктов наблюдения с датчиками. <br>Информация о температуре, давлении, влажности и скорости ветра раз в полчаса передаётся с датчиков на центральный сервер. <br>Приложение на сервере обрабатывает данные, переводит их в нужный формат и записывает в файл. Каждый файл содержит данные за три часа наблюдений. <br>Для прогноза нужно учитывать всю историю наблюдений за последние несколько лет, то есть все файлы потребуется собрать в одну БД.<br>Давайте потренируемся добавлять данные из файлов в БД ClickHouse.<br>На предыдущих уроках мы создали кластер, на котором развёрнута БД, и научились подключаться к нему. <br>Продолжим работать с этой БД, а в качестве добавляемого файла возьмем уже известный вам датасет с данными о погоде в Москве и Санкт-Петербурге.<br><strong>Decision:</strong><br>Сохраните файл на компьютере.<br>Прежде чем добавлять файл в БД, создадим в ней таблицу, куда будут вставляться данные. Перейдите в SQL-консоль кластера и выполните команду:<br>CREATE TABLE &lt;имя вашей БД&gt;.Weather<br>(  LocalDateTime DateTime,<br>  LocalDate Date,<br>  Month Int8,<br>  Day Int8,<br>  TempC Float32,<br>  Pressure Float32,<br>  RelHumidity Int32,<br>  WindSpeed10MinAvg Int32,<br>  VisibilityKm Float32,<br>  City String<br>) ENGINE=MergeTree<br>ORDER BY LocalDateTime; <br>В результате будет создана пустая таблица с полями и типами данных, соответствующими полям и типам данных в нашем файле (датасете).<br>Вставим данные в таблицу с помощью клиента командной строки clickhouse-client. Команды для его установки (для Ubuntu):<br>sudo apt update && sudo apt install --yes apt-transport-https ca-certificates dirmngr && \<br>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv E0C56BD4 && \<br>echo "deb https://repo.clickhouse.com/deb/stable/ main/" | sudo tee \<br>/etc/apt/sources.list.d/clickhouse.list<br>sudo apt update && sudo apt install --yes clickhouse-client<br>mkdir --parents ~/.clickhouse-client && \<br>wget "https://storage.yandexcloud.net/mdb/clickhouse-client.conf.example" \<br>--output-document ~/.clickhouse-client/config.xml <br>Подробности о том, как установить клиент и работать с ним, вы найдёте в документации ClickHouse.<br>Подключитесь к кластеру. Пример строки подключения посмотрите в консоли управления.<br>Добавим файл с данными в БД с помощью команды:<br>cat weather_data.tsv | clickhouse-client \<br>--host &lt;адрес вашей БД&gt; \<br>--secure \<br>--user user1 \<br>--database db1 \<br>--port 9440 \<br>-q "INSERT INTO db1.Weather FORMAT TabSeparated" \<br>--ask-password <br>Переключившись в SQL-консоль, вы увидите, что данные появились в таблице.<br>Данные в БД можно загружать и другими способами: из приложений или клиентов с графическим интерфейсом (например DBeaver). В этом случае подключение к БД и передача данных будут идти по HTTP-протоколу через порт 8443.<br>Теперь вы можете анализировать 10-летний срез данных о погоде в Москве и Санкт-Петербурге непосредственно в ClickHouse, без обращений к внешним источникам. Попробуйте, например, выяснить, какой день был самым ветреным в этих городах.<br>После практической работы остановите кластер, но не удаляйте его. Кластер ещё понадобится, когда мы будем рассматривать сервис визуализации и анализа данных Yandex DataLens.<br><strong>Decision:</strong><br>$ wget https://storage.yandexcloud.net/arhipov/weather_data.tsv<br>$ cat weather_data.tsv | clickhouse-client \<br>--host YOUR-IP \<br>--secure \<br>--user YOUR-USERNAME \<br>--database YOUR-DB \<br>--port 9440 \<br>-q "INSERT INTO YOUR-DB.Weather FORMAT TabSeparated" \<br>--ask-password<br><strong>Task:</strong><br>Создание базы данных. <br>В этой практической работе вы создадите БД YDB в dedicated режиме, научитесь подключаться к ней и добавлять данные из тестового приложения.<br>Также вы подключитесь к БД и запустите тестовое приложение, чтобы создать в ней несколько таблиц с данными о популярных сериалах.<br><strong>Decision:</strong><br>На стартовой странице консоли управления перейдите в каталог, в котором будете создавать БД, выберите в списке сервисов База данных YDB и нажмите кнопку Создать ресурс.<br>В открывшемся окне выберите тип БД dedicated. Появившийся интерфейс создания новой БД практически идентичен уже знакомым вам интерфейсам создания кластеров управляемых БД.<br>Выберите для вашей БД имя, назначьте необходимые вычислительные ресурсы (для этой и следующих практических работ достаточно одного хоста конфигурации medium), тип и количество групп хранения (достаточно одной группы).<br>Группа хранения – это массив независимых дисковых накопителей, объединённых по сети в единый логический элемент. В YDB такой массив состоит из 9 дисков, расположенных по три в каждой из трёх зон доступности. Такая конфигурация обеспечивает устойчивость при одновременном отказе одной из зон и отказе диска в другой зоне. Стандартный размер группы хранения — 100 ГБ.<br>Выберите облачную сеть и подсети для работы с БД. Вы можете оставить сеть по умолчанию или выбрать ту, которую создали на предыдущем курсе. БД будет доступна для всех виртуальных машин, которые подключены к той же облачной сети.<br>Также выберите опцию присвоения публичного IP-адреса, чтобы иметь возможность подключаться к БД из интернета.Нажмите кнопку Создать базу данных. Создание БД занимает несколько минут. Когда статус БД изменится с Provisioning на Running, она готова к работе. Кликнув на созданную БД в консоли управления, вы перейдёте на вкладку Обзор.<br>В разделе Соединение на этой странице приведена информация, которая вам понадобится для подключения к БД:<br>- Эндпоинт — точка подключения с указанием протокола, представляющая собой в данном случае адрес, на который посылаются сообщения;<br>- Размещение базы данных — полный путь к БД.<br>- Примеры подключений из командной строки и приложений вы можете посмотреть, нажав на кнопку Подключиться.<br>Подключение к базе данных и запуск тестового приложения. <br>Для того, чтобы выполнить эту задачу, вам понадобится сервисный аккаунт с ролями viewer и editor. Перейдите в дашборд каталога и выберите вкладку Сервисные аккаунты. Создайте сервисный аккаунт, назначив для него указанные роли. Сохраните идентификатор этого аккаунта.<br>Вы можете запускать тестовое приложение со своего компьютера или с виртуальной машины в Yandex Cloud. В данном примере используется OC Ubuntu и приложение на Python.<br>Если при создании БД вы не присвоили ей публичный IP-адрес, то подключиться к ней вы сможете только с виртуальной машины, расположенной в той же облачной сети.<br>Для запуска приложения нужно склонировать на свою машину репозиторий YDB Python SDK, из которого оно будет вызываться, а также установить библиотеки ydb, iso8601 и yandexcloud. Воспользуйтесь для этого следующими командами:<br>git clone https://github.com/yandex-cloud/ydb-python-sdk.git<br>sudo pip3 install iso8601 ydb yandexcloud <br>Создайте авторизованный ключ для вашего сервисного аккаунта и сохраните его в файл с помощью интерфейса командной строки Yandex Cloud.<br>mkdir ~/.ydb<br>yc iam key create \<br>  --folder-id &lt;идентификатор каталога&gt; \<br>  --service-account-name &lt;имя сервисного аккаунта&gt; \<br>  --output ~/.ydb/sa_name.json <br>&nbsp;&nbsp;Получите SSL-сертификат:<br>wget "https://storage.yandexcloud.net/cloud-certs/CA.pem" \<br>  -O ~/.ydb/CA.pem <br>Установите переменную окружения YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS и переменную окружения с SSL-сертификатом.<br>export YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS=~/.ydb/sa_name.json<br>export YDB_SSL_ROOT_CERTIFICATES_FILE=~/.ydb/CA.pem <br>&nbsp;&nbsp;Запустите тестовое приложение basic_example_v1 из репозитория ydb-python-sdk, указав в качестве параметров подключения значения протокола, эндпоинта и полного пути к БД.<br>cd ./ydb-python-sdk/examples/basic_example_v1<br>python3 __main__.py \<br>-e &lt;Эндпоинт&gt; \<br>-d &lt;Размещение базы данных&gt; <br>Результат выполнения приложения должен выглядеть так:<br>&gt; describe table: series<br>column, name: series_id , Uint64<br>column, name: title , Utf8<br>column, name: series_info , Utf8<br>column, name: release_date , Uint64<br>&gt; select_simple_transaction:<br>series, id:  1 , title:  IT Crowd , release date:  b'2006-02-03'<br>&gt; bulk upsert: episodes<br>&gt; select_prepared_transaction:<br>episode title: To Build a Better Beta , air date: b'2016-06-05'<br>&gt; select_prepared_transaction:<br>episode title: Bachman's Earnings Over-Ride , air date: b'2016-06-12'<br>&gt; explicit TCL call<br>&gt; select_prepared_transaction:<br>episode title: TBD , air date: b'2022-08-24' <br>Вернитесь в консоль управления Yandex Cloud, чтобы посмотреть на результаты работы приложения. Переключитесь на вкладку Навигация.<br>В вашей БД созданы три таблицы: episodes, seasons и series с информацией о двух популярных сериалах IT Crowd и Silicon Valley. Кликнув по названию таблицы, вы увидите содержащиеся в ней данные. А если подвести к названию таблицы курсор и кликнуть на значок «информация» справа, то внизу появится дополнительное окно с вкладками Обзор, Схема и Партиции.<br>Кнопка Создать на панели Навигация служит для создания директорий и таблиц. С её помощью можно создать новую таблицу, не прибегая к командам YQL.<br><strong>Decision:</strong><br>$ git clone https://github.com/yandex-cloud/ydb-python-sdk.git<br>$ mkdir ~/.ydb<br>$ yc iam key create \<br>--service-account-name sa-ydb \<br>--output ~/.ydb/authorized_key.json <br>$ export YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS=~/.ydb/authorized_key.json<br>$ cd ydb-python-sdk/examples/basic_example_v1<br>$ python3 __main__.py \<br>-e &lt;Эндпоинт&gt; \<br>-d &lt;Размещение базы данных&gt; <br><strong>Task:</strong><br>YQL и работа с данными<br>В этом уроке вы освоите базовый набор операций для работы с данными с использованием YQL и консоли управления Yandex.Cloud. <br><strong>Decision:</strong><br>Чтобы начать, войдите в раздел Навигация консоли управления и откройте редактор SQL, нажав на кнопку SQL-запрос.<br>На прошлом уроке мы уже создали в нашей БД три таблицы, содержащие информацию о сериалах IT Crowd и Silicon Valley.<br>Добавим в БД еще одну таблицу с рейтингами эпизодов сериала IT Crowd на IMDb.com.<br>YQL является диалектом SQL, поэтому многие инструкции в этих языках идентичны.<br>Для создания таблицы вам понадобится сделать запрос к БД, содержащий инструкцию CREATE TABLE. Например, если бы мы хотели создать таблицу seasons (она уже есть в вашей БД), то SQL запрос выглядел бы следующим образом:<br>CREATE TABLE seasons<br>(<br>&nbsp;&nbsp;series_id Uint64, <br>&nbsp;&nbsp;season_id Uint64, <br>&nbsp;&nbsp;first_aired Date, <br>&nbsp;&nbsp;last_aired Date, <br>&nbsp;&nbsp;title Utf8, <br>&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY KEY (series_id, season_id)<br>); <br>Обратите внимание, что в пределах директории YDB имена таблиц должны быть уникальны. Первичный ключ (PRIMARY KEY) — это столбец или комбинация столбцов, однозначно идентифицирующих каждую строку в таблице. Он может содержать только неповторяющиеся значения. Для таблицы YDB указание первичного ключа обязательно, при этом он может быть только один.<br>Первичный ключ по сути является первичным индексом, который помогает СУБД быстрее обнаруживать отдельные записи в таблице и сокращает время выполнения запросов. Также в таблицу можно добавить один или несколько вторичных индексов. Они служат той же цели, но в отличие от первичного индекса могут содержать повторяющиеся значения. Добавить вторичные индексы можно в любой момент, когда возникнет необходимость, и это не вызовет деградацию производительности БД. Чтобы при создании таблицы добавить в нее вторичный индекс, используется такая конструкция:<br>INDEX &lt;имя индекса&gt; GLOBAL ON (&lt;имя столбца1&gt;, &lt;имя столбца2&gt;, ...) <br>Вторичный индекс можно добавить и в уже существующую таблицу. Работа БД при этом не прерывается. В отличие от предыдущего случая в существующую таблицу можно добавлять только один вторичный индекс за раз. Делается это с помощью следующей команды:<br>ALTER TABLE &lt;имя таблицы&gt; ADD INDEX &lt;имя индекса&gt; GLOBAL ON (&lt;имя столбца&gt;); <br><strong>Task:</strong><br>создайте таблицу ratings, в которой будут содержаться рейтинги всех эпизодов сериала IT Crowd, со столбцами season_id (Uint64), episodes_id (Uint64), title (Utf8), air_date (Date) и imdb_rating (Uint64) и вторичным индексом rating_index по полю imdb_rating.<br><strong>Decision:</strong><br>CREATE TABLE ratings (<br>&nbsp;&nbsp;season_id Uint64, <br>&nbsp;&nbsp;episodes_id Uint64, <br>&nbsp;&nbsp;title Utf8, <br>&nbsp;&nbsp;air_date Date, <br>&nbsp;&nbsp;imdb_rating Uint64, <br>&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY KEY (season_id, episodes_id), <br>&nbsp;&nbsp;&nbsp;&nbsp;INDEX rating_index GLOBAL ON (imdb_rating)<br>); <br><strong>Decision:</strong><br>Добавим в эту таблицу данные. Для вставки данных в YDB помимо обычной SQL инструкции INSERT также используются инструкции REPLACE и UPSERT.<br>При выполнении INSERT перед операцией записи выполняется операция чтения данных. Это позволяет убедиться, что уникальность первичного ключа будет соблюдена. При выполнении инструкций REPLACE и UPSERT осуществляется слепая запись.<br>Инструкции REPLACE и UPSERT используются для добавления новой или изменения существующей строки по заданному значению первичного ключа. При операциях записи и изменения данных использование этих инструкций эффективнее.<br>Если при выполнении этих инструкций строка с указанным значением первичного ключа не существует, то она будет создана. Если же такая строка существует, то значения ее столбцов будут заменены на новые. Отличие между REPLACE и UPSERT заключается в том, что первая из этих инструкций устанавливает значения столбцов, не участвующих в операции, в значения по умолчанию, а вторая такие значения не меняет.<br>Одним запросом REPLACE, UPSERT или INSERT можно вставить в таблицу несколько строк.<br>Например, если бы мы хотели добавить в таблицу series те данные, которые в ней сейчас содержатся, то SQL запрос выглядел бы так:<br>REPLACE INTO series (series_id, title, release_date, series_info) <br>VALUES <br>&nbsp;&nbsp;( <br>&nbsp;&nbsp;&nbsp;&nbsp;1, <br>&nbsp;&nbsp;&nbsp;&nbsp;"IT Crowd", <br>&nbsp;&nbsp;&nbsp;&nbsp;Date("2006-02-03"), <br>&nbsp;&nbsp;&nbsp;&nbsp;"The IT Crowd is a British sitcom produced by Channel 4, written by Graham Linehan, produced by Ash Atalla and starring Chris O'Dowd, Richard Ayoade, Katherine Parkinson, and Matt Berry."), <br>&nbsp;&nbsp;( <br>&nbsp;&nbsp;&nbsp;&nbsp;2, <br>&nbsp;&nbsp;&nbsp;&nbsp;"Silicon Valley", <br>&nbsp;&nbsp;&nbsp;&nbsp;Date("2014-04-06"), <br>&nbsp;&nbsp;&nbsp;&nbsp;"Silicon Valley is an American comedy television series created by Mike Judge, John Altschuler and Dave Krinsky. The series focuses on five young men who founded a startup company in Silicon Valley." <br>&nbsp;&nbsp;); <br><strong>Task:</strong><br>добавьте в таблицу ratings данные из этого файла.<br><strong>Decision:</strong><br>REPLACE INTO ratings (season_id, episodes_id, title, air_date, imdb_rating) VALUES <br>&nbsp;&nbsp;(1, 1, "Yesterday's Jam", Date("2006-02-03"), 76),<br>&nbsp;&nbsp;(1, 2, "Calamity Jen", Date("2006-02-03"), 82),<br>&nbsp;&nbsp;(1, 3, "Fifty-Fifty", Date("2006-02-10"), 79),<br>&nbsp;&nbsp;(1, 4, "The Red Door", Date("2006-02-17"), 80),<br>&nbsp;&nbsp;(1, 5, "The Haunting of Bill Crouse", Date("2006-02-24"), 85),<br>&nbsp;&nbsp;(1, 6, "Aunt Irma Visits", Date("2006-03-03"), 81),<br>&nbsp;&nbsp;(2, 1, "The Work Outing", Date("2006-08-24"), 95),<br>&nbsp;&nbsp;(2, 2, "Return of the Golden Child", Date("2007-08-31"), 82),<br>&nbsp;&nbsp;(2, 3, "Moss and the German", Date("2007-09-07"), 82),<br>&nbsp;&nbsp;(2, 4, "The Dinner Party", Date("2007-09-14"), 87),<br>&nbsp;&nbsp;(2, 5, "Smoke and Mirrors", Date("2007-09-21"), 78),<br>&nbsp;&nbsp;(2, 6, "Men Without Women", Date("2007-09-28"), 76),<br>&nbsp;&nbsp;(3, 1, "From Hell", Date("2008-11-21"), 78),<br>&nbsp;&nbsp;(3, 2, "Are We Not Men?", Date("2008-11-28"), 85),<br>&nbsp;&nbsp;(3, 3, "Tramps Like Us", Date("2008-12-05"), 82),<br>&nbsp;&nbsp;(3, 4, "The Speech", Date("2008-12-12"), 90),<br>&nbsp;&nbsp;(3, 5, "Friendface", Date("2008-12-19"), 85),<br>&nbsp;&nbsp;(3, 6, "Calendar Geeks", Date("2008-12-26"), 78),<br>&nbsp;&nbsp;(4, 1, "Jen The Fredo", Date("2010-06-25"), 80),<br>&nbsp;&nbsp;(4, 2, "The Final Countdown", Date("2010-07-02"), 84),<br>&nbsp;&nbsp;(4, 3, "Something Happened", Date("2010-07-09"), 75),<br>&nbsp;&nbsp;(4, 4, "Italian For Beginners", Date("2010-07-16"), 82),<br>&nbsp;&nbsp;(4, 5, "Bad Boys", Date("2010-07-23"), 84),<br>&nbsp;&nbsp;(4, 6, "Reynholm vs Reynholm", Date("2010-07-30"), 76); <br><strong>Decision:</strong><br>C помощью SQL запросов можно добавлять и удалять не только строки таблицы, но и столбцы. Для этого используется команда ALTER TABLE и фразы ADD COLUMN и DROP COLUMN.<br>Например, если вы хотите добавить в таблицу ratings столбец viewed с данными о том, какие эпизоды сериала вы уже посмотрели, то это можно сделать с помощью следующей команды.<br>ALTER TABLE ratings ADD COLUMN viewed Bool;  <br><strong>Task:</strong><br>Вы решили, что столбец с датой выхода эпизодов в таблице ratings не нужен, поскольку эта информация уже содержится в другой таблице. Удалите столбец air_date из таблицы ratings.<br><strong>Decision:</strong><br>ALTER TABLE ratings DROP COLUMN air_date; <br><strong>Decision:</strong> <br>Теперь потренируемся извлекать данные из БД. Для этого используется команда SELECT. В простейшем случае ее синтаксис выглядит так:<br>SELECT &lt;имя столбца1&gt;, &lt;имя столбца2&gt;, ...<br>FROM &lt;имя таблицы&gt;; <br>Например, чтобы выбрать всю информацию из таблицы seasons, нужно сделать следующий запрос к БД.<br>SELECT * FROM seasons; <br>Если нужно выбрать из таблицы только те строки, которые удовлетворяют определенному условию, в запросе используют секцию WHERE. В этой секции должно находиться выражение, возвращающее логический результат. Обычно оно состоит из логических операций and, or, not и операций сравнения.<br>Например, выбрать из таблицы episodes только первые эпизоды всех сезонов можно так:<br>SELECT * FROM episodes<br>WHERE episode_id = 1;  <br>Запрос SELECT извлекает строки без определенного порядка. Чтобы отсортировать полученные данные нужным образом, в этот запрос включают секцию ORDER BY. В ней указывается список столбцов, которые будут определять порядок сортировки результатов запроса.<br><strong>Task:</strong> <br>получите список самых популярных (с рейтингом не менее 85) эпизодов сериала IT Crowd. При поиске используйте созданный ранее вторичный индекс rating_index. Чтобы упорядочить результаты по убыванию рейтинга используйте конструкцию ORDER BY … DESC.<br><strong>Decision:</strong><br>SELECT <br>&nbsp;&nbsp;season_id, <br>&nbsp;&nbsp;episodes_id, <br>&nbsp;&nbsp;title, <br>&nbsp;&nbsp;imdb_rating<br>FROM ratings VIEW rating_index <br>WHERE <br>&nbsp;&nbsp;imdb_rating &gt;= 85 <br>ORDER BY <br>&nbsp;&nbsp;imdb_rating DESC;  <br><strong>Decision:</strong><br>Для получения обобщённых сведений о содержащихся в таблице данных — например, о числе строк в таблице или среднем значении какого-либо выражения — в запрос SELECT включают агрегатные функции и секцию GROUP BY. Эта секция используется для агрегации внутри каждого ключа. Ключом является значение одной или более колонок, указанных в GROUP BY.<br>Примеры агрегатных функций:<br>COUNT(*) — вычисляет число строк в таблице.<br>MAX(expr) — находит максимум выражения expr по всем строкам.<br>SUM(expr) — суммирует выражение expr по всем строкам. Тип выражения должен быть числовым.<br>AVG(expr) — находит среднее значение выражения expr по всем строкам. Тип выражения должен быть числовым или интервалом.<br>SOME(expr) — возвращает одно произвольное значение выражения по всем строкам.<br>Результаты выполнения агрегатной функции выводятся в отдельном столбце. Чтобы задать этому столбцу имя, используют оператор AS. Конструкция может выглядеть, например, так:<br>SELECT <br>&nbsp;&nbsp;&lt;имя столбца1&gt;, <br>&nbsp;&nbsp;MAX(&lt;имя столбца2&gt;) AS max_value<br>...; <br><strong>Task:</strong><br>Напишите SQL запрос к таблице episodes, который выводит данные о числе эпизодов каждого сериала.<br>Вам понадобится вычислить число строк для каждого значения столбца series_id и сгруппировать результаты по series_id.<br><strong>Decision:</strong><br>SELECT <br>&nbsp;&nbsp;series_id, <br>&nbsp;&nbsp;COUNT(*) AS total_episodes <br>FROM episodes <br>GROUP BY <br>&nbsp;&nbsp;series_id <br>ORDER BY <br>&nbsp;&nbsp;series_id; <br><strong>Task:</strong> <br>Напишите SQL запрос, с помощью которого можно сравнить популярность сезонов сериала IT Crowd. <br>Вам понадобится вычислить средний рейтинг эпизодов для каждого сезона и сгруппировать результаты по столбцу season_id.<br><strong>Decision:</strong><br>SELECT <br>&nbsp;&nbsp;season_id, <br>&nbsp;&nbsp;AVG (imdb_rating) AS avg_rating<br>FROM ratings <br>GROUP BY season_id<br>ORDER BY avg_rating DESC; <br><strong>Decision:</strong><br>В реляционной БД таблицы логически связаны друг с другом. С помощью объединений (JOIN) можно получить данные из нескольких связанных друг с другом таблиц и представить их в виде одной результирующей таблицы.<br>Столбцы, по которым выполняется объединение, можно указать одним из двух способов.<br>- После ключевого слова USING, например table1 AS a JOIN table2 AS b USING (foo). Это более короткий способ записи, удобный для простых случаев. Имена столбцов, по которым происходит объединение таблиц, должны быть одинаковы.<br>- После ключевого слова ON (например, a JOIN b ON a.foo = b.bar). Этот способ позволяет использовать разные имена столбцов и указывать дополнительные условия по аналогии с WHERE.<br>Поскольку такие запросы затрагивают столбцы разных таблиц, имена столбцов должны содержать и имя таблицы (то есть, например, не просто series_id, а seasons.series_id).<br>В YDB доступны следующие логические типы объединений:<br>INNER (используется по умолчанию) — строки попадают в результат, только если значение ключевых колонок присутствует в обеих таблицах;<br>FULL, LEFT и RIGHT — при отсутствии значения в обеих или в одной из таблиц включает строку в результат, но оставляет пустыми (NULL) колонки, соответствующие противоположной таблице.<br>LEFT/RIGHT SEMI — одна сторона выступает как белый список (whitelist) ключей, её значения недоступны. В результат включаются столбцы только из одной таблицы, декартового произведения не возникает;<br>LEFT/RIGHT ONLY — вычитание множеств по ключам (blacklist). Практически эквивалентно добавлению условия IS NULL на ключ противоположной стороны в обычном LEFT/RIGHT, но, как и в SEMI, нет доступа к значениям;<br>CROSS — декартово произведение двух таблиц целиком без указания ключевых колонок, секция с ON/USING явно не пишется;<br>EXCLUSION — обе стороны минус пересечение.<br>Простой пример запроса с объединением таблиц приведен ниже.<br>SELECT<br>&nbsp;&nbsp;sa.title AS season_title,<br>&nbsp;&nbsp;sr.title AS series_title,<br>&nbsp;&nbsp;sr.series_id, sa.season_id <br>FROM seasons AS sa<br>INNER JOIN series AS sr ON sa.series_id = sr.series_id <br>WHERE sa.season_id = 1<br>ORDER BY sr.series_id; <br>Этот запрос извлекает из таблиц series и seasons сведения о первых сезонах всех сериалов и выводит объединённые данные в результирующей таблице.<br><strong>Task:</strong> <br>напишите запрос, который выводит таблицу, содержащую название сериала IT Crowd и названия всех его эпизодов (то есть, каждая строка итоговой таблице должна содержать название сериала и название отдельного эпизода).<br><strong>Decision:</strong><br>SELECT <br>&nbsp;&nbsp;sr.title AS series_title, <br>&nbsp;&nbsp;ep.title AS episode_title, <br>&nbsp;&nbsp;ep.season_id,&nbsp;&nbsp; <br>&nbsp;&nbsp;ep.episode_id <br>FROM <br>&nbsp;&nbsp;series AS sr <br>INNER JOIN <br>&nbsp;&nbsp;episodes AS ep <br>ON sr.series_id = ep.series_id <br>WHERE sr.series_id = 1 <br>ORDER BY <br>&nbsp;&nbsp;ep.season_id,&nbsp;&nbsp; <br>&nbsp;&nbsp;ep.episode_id;  <br><strong>Task:</strong><br>Создание кластера Hadoop.<br>На этом уроке вы создадите и настроите кластер Hadoop с помощью сервиса Yandex Data Proc. <br>Hadoop предназначается для работы с большими данными, поэтому создание кластера потребует от вас больше усилий, чем на предыдущих практических работах (но гораздо меньше, чем если бы вы делали это самостоятельно).<br><strong>Decision:</strong><br>Для хранения зависимостей заданий нашего кластера и результатов их выполнения нужно предварительно создать бакет в объектном хранилище. О том, как это сделать, мы рассказывали на одном из предыдущих занятий.<br>Также создайте сервисный аккаунт для доступа к кластеру. Обратите внимание: можно использовать только аккаунт с ролью mdb.dataproc.agent. Для автоматического масштабирования кластера сервисному аккаунту также понадобятся роли editor и dataproc.agent.<br>Откройте каталог, где будете создавать кластер, и выберите сервис Data Proc.<br>В открывшемся окне нажмите кнопку Создать кластер.<br>Задайте для кластера имя и выберите версию образа — 1.4. В образ включена одна из версий Hadoop и дополнительные компоненты. Некоторые вы можете устанавливать по выбору. Кроме того, в каждую версию образа входит Conda (менеджер окружений для Python) и набор инструментов машинного обучения (scikit-learn, TensorFlow, CatBoost, LightGBM и XGBoost).<br>Обратите внимание на то, что некоторые из сервисов обязательны, чтобы использовать другие. На следующем уроке нам понадобится сервис HIVE. Выберите его, и рядом с MAPREDUCE и YARN вы увидите напоминания о том, что они нужны для HIVE.<br>Вставьте в поле публичный ключ публичную часть SSH-ключа. Как сгенерировать и использовать SSH-ключи, мы рассказывали в одной из практических работ о виртуальных машинах.<br>Выберите созданный сервисный аккаунт для доступа к кластеру.<br>Выберите зону доступности для кластера. Все подкластеры будут находиться в этой <br>Если нужно, задайте свойства Hadoop и его компонентов. Доступные свойства перечислены в документации.<br>Выберите бакет в объектном хранилище, где будут храниться зависимости заданий и результаты их выполнения.<br>Выберите или создайте сеть для кластера. Включите опцию NAT в интернет для подсетей, в которых размещается кластер.<br>Если нужно, создайте группу безопасности. Правила для неё вы добавите позже в сервисе Virtual Private Cloud.<br>Включите опцию UI Proxy, чтобы получить доступ к веб-интерфейсам компонентов Data Proc. У некоторых компонентов (например Hadoop, Spark, YARN и Zeppelin) есть пользовательские веб-интерфейсы, доступные на мастер-узле кластера. С помощью этих интерфейсов вы можете:<br>- отслеживать ресурсы кластера и управлять ими (YARN Resource Manager, HDFS NameNode);<br>- просматривать статус и отлаживать задания (Spark History, JobHistory);<br>- проводить эксперименты, совместно работать или выполнять отдельные операции (Zeppelin).<br>Настройка подкластеров. В состав кластера входит один главный подкластер (Мастер) с управляющим хостом, а также подкластеры для хранения данных (Data) или вычислений (Compute).<br>В подкластерах Data можно разворачивать компоненты для хранения данных, а в подкластерах Compute — для обработки данных. Хранилище в подкластере Compute предназначено только для временного хранения обрабатываемых файлов.<br>Для каждого подкластера можно задать число и класс хостов, размер и тип хранилища, а также подсеть той сети, в которой расположен кластер. Кроме того, для подкластеров Compute можно настроить автоматическое масштабирование. Это позволит выполнять задания на обработку данных быстрее без дополнительных усилий с вашей стороны.<br>Создадим подкластер Compute с одним хостом.<br>В блоке Добавить подкластер нажмите кнопку Добавить.<br>В поле Роли выберите COMPUTENODE. В блоке Масштабирование включите опцию Автоматическое масштабирование.<br>Все открывшиеся настройки знакомы вам из практических работ по созданию виртуальных машин.<br>Автоматическое масштабирование подкластеров обработки данных поддерживается в кластерах Yandex Data Proc версии 1.2 и выше. Чтобы оно работало, в кластере с установленным Spark или Hive должен быть также установлен сервис YARN.<br>Yandex Data Proc автоматически масштабирует кластер, используя для этого системные метрики нагрузки на кластер. Когда их значение выходит из установленного диапазона, запускается масштабирование. Если значение метрики превысит порог, в подкластер добавятся хосты. Если опустится ниже порога, начнётся декомиссия (высвобождение ненужных ресурсов), а избыточные хосты удалятся.<br>По умолчанию для масштабирования используется внутренняя метрика YARN (yarn.cluster.containersPending). Она показывает, сколько единиц ресурсов нужно заданиям в очереди. Выбирайте эту опцию Масштабирование по умолчанию, если в кластере выполняется много относительно небольших заданий.<br>Другой вариант — масштабирование на основе метрики загрузки процессора (vCPU). Чтобы использовать его, отключите опцию Масштабирование по умолчанию и укажите целевой уровень загрузки vCPU.<br>Настроив подкластеры, нажмите кнопку Создать кластер.<br>Сервис запустит создание кластера. После того как статус кластера изменится на Running, вы сможете подключиться к любому активному подкластеру с помощью указанного в настройках SSH-ключа.<br><strong>Task:</strong><br>Подключение к кластеру и работа с Hive.<br>На этом уроке вы научитесь подключаться к кластеру Hadoop и работать с ним на примере выполнения запросов с помощью Hive.<br><strong>Decision:</strong><br>Подключимся к управляющему хосту главного подкластера. Поскольку хостам кластера Hadoop не назначается публичный IP-адрес, для подключения к ним нужна виртуальная машина, расположенная в той же сети Yandex Cloud.<br>Выберите машину, которую создавали раньше, или создайте новую. Подключитесь к ней по SSH. Вы уже делали это, когда изучали виртуальные машины.<br>Подключитесь с этой машины к хосту главного подкластера также с помощью SSH. Для этого на машине должна быть закрытая часть SSH-ключа, открытую часть которого вы указали при создании кластера Data Proc. Вы можете скопировать ключ на виртуальную машину или подключаться к ней с запущенным SSH-агентом.<br>Скопировать ключ можно с помощью утилиты nano. На виртуальной машине выполните команду:<br>sudo nano ~/.ssh/&lt;имя ключа&gt; <br>В открывшийся редактор скопируйте содержимое закрытой части SSH-ключа с вашей локальной машины.<br>Запустите SSH-агент:<br>eval `ssh-agent -s` <br>Добавьте ключ в список доступных агенту:<br>ssh-add ~/.ssh/&lt;имя ключа&gt; <br>Узнайте внутренний FQDN хоста главного подкластера. Для этого в консоли управления на странице кластера перейдите на вкладку Хосты и выберите хост с ролью MASTERNODE.<br>Откройте SSH-соединение с хостом Data Proc для пользователя root, например:<br>ssh root@&lt;FQDN хоста&gt; <br>Пошаговые инструкции по различным способам подключения к кластеру Data Proc приведены в документации.<br>Проверим, что команды Hadoop выполняются, например:<br>hadoop version <br>Результат выполнения этой команды выглядит так:<br>Запуск заданий Apache Hive<br>Как мы уже говорили ранее, Hive — это платформа для хранения данных и управления ими в экосистеме Hadoop. Она используется для доступа к большим датасетам, сохранённым в распределённом хранилище.<br>Hive позволяет работать с данными различного формата (csv, tsv, Parquet, ORC, Avro и другими), подключаться к БД и взаимодействовать с ней с помощью SQL-подобного языка запросов. Hive используется преимущественно для работы с данными в HDFS, HBase, S3-совместимых хранилищах и реляционных СУБД.<br>Запрос на действия с данными в Hive называется заданием. Задания можно запускать на управляющем хосте с помощью командной оболочки CLI Hive, а также с помощью CLI Yandex Cloud.<br>Для запуска Hive CLI выполните команду hive на управляющем хосте.<br>Проверьте, всё ли работает: выполните, например, команду select 1; — корректный результат выглядит так:<br>Теперь создайте внешнюю таблицу (external table) в формате Parquet, содержащую открытые данные о списке перелётов между городами США в 2018 году. Для этого с помощью Hive CLI выполните запрос:<br>hive&gt; CREATE EXTERNAL TABLE flights (Year bigint, Month bigint, FlightDate string, Flight_Number_Reporting_Airline bigint, OriginAirportID bigint, DestAirportID bigint) STORED AS PARQUET LOCATION 's3a://yc-mdb-examples/dataproc/example01/set01'; <br>Проверим список таблиц, выполнив команду show tables. Результат должен выглядеть так:<br>Запросим число перелётов с разбивкой по месяцам:<br>hive&gt; SELECT Month, COUNT(*) FROM flights GROUP BY Month; <br>Пример результата такого запроса:<br>Безусловно, на одном примере сложно показать возможности сервиса Data Proc. Если вас интересует работа с большими данными в облаке, посмотрите доклады сотрудников Yandex Cloud об управлении кластерами Hadoop и заданиями в Data Proc на YouTube-канале Yandex Cloud.<br><strong>Decision:</strong><br>$ cat YOUR-KEY<br>$ eval `ssh-agent -s`<br>$ ssh-add YOUR-KEY<br>$ ssh root@&lt;FQDN хоста&gt; <br>$ hadoop version<br>$ hive<br>hive&gt; select 1;<br>hive&gt; CREATE EXTERNAL TABLE flights (Year bigint, Month bigint, FlightDate string, Flight_Number_Reporting_Airline bigint, OriginAirportID bigint, DestAirportID bigint) STORED AS PARQUET LOCATION 's3a://yc-mdb-examples/dataproc/example01/set01';<br>hive&gt; show tables;<br>hive&gt; SELECT Month, COUNT(*) FROM flights GROUP BY Month;<br><strong>Task:</strong><br>Создание датасетов, чартов и дашбордов.<br>На этом уроке вы научитесь создавать чарты и дашборды. Мы пройдём по всей цепочке сущностей DataLens начиная с источника данных.<br>Изучая ClickHouse, мы анализировали данные о погоде с помощью SQL-запросов. <br>Давайте посмотрим на примере того же самого набора данных, как с помощью DataLens быстро и наглядно показать отличия климата в Москве и Санкт-Петербурге.<br><strong>Decision:</strong><br>Источник данных.ClickHouse и DataLens интегрированы друг с другом, поэтому подключение DataLens к ClickHouse можно настроить всего за пару кликов.<br>В консоли управления запустите кластер ClickHouse, в котором развёрнута БД с таблицей Weather, созданной вами ранее. Перейдите на страницу кластера, на панели слева выберите DataLens.<br>Подключение. Нажмите кнопку Создать подключение. В открывшемся диалоговом окне вы увидите, что кластер ClickHouse, из которого мы возьмём данные для анализа, имя хоста и имя пользователя БД уже указаны.<br>Вам осталось только дать имя подключению в пустом поле вверху, ввести пароль к БД, нажать кнопку Проверить подключение и убедиться, что всё в порядке, а потом — кнопку Создать.<br>Датасет. После того как подключение будет создано, DataLens выведет на панели слева таблицы из БД и предложит создать датасет. Наш датасет будет состоять из одной таблицы: db1.Weather. Перетащите её на центральную панель, и внизу откроется предпросмотр данных.<br>Нажмите кнопку Сохранить и задайте имя датасета.<br>Подготовим данные. Это важная часть аналитической работы, и её не стоит пропускать. Прежде всего укажем имена полей на русском языке. Перейдите на вкладку Поля и переименуйте их:<br>- LocalDateTime - Дата и время<br>- LocalDate - Дата<br>- Month - Месяц<br>- Day - День<br>- TempC - Температура<br>- Pressure - Давление<br>- RelHumidity - Влажность<br>- Тип WindSpeed10MinAvg - Скорость ветра<br>- VisibilityKm - Видимость<br>- City - Город<br>Поля Дата и время, Дата, Месяц, День, Город будут полями-измерениями, а Температура, Давление, Влажность, Скорость ветра, Видимость — полями-показателями. Зададим для показателей тип агрегации Среднее.<br>Чарты. Приступим к созданию первого чарта. Нажмите кнопку Создать чарт. Выберите тип чарта Линейная диаграмма и перетащите Дата в раздел X , а Температура — в раздел Y.<br>На этом примере видно, что средства визуализации иногда помогают быстро проверить качество датасета: есть ли в нём пропущенные или странные, выбивающиеся из общей тенденции данные.<br>В нашем случае можно сделать вывод о том, что в датасете не хватает данных примерно с середины 2015-го по середину 2016-го.<br>Разделим показатели температуры для двух городов. Для этого перетащим Город в раздел Цвета. Кроме того, округлим значения поля Дата до месяцев, чтобы лучше увидеть, как различаются данные для Москвы и Санкт-Петербурга. Для этого слева от поля Дата нажмите зелёный значок календаря и в разделе Группировка выберите округление по месяцам.<br>Из этого графика уже можно делать выводы. В целом температура в Москве выше, чем в Санкт-Петербурге. Летом примерно на 5 градусов, зимой — на 1−2 градуса.<br>Сохраните чарт, чтобы затем использовать его для дашборда.<br>Чтобы окончательно разобраться с температурой, построим ещё один чарт — Столбчатую диаграмму — и сравним среднегодовую температуру. Выберите тип диаграммы. Добавьте поле Город в раздел X, чтобы разделить отображение значений температуры. Также для поля Дата выберите группировку по годам.<br>Кроме того, для чарта понадобится задать фильтр по датам. Поскольку мы сравниваем среднегодовые значения, неполные данные за 2009 и 2019 годы отбросим. В разделе Фильтры нажмите + и выберите поле Дата.<br>Для этого чарта мы возьмём только данные из диапазона с начала 2010-го по конец 2018-го. Нажмите кнопку Применить фильтр и сохраните чарт.<br>Сделайте сами два таких же чарта с данными о скорости ветра: линейную диаграмму со среднемесячными значениями скорости ветра в городах и столбчатую диаграмму со среднегодовыми значениями.<br>Теперь у нас достаточно чартов для информативного дашборда.<br>Дашборд. На панели слева выберите Дашборды и нажмите кнопку Создать дашборд. Введите название дашборда и нажмите Создать.<br>Если в каталоге это первый дашборд — он откроется сразу после создания. Если в каталоге есть другие дашборды, вы увидите список. В этом случае выберите из списка только что созданный дашборд.<br>Теперь добавим созданные нами чарты на дашборд. Нажмите Добавить и в выпадающем списке выберите Чарт. Поочерёдно выбирайте из списка и добавляйте чарты.<br>В результате на дашборде появятся четыре виджета с чартами. Меняйте размеры и положение виджетов для лучшей визуализации.<br>Осталось лишь несколько последних штрихов. В том же пункте меню Добавить создадим пару заголовков и селектор по датам. В правом верхнем углу каждого виджета нажмите значок шестерёнки, чтобы изменить названия. Сохраним дашборд. <br>То, какие чарты сделать и как их разместить на дашборде, бывает понятно не сразу. Рассмотрите несколько вариантов, когда строите дашборд, чтобы разобраться, какая именно визуализация лучше помогает ответить на вопросы.<br>В маркетплейсе DataLens вы найдёте ещё один дашборд с погодой. Он хорошо демонстрирует возможности визуализации данных этого сервиса.<br>Чтобы открыть публичный доступ к дашборду, справа от его названия нажмите ··· и выберите Публичный доступ. Скопируйте ссылку. По ней дашборд будет доступен всем, с любых устройств и без аутентификации.</p>

<p><strong>Task:</strong><br>Права доступа и роли для сервисного аккаунта.<br>В этом уроке вы научитесь работать с сервисными аккаунтами и назначать для них роли и права доступа к объектам. <br>В качестве объекта будет выступать созданный в сервисе KMS ключ шифрования. <br>Предположим, что перед вами стоит задача использовать сервисный аккаунт для ротации ключей.<br>Чтобы решить эту задачу, понадобится выполнить следующие шаги:<br>- Создать сервисный аккаунт.<br>- Получить права на управление этим сервисным аккаунтом.<br>- Создать статические ключи доступа и привязать их к сервисному аккаунту, чтобы он мог пройти авторизацию в сервисе KMS.<br>- Создать в сервисе KMS ключ шифрования и назначить сервисному аккаунту роль kms.admin для управления этим ключом.<br>- И, наконец, ротировать ключ, то есть создать его новую версию с такими же параметрами, из-под сервисного аккаунта.<br>- Нужно заметить, что через консоль управления сервисному аккаунту можно назначить роль только на каталог, в котором он был создан. Роли на все остальные ресурсы назначаются с помощью CLI или API. Поэтому для выполнения этой практической работы вам понадобится вспомнить, как пользоваться утилитой yc, чему вы уже научились в курсе &laquo;DevOps и автоматизация&raquo;.<br><strong>Decision:</strong><br>ШАГ 1<br>Для начала создадим сервисный аккаунт. В консоли управления войдите в каталог облака, в котором вы будете выполнять эту практическую работу, и перейдите на вкладку Сервисные аккаунты. Нажмите кнопку Создать сервисный аккаунт.<br>В открывшемся окне задайте для нового сервисного аккаунта имя и, при желании, добавьте описание. Здесь аккаунту также можно добавить роли на каталог, в котором он создаётся.<br>Оставьте поле с ролями пустым и нажмите Создать.<br>ШАГ 2<br>Настройте для вашего аккаунта на Яндексе доступ на авторизацию под созданным сервисным аккаунтом.<br>Для начала убедитесь, что вы авторизованы в аккаунте с ролью admin. Чтобы это проверить, выполните команду<br>yc iam role list <br>Вы увидите список ролей вашего аккаунта. Примерно такой (роль admin должна в нем присутствовать):<br>Узнайте идентификатор своего аккаунта. Он понадобится, чтобы добавить вашему аккаунту роль editor на созданный сервисный аккаунт (сервисный аккаунт тоже является ресурсом, и для работы с ним нужна соответствующая роль). Воспользуйтесь для этого командой:<br>yc iam user-account get &lt;имя_вашего_аккаунта&gt; <br>Кроме того, нужно узнать идентификатор созданного сервисного аккаунта. Это можно сделать в разделе Сервисные аккаунты консоли управления. Выбрав нужный аккаунт в списке, вы перейдёте на страницу с детальной информацией о нем.<br>Теперь предоставьте вашему пользовательскому аккаунту права на управление созданным сервисным аккаунтом. Для этого нужно выполнить команду<br>yc iam service-account add-access-binding &lt;ID_сервисного_аккаунта&gt; \<br>--role editor --subject userAccount:&lt;ID_пользовательского_аккаунта&gt; <br>ШАГ 3<br>Настройте аутентификацию под сервисным аккаунтом с вашей машины.<br>Сначала нужно создать статические ключи доступа и сохранить их в json-файле (например key.json).<br>Воспользуйтесь для этого командой<br>yc --folder-name &lt;имя_каталога&gt; iam key create \<br>--service-account-name &lt;имя_сервисного_аккаунта&gt; --output key.json <br>После выполнения команды вы получите идентификатор созданной ключевой пары. Используя статические ключи доступа, можно получить IAM-токен для авторизации в сервисах.<br>Теперь нужно создать профиль, от имени которого будут выполняться операции из-под сервисного аккаунта. Для этого придумайте имя этого профиля (например yc-lab23-profile) и выполните команду:<br>yc config profile create &lt;имя_профиля&gt; <br>Привяжите к этому профилю ранее созданный статический ключ доступа с помощью команды:<br>yc config set service-account-key key.json <br>Чтобы убедиться, что всё сделано правильно, выведите информацию об авторизации и ключах доступа<br>yc config list <br>Вы должны получить примерно такой результат:<br>ШАГ 4<br>Теперь нужно создать ключ шифрования, ротацией которого вы будете управлять с помощью сервисного аккаунта. Для этого перейдите в дашборд каталога в консоли управления, нажмите кнопку Создать ресурс и выберите Ключ шифрования.<br>В открывшемся окне задайте для ключа имя и нажмите кнопку Создать. Новый ключ появится в списке в открывшемся разделе Ключи.<br>Чтобы назначить сервисному аккаунту роль для какого-либо ресурса, нужно знать идентификатор этого ресурса. Нажмите строку с созданным ключом, чтобы перейти на страницу детальной информации о нём, и скопируйте ID ключа.<br>Перейдем к назначению сервисному аккаунту роли kms.admin для управления созданным ключом шифрования. Перед этим нужно сначала вернуться в профиль вашего аккаунта.<br>yc config profile activate &lt;имя_профиля&gt; <br>Выполните команду:<br>yc --folder-name &lt;имя_каталога&gt; kms symmetric-key \<br>add-access-binding &lt;ID_ключа_шифрования&gt; --role kms.admin \<br>--subject serviceAccount:&lt;ID_сервисного_аккаунта&gt; <br>Теперь с помощью сервисного аккаунта вы можете управлять этим ключом шифрования.<br>ШАГ 5<br>В CLI переключитесь обратно в профиль сервисного аккаунта:<br>yc config profile activate &lt;имя_профиля_сервисного_аккаунта&gt; <br>Ротируйте ключ шифрования:<br>yc kms symmetric-key rotate &lt;ID_ключа&gt; <br>После выполнения команды перейдите на страницу детальной информации о ключе и откройте вкладку Операции.<br>Вы увидите, что операция по ротации ключа выполнена под вашим сервисным аккаунтом. Значит, всё получилось и задача решена!<br><strong>Decision:</strong><br>$ yc iam service-account create --name &lt;имя_сервисного_аккаунта&gt;<br>$ yc iam service-account create --name security-labs \<br>--description "Service account for Security course labs"<br>$ yc iam role list<br>$ yc iam user-account get &lt;ваш_логин&gt;<br>$ yc iam service-account list<br>$ yc iam service-account get &lt;имя_сервисного_аккаунта&gt;<br>$ yc iam service-account add-access-binding &lt;id_сервисного_аккаунта&gt; \<br>--role editor \<br>--subject userAccount:&lt;id_пользовательского_аккаунта&gt;<br>$ vim key.json<br>$ cat key.json<br>{<br>&nbsp; "id": "YOUR-ID1",<br>&nbsp; "service_account_id": "YOUR-ID2",<br>&nbsp; "created_at": "2023-12-09T01:19:35.625144946Z",<br>&nbsp; "key_algorithm": "RSA_2048",<br>&nbsp; "public_key": "-----BEGIN PUBLIC KEY-----\nYOUR-KEY1\n-----END PUBLIC KEY-----\n",<br>&nbsp; "private_key": "PLEASE DO NOT REMOVE THIS LINE! Yandex.Cloud SA Key ID &lt;YOUR-ID1&gt;\n-----BEGIN PRIVATE KEY-----\nYOUR-KEY2\n-----END PRIVATE KEY-----\n"<br>}<br>$ yc iam key create \<br>--service-account-name &lt;имя_сервисного_аккаунта&gt; \<br>--output key.json<br>$ yc config profile create &lt;имя_профиля_сервисного_аккаунта&gt;<br>$ yc config set service-account-key key.json<br>$ yc config set folder-id &lt;идентификатор_рабочего_каталога&gt;<br>$ yc config list<br>$ yc config profile list<br>$ yc config profile activate &lt;имя_основного_профиля&gt;<br>$ yc kms symmetric-key add-access-binding \<br>--id &lt;id_ключа_шифрования&gt; \<br>--role kms.admin \<br>--subject serviceAccount:&lt;id_сервисного_аккаунта&gt;<br>$ yc config profile activate &lt;имя_профиля_сервисного_аккаунта&gt;<br>$ yc kms symmetric-key rotate --id &lt;id_ключа_шифрования&gt;<br><strong>Task:</strong><br>Организация защищённого канала. <br>Защита данных, передаваемых между вашей локальной инфраструктурой и облаком, &mdash; важный элемент информационной безопасности. А удалённая работа, которая получила распространение в период пандемии коронавируса и сейчас закрепилась в практиках многих компаний, сделала эту задачу ещё более актуальной.<br>Чтобы защитить передаваемую информацию, используют VPN (Virtual Private Network) &mdash; технологию, позволяющую развернуть защищённое сетевое соединение &laquo;поверх&raquo; незащищённой сети (чаще всего это интернет). VPN-соединение представляет собой канал передачи данных между двумя узлами. Этот канал обычно называют VPN-туннелем. Если за одним из узлов находится целая сеть, то его называют VPN-шлюзом.<br>Механизм работы VPN:<br>- Перед созданием туннеля узлы идентифицируют друг друга, чтобы удостовериться, что шифрованные данные будут отправлены на нужный узел.<br>- На обоих узлах нужно заранее определить, какие протоколы будут использоваться для шифрования и обеспечения целостности данных.<br>- Узлы сверяют настройки, чтобы договориться об используемых алгоритмах. Если настройки разные, туннель не создаётся.<br>- Если сверка прошла успешно, то создаётся ключ, который используется для симметричного шифрования.<br>Этот механизм регламентируют несколько стандартов. Один из самых популярных &mdash; IPSec (Internet Protocol Security).<br>На этом уроке вы научитесь настраивать IPSec VPN-туннель между двумя VPN-шлюзами с помощью демона strongSwan. Один шлюз вы настроите на виртуальной машине в Yandex Cloud, второй &mdash; на своей локальной машине или виртуальной машине в другой облачной сети.<br><strong>Decision:</strong><br>Шаг 1. Создание ресурсов<br>Для практической работы вам понадобится сеть и подсеть в Yandex Cloud, а также созданная в этой подсети тестовая ВМ без публичного IP-адреса. Создайте эти ресурсы, если у вас их нет.<br>Теперь создадим IPSec-инстанс &mdash; ВМ, которая будет служить шлюзом для IPSec-туннеля. Чтобы это сделать:<br>Откройте ваш каталог, нажмите кнопку Создать ресурс и выберите пункт Виртуальная машина.<br>В поле Имя задайте имя ВМ, например ipsec-instance.<br>Выберите зону доступности, где находится подсеть, к которой будет подключён IPSec-инстанс, и тестовая ВМ.<br>В разделе Выбор образа/загрузочного диска перейдите в блок Cloud Marketplace и выберите образ IPSec-инстанс.<br>В блоке Сетевые настройки выберите нужную сеть, подсеть и назначьте ВМ публичный IP-адрес из списка или автоматически.<br>Важно использовать только статические публичные IP-адреса из списка или сделать IP-адрес ВМ статическим после её создания. Динамический IP-адрес может измениться после перезагрузки ВМ, и туннель перестанет работать.<br>В блоке Доступ укажите логин и SSH-ключ для доступа к ВМ.<br>Нажмите кнопку Создать ВМ.<br>Виртуальная машина готова.<br>Шаг 2. Настраиваем IPSec<br>Теперь настроим шлюз с публичным IP-адресом, который будет устанавливать IPSec-соединение с удалённым шлюзом (вашей локальной машиной или ВМ в другой облачной сети).<br>Вы можете создать в своём каталоге ещё одну облачную сеть с подсетью, создать в ней IPSec-инстанс из образа и использовать его в качестве удалённого шлюза. Либо можно использовать в качестве шлюза машину в вашей локальной сети. Вам понадобится публичный IP-адрес удалённого шлюза и CIDR подсети.<br>Допустим, публичный IP-адрес вашего шлюза &mdash; 130.193.32.25, а за ним находится подсеть c префиксом подсети CIDR 10.128.0.0/24. Шлюз будет устанавливать IPSec-соединение с удалённым шлюзом с IP-адресом, например, 1.1.1.1, за которым находится подсеть с префиксом подсети CIDR 192.168.0.0/24.<br>Подключитесь к ВМ IPSec-инстанс по SSH:<br>ssh &lt;имя пользователя&gt;@130.193.32.25 <br>Откройте конфигурацию IPSec:<br>sudo nano /etc/ipsec.conf <br>В разделе config setup файла конфигурации задайте следующие параметры:<br>config setup<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; charondebug="all"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniqueids=yes<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strictcrlpolicy=no <br>Добавьте новый раздел с описанием тестового соединения, например conn cloud-to-hq.<br>Задайте параметры тестового соединения:<br>leftid &mdash; публичный IP-адрес IPSec-инстанса.<br>leftsubnet &mdash; CIDR подсети, к которой подключён IPSec-инстанс.<br>right &mdash; публичный IP-адрес шлюза на другом конце VPN-туннеля.<br>rightsubnet &mdash; CIDR подсети, к которой подключён VPN-шлюз на другом конце VPN-туннеля.<br>Параметры ike и esp &mdash; это алгоритмы шифрования, которые поддерживаются на удалённом шлюзе. Перечень поддерживаемых алгоритмов можно посмотреть на сайте strongSwan: IKEv1 и IKEv2.<br>Укажите остальные настройки, консультируясь с документацией strongSwan и учитывая настройки удалённого шлюза.<br>У вас должна получиться примерно такая конфигурация:<br>conn cloud-to-hq<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authby=secret<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left=%defaultroute<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftid=130.193.32.25<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftsubnet=10.128.0.0/24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right=1.1.1.1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rightsubnet=192.168.0.0/24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ike=aes256-sha2_256-modp1024!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esp=aes256-sha2_256!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyingtries=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ikelifetime=1h<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lifetime=8h<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpddelay=30<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpdtimeout=120<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpdaction=restart<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto=start <br>Сохраните изменения и закройте файл.<br>Откройте файл /etc/ipsec.secrets и укажите в нём пароль для установки соединения:<br>130.193.32.25 1.1.1.1 : PSK "&lt;пароль&gt;" <br>Перезапустите strongSwan:<br>sudo systemctl restart strongswan-starter <br>Шаг 3. Настраиваем статическую маршрутизацию<br>Теперь нужно настроить маршрутизацию между IPSec-инстансом и тестовой ВМ без публичного IP-адреса. Для этого создадим таблицу маршрутизации и добавим в неё статические маршруты.<br>Откройте сервис Virtual Private Cloud в каталоге, где требуется создать статический маршрут.<br>Выберите раздел Таблицы маршрутизации в панели слева и нажмите кнопку Создать таблицу маршрутизации.<br>Задайте имя таблицы маршрутизации, выберите сеть, в которой требуется её создать, и нажмите кнопку Добавить маршрут.<br>В открывшемся окне введите префикс подсети назначения на удалённой стороне, в примере это 192.168.0.0/24.<br>В поле Next hop укажите внутренний IP-адрес IPSec-шлюза и нажмите кнопку Добавить.<br>Нажмите кнопку Создать таблицу маршрутизации.<br>Чтобы использовать статические маршруты, нужно привязать таблицу маршрутизации к подсети. Для этого в разделе Подсети, в строке нужной подсети, нажмите кнопку &hellip; и в открывшемся меню выберите пункт Привязать таблицу маршрутизации.<br>В открывшемся окне выберите созданную таблицу и нажмите кнопку Привязать. Созданный маршрут можно применять и к другим подсетям этой сети.<br>Шаг 4. Настраиваем IPSec на другом шлюзе<br>Для работы VPN-туннеля нужно настроить второй шлюз.<br>Настройте strongSwan аналогично первому IPSec-шлюзу, но с зеркальными настройками IP-адресов и подсетей в файле /etc/ipsec.conf. Должна получиться такая конфигурация:<br>conn hq-to-cloud<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authby=secret<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left=%defaultroute<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftid=1.1.1.1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftsubnet=192.168.0.0/24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right=130.193.32.25<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rightsubnet=10.128.0.0/24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ike=aes256-sha2_256-modp1024!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esp=aes256-sha2_256!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyingtries=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ikelifetime=1h<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lifetime=8h<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpddelay=30<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpdtimeout=120<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpdaction=restart<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto=start <br>Укажите пароль для соединения в файле /etc/ipsec.secrets, указав IP-адреса шлюзов в обратном порядке:<br>1.1.1.1 130.193.32.25 : PSK "&lt;пароль&gt;" <br>Перезапустите strongSwan:<br>sudo systemctl restart strongswan-starter <br>Шаг 5. Проверяем, что всё работает<br>Чтобы убедиться, что туннель между шлюзами установлен, выполните на любом из шлюзов команду:<br>sudo ipsec status <br>Если всё в порядке, то у вас должно появиться примерно такое сообщение:<br>Security Associations (1 up, 0 connecting):<br>hq-to-cloud[3]: ESTABLISHED 29 minutes ago, 10.128.0.26[130.193.33.12]...192.168.0.23[1.1.1.1]<br>hq-to-cloud{3}:&nbsp; INSTALLED, TUNNEL, reqid 3, ESP in UDP SPIs: c7fa371d_i ce8b91ad_o<br>hq-to-cloud{3}:&nbsp;&nbsp; 10.128.0.0/24 === 192.168.0.0/24 <br>Статус ESTABLISHED означает, что туннель между шлюзами создан.<br>Сведения об установке и работе соединения находятся в логах strongSwan. Просмотреть логи можно с помощью команды:<br>sudo journalctl -u strongswan-starter <br>Проверить статус демона strongSwan можно командой:<br>systemctl status strongswan-starter <br>Осталось проверить связность соединения. Для этого создайте ещё одну тестовую виртуальную машину за вторым шлюзом, а затем пропингуйте одну тестовую машину с другой.<br><strong>Decision:</strong><br>$ ssh &lt;имя пользователя&gt;@130.193.32.25<br>$ sudo vim /etc/ipsec.conf<br>$ sudo cat /etc/ipsec.conf<br>...<br>config setup<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; charondebug="all"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniqueids=yes<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strictcrlpolicy=no<br>...<br>conn cloud-to-hq<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authby=secret<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left=%defaultroute<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftid=130.193.32.25<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftsubnet=10.128.0.0/24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right=1.1.1.1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rightsubnet=192.168.0.0/24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ike=aes256-sha2_256-modp1024!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esp=aes256-sha2_256!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyingtries=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ikelifetime=1h<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lifetime=8h<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpddelay=30<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpdtimeout=120<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpdaction=restart<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto=start<br>$ sudo vim /etc/ipsec.secrets<br>$ sudo cat /etc/ipsec.secrets<br>130.193.32.25 1.1.1.1 : PSK "&lt;пароль&gt;"<br>$ sudo systemctl restart strongswan-starter<br>$ exit <br>$ ssh &lt;имя пользователя&gt;@130.193.32.26<br>$ sudo vim /etc/ipsec.conf<br>$ sudo cat /etc/ipsec.conf<br>...<br>config setup<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; charondebug="all"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniqueids=yes<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strictcrlpolicy=no<br>...<br>conn hq-to-cloud<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authby=secret<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left=%defaultroute<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftid=1.1.1.1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftsubnet=192.168.0.0/24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right=130.193.32.25<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rightsubnet=10.128.0.0/24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ike=aes256-sha2_256-modp1024!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esp=aes256-sha2_256!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyingtries=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ikelifetime=1h<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lifetime=8h<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpddelay=30<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpdtimeout=120<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dpdaction=restart<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto=start<br>$ sudo vim /etc/ipsec.secrets<br>$ sudo cat /etc/ipsec.secrets<br>1.1.1.1 130.193.32.25 : PSK "&lt;пароль&gt;"<br>$ sudo systemctl restart strongswan-starter<br>$ ssh &lt;имя пользователя&gt;@130.193.32.25<br>$ sudo ipsec status <br>$ sudo journalctl -u strongswan-starter<br>$ systemctl status strongswan-starter<br><strong>Task:</strong><br>Выпуск сертификата для сайта.<br>В этой практической работе мы зарегистрируем домен, привяжем его к бакету в объектном хранилище и настроим для этого домена автоматический выпуск сертификата с помощью Certificate Manager.<br><strong>Decision:</strong><br>Шаг 1<br>Если у вас нет своего домена, зарегистрируйте временный домен, например, на сайте freenom.com:<br>Проверьте на сайте доступность имени, которое вы придумали для своего домена.<br>Введите имя вместе с доменом верхнего уровня, например testpracticum2022.ml, иначе при попытке зарезервировать домен сервис будет сообщать, что домен занят.<br>Если это имя доступно, добавьте домен в корзину и укажите свой email для подтверждения.<br>Проверьте почту и подтвердите регистрацию домена.<br>Обновите страницу с заказом.<br>После подтверждения регистрации домена зайдите в объектное хранилище (Object Storage) и создайте новый публичный бакет. Его название должно совпадать с полным названием домена.<br>Переключите доступ на чтение объектов в Публичный. Загрузите в бакет файлы статического сайта (вы можете воспользоваться файлами из практической работы курса &laquo;Хранение и анализ данных&raquo;.<br>Выберите на панели управления раздел Веб-сайт, переключите бакет в режим Хостинг и нажмите Сохранить.<br>Шаг 2<br>Настроить защищённый доступ к бакету можно двумя способами: загрузить сертификат прямо в бакет или с помощью Certificate Manager. Воспользуемся вторым способом.<br>В консоли управления перейдите в сервис Certificate Manager. Для выпуска сертификата с помощью этого сервиса подтвердите владение доменом: в разделе Сертификаты нажмите кнопку Добавить сертификат и выберите Сертификат Let&rsquo;s Encrypt.<br>В открывшемся окне задайте имя создаваемого сертификата и заполните поле с именем вашего домена. Нажмите кнопку Создать.<br>Сервис автоматически направит запрос на создание сертификата, а домен перейдёт в статус проверки.<br>Для выпуска сертификата необходимо подтвердить статус владения доменом. Откройте страницу с деталями запроса на сертификат:<br>На этой странице для нас важны два поля: имя DNS-записи и её значение. Если вы создавали домен на freenom.com, то перейдите в личный кабинет на этом сайте, выберите раздел Services &rarr; My Domains и нажмите кнопку Manage Domains:<br>Выберите Manage Freenom DNS:<br>В открывшемся редакторе добавьте TXT-запись для подтверждения владения доменом. В качестве названия записи задайте _acme-challenge без полного названия домена. В качестве значения TXT-записи &mdash; значение со страницы проверки прав на домен в консоли управления Yandex Cloud.<br>Аналогично внесите значение CNAME-записи со страницы проверки прав на домен в консоли управления Yandex Cloud.<br>Добавьте также запись CNAME для привязки поддомена WWW к вашему бакету:<br>В поле Target укажите полное имя бакета, включая .website.yandexcloud.net. Сохраните сделанные изменения.<br>Если вы используете собственный домен, задайте параметры DNS в настройках вашего DNS-сервера. Для применения настроек DNS потребуется некоторое время &mdash; обычно до 15 минут.<br>После окончания проверки домена Certificate Manager автоматически выпустит сертификат.<br>Шаг 3<br>Теперь настроим доступ к сайту, то есть к созданному бакету, по протоколу HTTPS с помощью сертификата. Для этого перейдите в раздел HTTPS и нажмите кнопку Настроить.<br>В поле Источник выберите Certificate Manager, в поле Сертификат &mdash; ранее выпущенный сертификат. Нажмите кнопку Сохранить.<br>Теперь ваш сайт доступен по протоколу HTTPS. Чтобы проверить это, откройте его в браузере. В адресной строке браузера должен отображаться значок защищённого соединения.<br><strong>Task:</strong><br>Создание и ротация ключей шифрования<br>На прошлом уроке вы познакомились с возможностями сервиса управления ключами шифрования KMS. В этой практической работе вы научитесь создавать ключи шифрования и управлять ими, а также использовать эти ключи для шифрования и расшифрования данных.<br><strong>Decision:</strong><br>Шаг 1<br>Перейдите в панель управления Yandex Cloud, нажмите кнопку Создать ресурс и выберите из выпадающего списка пункт Ключ шифрования.<br>Задайте для создаваемого ключа имя (например yc-lab-key1), заполните поле Описание (это необязательно) и выберите алгоритм шифрования. Предположим, что ключ нужно ротировать каждый день. Для этого в поле Период ротации, дни выберите вариант Своё значение и введите число 1 в поле справа.<br>Нажмите кнопку Создать. Когда операция создания ключа завершится, новый ключ появится в списке.<br>Нажав на строку с ключом, вы перейдёте на страницу детальной информации. На ней приведены все параметры ключа, а также список его версий. Обратите внимание, что ID (идентификатор) ключа и ID конкретной версии ключа отличаются. Важно их не путать.<br>Шаг 2<br>Давайте используем созданный ключ для шифрования и расшифрования данных. Создайте у себя на диске файл (например, текстовый файл с именем plain.txt). Добавьте в него любой текст и сохраните содержимое. Напомним, что размер файла не должен превышать 32 килобайта.<br>Запустите утилиту командной строки (bash или cmd) и перейдите в каталог с файлом plain.txt. Зашифруйте этот файл с помощью утилиты yc, а результат операции шифрования выведите в файл encrypted.txt. Для этого выполните команду:<br>yc kms symmetric-crypto encrypt --id &lt;ID ключа&gt; --plaintext-file plain.txt --ciphertext-file encrypted.txt <br>После выполнения команды будет создан файл encrypted.txt, который содержит зашифрованный текст. Утилита yc также выведет информацию о том, каким ключом и какой его версией файл был зашифрован.<br>Шаг 3<br>Теперь расшифруйте этот файл, а результат операции выведите в файл decrypted.txt. Для этого выполните команду:<br>yc kms symmetric-crypto decrypt --id &lt;ID ключа&gt; --ciphertext-file encrypted.txt --plaintext-file decrypted.txt <br>В результате выполнения команды будет создан файл decrypted.txt с идентичным исходному файлу (plain.txt) содержимым.<br>Если расшифровать файл не удалось, утилита выдаст сообщение об ошибке.<br>Шаг 4<br>Создайте новую версию ключа. Для этого перейдите на страницу детальной информации о ключе и нажмите кнопку Ротировать. Новая версия ключа появится в списке версий и станет основной (Primary). Обратите внимание, что идентификаторы версий отличаются друг от друга.<br>Шаг 5<br>Запланируйте удаление первой версии ключа. Для этого в списке версий нажмите на значок &hellip; в строке с этой версией, а затем выберите пункт Запланировать удаление.<br>В появившемся окне установите время, по истечении которого ключ будет удалён, и нажмите Запланировать. Версия ключа не может быть удалена моментально, минимальный период времени для её удаления составляет один день.<br>После этого в списке версий удаляемый ключ будет помечен как запланированный на удаление (Scheduled For Destruction). Теперь этой версией ключа невозможно расшифровать файлы, которые были зашифрованы с её помощью.<br>Провести ротацию ключа можно и из командной строки. Для этого используется команда:<br>yc kms symmetric-key rotate &lt;ID ключа&gt; <br>Шаг 6<br>Зашифруйте исходный файл plain.txt с помощью новой версии ключа. Результат запишите в файл encrypted_with_new_key.txt.<br>yc kms symmetric-crypto encrypt --id &lt;ID ключа&gt; --plaintext-file plain.txt --ciphertext-file encrypted_with_new_key.txt <br>Теперь у вас есть два файла:<br>- encrypted.txt, зашифрованный версией ключа, которая помечена на удаление;<br>- encrypted_with_new_version.txt, зашифрованный новой версией ключа.<br>Попробуйте расшифровать данные из обоих файлов. Вы увидите, что расшифровать первый файл не получилось, а файл, который зашифрован второй версией ключа, расшифрован.<br>Запланированное удаление первой версии ключа можно отменить. Это позволит расшифровать данные из первого файла.<br>В строке версии ключа, которая запланирована на удаление, нажмите значок &hellip;, а затем кнопку кнопку Отменить удаление. Эта версия снова получит статус активной. Проверьте, что она работает, расшифровав файл encrypted.txt.<br><strong>Decision:</strong><br>$ vim plain.txt<br>$ cat plain.txt<br>test text<br>$ yc kms symmetric-crypto encrypt --id &lt;ID ключа&gt; --plaintext-file plain.txt --ciphertext-file encrypted.txt<br>$ yc kms symmetric-crypto encrypt --id abjkh5a8k2uao3f8qi8k --plaintext-file plain.txt --ciphertext-file encrypted.txt<br>$ cat encrypted.txt <br>abj2vjcrv89d83cef26in#���k��|�V�X�<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ����:�F���*Y��l�(���у��֜�l�S<br>$ yc kms symmetric-crypto decrypt --id &lt;ID ключа&gt; --ciphertext-file encrypted.txt --plaintext-file decrypted.txt<br>$ cat decrypted.txt <br>test text<br>$ yc kms symmetric-key rotate &lt;ID ключа&gt;<br>$ yc kms symmetric-crypto encrypt --id &lt;ID ключа&gt; --plaintext-file plain.txt --ciphertext-file encrypted_with_new_key.txt<br>$ cat encrypted_with_new_key.txt<br>abjofv85g302tc8mjhqq��n�nߊz6�5�A�<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; �)ڀi�R0����o��s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; �^<br>�m�C zci�b�'</p>